// Generated by: github.com/Feresey/gen-tgbotapi

package api

const Version = "4.9"

// TODO: category description

// Animation
// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
type Animation struct {
	// Duration
	// Duration of the video in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Video height as defined by sender
	Height int64 `json:"height"`
	// Width
	// Video width as defined by sender
	Width int64 `json:"width"`
	// FileName
	// Original animation filename as defined by sender
	FileName *string `json:"file_name,omitempty"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Thumb
	// Animation thumbnail as defined by sender
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *Animation) GetFileName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FileName; field != nil {
		return *field
	}
	return res
}

func (t *Animation) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Animation) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Animation) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// Audio
// This object represents an audio file to be treated as music by the Telegram clients.
type Audio struct {
	// Duration
	// Duration of the audio in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Performer
	// Performer of the audio as defined by sender or by audio tags
	Performer *string `json:"performer,omitempty"`
	// Thumb
	// Thumbnail of the album cover to which the music file belongs
	Thumb *PhotoSize `json:"thumb,omitempty"`
	// Title
	// Title of the audio as defined by sender or by audio tags
	Title *string `json:"title,omitempty"`
}

func (t *Audio) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetPerformer() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Performer; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// BotCommand
// This object represents a bot command.
type BotCommand struct {
	// Command
	// Text of the command, 1-32 characters. Can contain only lowercase English letters, digits and
	// underscores.
	Command string `json:"command"`
	// Description
	// Description of the command, 3-256 characters.
	Description string `json:"description"`
}

// CallbackGame
// A placeholder, currently holds no information. Use BotFather to set up your game.
type CallbackGame struct {
	// Score
	// New score, must be non-negative
	Score int64 `json:"score"`
	// UserID
	// User identifier
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID *int64 `json:"chat_id,omitempty"`
	// DisableEditMessage
	// Pass True, if the game message should not be automatically edited to include the current
	// scoreboard
	DisableEditMessage *bool `json:"disable_edit_message,omitempty"`
	// Force
	// Pass True, if the high score is allowed to decrease. This can be useful when fixing mistakes
	// or banning cheaters
	Force *bool `json:"force,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID *string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID *int64 `json:"message_id,omitempty"`
}

func (t *CallbackGame) GetChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ChatID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetDisableEditMessage() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableEditMessage; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetForce() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Force; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MessageID; field != nil {
		return *field
	}
	return res
}

// CallbackQuery
// This object represents an incoming callback query from a callback button in an inline keyboard.
// If the button that originated the query was attached to a message sent by the bot, the field
// message will be present. If the button was attached to a message sent via the bot (in inline
// mode), the field inline_message_id will be present. Exactly one of the fields data or
// game_short_name will be present.
type CallbackQuery struct {
	// ChatInstance
	// Global identifier, uniquely corresponding to the chat to which the message with the callback
	// button was sent. Useful for high scores in games.
	ChatInstance string `json:"chat_instance"`
	// From
	// Sender
	From User `json:"from"`
	// ID
	// Unique identifier for this query
	ID string `json:"id"`
	// Data
	// Data associated with the callback button. Be aware that a bad client can send arbitrary data
	// in this field.
	Data *string `json:"data,omitempty"`
	// GameShortName
	// Short name of a Game to be returned, serves as the unique identifier for the game
	GameShortName *string `json:"game_short_name,omitempty"`
	// InlineMessageID
	// Identifier of the message sent via the bot in inline mode, that originated the query.
	InlineMessageID *string `json:"inline_message_id,omitempty"`
	// Message
	// Message with the callback button that originated the query. Note that message content and
	// message date will not be available if the message is too old
	Message *Message `json:"message,omitempty"`
}

func (t *CallbackQuery) GetData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Data; field != nil {
		return *field
	}
	return res
}

func (t *CallbackQuery) GetGameShortName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GameShortName; field != nil {
		return *field
	}
	return res
}

func (t *CallbackQuery) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackQuery) GetMessage() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.Message; field != nil {
		return *field
	}
	return res
}

// Chat
// This object represents a chat.
type Chat struct {
	// ID
	// Unique identifier for this chat. This number may be greater than 32 bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it is
	// smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for
	// storing this identifier.
	ID int64 `json:"id"`
	// Type
	// Type of chat, can be either "private", "group", "supergroup" or "channel"
	Type ChatType `json:"type"`
	// CanSetStickerSet
	// True, if the bot can change the group sticker set. Returned only in getChat.
	CanSetStickerSet *bool `json:"can_set_sticker_set,omitempty"`
	// Description
	// Description, for groups, supergroups and channel chats. Returned only in getChat.
	Description *string `json:"description,omitempty"`
	// FirstName
	// First name of the other party in a private chat
	FirstName *string `json:"first_name,omitempty"`
	// InviteLink
	// Chat invite link, for groups, supergroups and channel chats. Each administrator in a chat
	// generates their own invite links, so the bot must first generate the link using
	// exportChatInviteLink. Returned only in getChat.
	InviteLink *string `json:"invite_link,omitempty"`
	// LastName
	// Last name of the other party in a private chat
	LastName *string `json:"last_name,omitempty"`
	// Permissions
	// Default chat member permissions, for groups and supergroups. Returned only in getChat.
	Permissions *ChatPermissions `json:"permissions,omitempty"`
	// Photo
	// Chat photo. Returned only in getChat.
	Photo *ChatPhoto `json:"photo,omitempty"`
	// PinnedMessage
	// Pinned message, for groups, supergroups and channels. Returned only in getChat.
	PinnedMessage *Message `json:"pinned_message,omitempty"`
	// SlowModeDelay
	// For supergroups, the minimum allowed delay between consecutive messages sent by each
	// unpriviledged user. Returned only in getChat.
	SlowModeDelay *int64 `json:"slow_mode_delay,omitempty"`
	// StickerSetName
	// For supergroups, name of group sticker set. Returned only in getChat.
	StickerSetName *string `json:"sticker_set_name,omitempty"`
	// Title
	// Title, for supergroups, channels and group chats
	Title *string `json:"title,omitempty"`
	// Username
	// Username, for private chats, supergroups and channels if available
	Username *string `json:"username,omitempty"`
}

func (t *Chat) GetCanSetStickerSet() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSetStickerSet; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetFirstName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FirstName; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetInviteLink() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InviteLink; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetPermissions() ChatPermissions {
	var res ChatPermissions
	if t == nil {
		return res
	}
	if field := t.Permissions; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetPhoto() ChatPhoto {
	var res ChatPhoto
	if t == nil {
		return res
	}
	if field := t.Photo; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetPinnedMessage() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.PinnedMessage; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetSlowModeDelay() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.SlowModeDelay; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetStickerSetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.StickerSetName; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetUsername() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Username; field != nil {
		return *field
	}
	return res
}

// ChatMember
// This object contains information about one member of a chat.
type ChatMember struct {
	// Status
	// The member's status in the chat. Can be "creator", "administrator", "member", "restricted",
	// "left" or "kicked"
	Status string `json:"status"`
	// User
	// Information about the user
	User User `json:"user"`
	// CanAddWebPagePreviews
	// Restricted only. True, if the user is allowed to add web page previews to their messages
	CanAddWebPagePreviews *bool `json:"can_add_web_page_previews,omitempty"`
	// CanBeEdited
	// Administrators only. True, if the bot is allowed to edit administrator privileges of that
	// user
	CanBeEdited *bool `json:"can_be_edited,omitempty"`
	// CanChangeInfo
	// Administrators and restricted only. True, if the user is allowed to change the chat title,
	// photo and other settings
	CanChangeInfo *bool `json:"can_change_info,omitempty"`
	// CanDeleteMessages
	// Administrators only. True, if the administrator can delete messages of other users
	CanDeleteMessages *bool `json:"can_delete_messages,omitempty"`
	// CanEditMessages
	// Administrators only. True, if the administrator can edit messages of other users and can pin
	// messages; channels only
	CanEditMessages *bool `json:"can_edit_messages,omitempty"`
	// CanInviteUsers
	// Administrators and restricted only. True, if the user is allowed to invite new users to the
	// chat
	CanInviteUsers *bool `json:"can_invite_users,omitempty"`
	// CanPinMessages
	// Administrators and restricted only. True, if the user is allowed to pin messages; groups and
	// supergroups only
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`
	// CanPostMessages
	// Administrators only. True, if the administrator can post in the channel; channels only
	CanPostMessages *bool `json:"can_post_messages,omitempty"`
	// CanPromoteMembers
	// Administrators only. True, if the administrator can add new administrators with a subset of
	// their own privileges or demote administrators that he has promoted, directly or indirectly
	// (promoted by administrators that were appointed by the user)
	CanPromoteMembers *bool `json:"can_promote_members,omitempty"`
	// CanRestrictMembers
	// Administrators only. True, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers *bool `json:"can_restrict_members,omitempty"`
	// CanSendMediaMessages
	// Restricted only. True, if the user is allowed to send audios, documents, photos, videos,
	// video notes and voice notes
	CanSendMediaMessages *bool `json:"can_send_media_messages,omitempty"`
	// CanSendMessages
	// Restricted only. True, if the user is allowed to send text messages, contacts, locations and
	// venues
	CanSendMessages *bool `json:"can_send_messages,omitempty"`
	// CanSendOtherMessages
	// Restricted only. True, if the user is allowed to send animations, games, stickers and use
	// inline bots
	CanSendOtherMessages *bool `json:"can_send_other_messages,omitempty"`
	// CanSendPolls
	// Restricted only. True, if the user is allowed to send polls
	CanSendPolls *bool `json:"can_send_polls,omitempty"`
	// CustomTitle
	// Owner and administrators only. Custom title for this user
	CustomTitle *string `json:"custom_title,omitempty"`
	// IsMember
	// Restricted only. True, if the user is a member of the chat at the moment of the request
	IsMember *bool `json:"is_member,omitempty"`
	// UntilDate
	// Restricted and kicked only. Date when restrictions will be lifted for this user; unix time
	UntilDate *int64 `json:"until_date,omitempty"`
}

func (t *ChatMember) GetCanAddWebPagePreviews() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanAddWebPagePreviews; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanBeEdited() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanBeEdited; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanChangeInfo() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanChangeInfo; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanDeleteMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanDeleteMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanEditMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanEditMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanInviteUsers() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanInviteUsers; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanPinMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPinMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanPostMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPostMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanPromoteMembers() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPromoteMembers; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanRestrictMembers() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanRestrictMembers; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanSendMediaMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendMediaMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanSendMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanSendOtherMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendOtherMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCanSendPolls() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendPolls; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetCustomTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomTitle; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetIsMember() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.IsMember; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetUntilDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.UntilDate; field != nil {
		return *field
	}
	return res
}

// ChatPermissions
// Describes actions that a non-administrator user is allowed to take in a chat.
type ChatPermissions struct {
	// CanAddWebPagePreviews
	// True, if the user is allowed to add web page previews to their messages, implies
	// can_send_media_messages
	CanAddWebPagePreviews *bool `json:"can_add_web_page_previews,omitempty"`
	// CanChangeInfo
	// True, if the user is allowed to change the chat title, photo and other settings. Ignored in
	// public supergroups
	CanChangeInfo *bool `json:"can_change_info,omitempty"`
	// CanInviteUsers
	// True, if the user is allowed to invite new users to the chat
	CanInviteUsers *bool `json:"can_invite_users,omitempty"`
	// CanPinMessages
	// True, if the user is allowed to pin messages. Ignored in public supergroups
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`
	// CanSendMediaMessages
	// True, if the user is allowed to send audios, documents, photos, videos, video notes and
	// voice notes, implies can_send_messages
	CanSendMediaMessages *bool `json:"can_send_media_messages,omitempty"`
	// CanSendMessages
	// True, if the user is allowed to send text messages, contacts, locations and venues
	CanSendMessages *bool `json:"can_send_messages,omitempty"`
	// CanSendOtherMessages
	// True, if the user is allowed to send animations, games, stickers and use inline bots,
	// implies can_send_media_messages
	CanSendOtherMessages *bool `json:"can_send_other_messages,omitempty"`
	// CanSendPolls
	// True, if the user is allowed to send polls, implies can_send_messages
	CanSendPolls *bool `json:"can_send_polls,omitempty"`
}

func (t *ChatPermissions) GetCanAddWebPagePreviews() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanAddWebPagePreviews; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanChangeInfo() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanChangeInfo; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanInviteUsers() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanInviteUsers; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanPinMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPinMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendMediaMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendMediaMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendOtherMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendOtherMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendPolls() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendPolls; field != nil {
		return *field
	}
	return res
}

// ChatPhoto
// This object represents a chat photo.
type ChatPhoto struct {
	// BigFileID
	// File identifier of big (640x640) chat photo. This file_id can be used only for photo
	// download and only for as long as the photo is not changed.
	BigFileID string `json:"big_file_id"`
	// BigFileUniqueID
	// Unique file identifier of big (640x640) chat photo, which is supposed to be the same over
	// time and for different bots. Can't be used to download or reuse the file.
	BigFileUniqueID string `json:"big_file_unique_id"`
	// SmallFileID
	// File identifier of small (160x160) chat photo. This file_id can be used only for photo
	// download and only for as long as the photo is not changed.
	SmallFileID string `json:"small_file_id"`
	// SmallFileUniqueID
	// Unique file identifier of small (160x160) chat photo, which is supposed to be the same over
	// time and for different bots. Can't be used to download or reuse the file.
	SmallFileUniqueID string `json:"small_file_unique_id"`
}

// ChosenInlineResult
// Represents a result of an inline query that was chosen by the user and sent to their chat
// partner.
type ChosenInlineResult struct {
	// From
	// The user that chose the result
	From User `json:"from"`
	// Query
	// The query that was used to obtain the result
	Query string `json:"query"`
	// ResultID
	// The unique identifier for the result that was chosen
	ResultID string `json:"result_id"`
	// InlineMessageID
	// Identifier of the sent inline message. Available only if there is an inline keyboard
	// attached to the message. Will be also received in callback queries and can be used to edit
	// the message.
	InlineMessageID *string `json:"inline_message_id,omitempty"`
	// Location
	// Sender location, only for bots that require user location
	Location *Location `json:"location,omitempty"`
}

func (t *ChosenInlineResult) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

func (t *ChosenInlineResult) GetLocation() Location {
	var res Location
	if t == nil {
		return res
	}
	if field := t.Location; field != nil {
		return *field
	}
	return res
}

// Contact
// This object represents a phone contact.
type Contact struct {
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// LastName
	// Contact's last name
	LastName *string `json:"last_name,omitempty"`
	// UserID
	// Contact's user identifier in Telegram
	UserID *int64 `json:"user_id,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard
	Vcard *string `json:"vcard,omitempty"`
}

func (t *Contact) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *Contact) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.UserID; field != nil {
		return *field
	}
	return res
}

func (t *Contact) GetVcard() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Vcard; field != nil {
		return *field
	}
	return res
}

// Dice
// This object represents an animated emoji that displays a random value.
type Dice struct {
	// Emoji
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`
	// Value
	// Value of the dice, 1-6 for "" and "" base emoji, 1-5 for "" base emoji
	Value int64 `json:"value"`
}

// Document
// This object represents a general file (as opposed to photos, voice messages and audio files).
type Document struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FileName
	// Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Thumb
	// Document thumbnail as defined by sender
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *Document) GetFileName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FileName; field != nil {
		return *field
	}
	return res
}

func (t *Document) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Document) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Document) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// EncryptedCredentials
// Contains data required for decrypting and authenticating EncryptedPassportElement. See the
// Telegram Passport Documentation for a complete description of the data decryption and
// authentication processes.
type EncryptedCredentials struct {
	// Data
	// Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and
	// secrets required for EncryptedPassportElement decryption and authentication
	Data string `json:"data"`
	// Hash
	// Base64-encoded data hash for data authentication
	Hash string `json:"hash"`
	// Secret
	// Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption
	Secret string `json:"secret"`
}

// EncryptedPassportElement
// Contains information about documents or other Telegram Passport elements shared with the bot by
// the user.
type EncryptedPassportElement struct {
	// Hash
	// Base64-encoded element hash for using in PassportElementErrorUnspecified
	Hash string `json:"hash"`
	// Type
	// Element type. One of "personal_details", "passport", "driver_license", "identity_card",
	// "internal_passport", "address", "utility_bill", "bank_statement", "rental_agreement",
	// "passport_registration", "temporary_registration", "phone_number", "email".
	Type EncryptedType `json:"type"`
	// Data
	// Base64-encoded encrypted Telegram Passport element data provided by the user, available for
	// "personal_details", "passport", "driver_license", "identity_card", "internal_passport" and
	// "address" types. Can be decrypted and verified using the accompanying EncryptedCredentials.
	Data *string `json:"data,omitempty"`
	// Email
	// User's verified email address, available only for "email" type
	Email *string `json:"email,omitempty"`
	// Files
	// Array of encrypted files with documents provided by the user, available for "utility_bill",
	// "bank_statement", "rental_agreement", "passport_registration" and "temporary_registration"
	// types. Files can be decrypted and verified using the accompanying EncryptedCredentials.
	Files []PassportFile `json:"files,omitempty"`
	// FrontSide
	// Encrypted file with the front side of the document, provided by the user. Available for
	// "passport", "driver_license", "identity_card" and "internal_passport". The file can be
	// decrypted and verified using the accompanying EncryptedCredentials.
	FrontSide *PassportFile `json:"front_side,omitempty"`
	// PhoneNumber
	// User's verified phone number, available only for "phone_number" type
	PhoneNumber *string `json:"phone_number,omitempty"`
	// ReverseSide
	// Encrypted file with the reverse side of the document, provided by the user. Available for
	// "driver_license" and "identity_card". The file can be decrypted and verified using the
	// accompanying EncryptedCredentials.
	ReverseSide *PassportFile `json:"reverse_side,omitempty"`
	// Selfie
	// Encrypted file with the selfie of the user holding a document, provided by the user;
	// available for "passport", "driver_license", "identity_card" and "internal_passport". The
	// file can be decrypted and verified using the accompanying EncryptedCredentials.
	Selfie *PassportFile `json:"selfie,omitempty"`
	// Translation
	// Array of encrypted files with translated versions of documents provided by the user.
	// Available if requested for "passport", "driver_license", "identity_card",
	// "internal_passport", "utility_bill", "bank_statement", "rental_agreement",
	// "passport_registration" and "temporary_registration" types. Files can be decrypted and
	// verified using the accompanying EncryptedCredentials.
	Translation []PassportFile `json:"translation,omitempty"`
}

func (t *EncryptedPassportElement) GetData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Data; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetEmail() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Email; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetFrontSide() PassportFile {
	var res PassportFile
	if t == nil {
		return res
	}
	if field := t.FrontSide; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetReverseSide() PassportFile {
	var res PassportFile
	if t == nil {
		return res
	}
	if field := t.ReverseSide; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetSelfie() PassportFile {
	var res PassportFile
	if t == nil {
		return res
	}
	if field := t.Selfie; field != nil {
		return *field
	}
	return res
}

// File
// This object represents a file ready to be downloaded. The file can be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be
// valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile.
type File struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FilePath
	// File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file.
	FilePath *string `json:"file_path,omitempty"`
	// FileSize
	// File size, if known
	FileSize *int64 `json:"file_size,omitempty"`
}

func (t *File) GetFilePath() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FilePath; field != nil {
		return *field
	}
	return res
}

func (t *File) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

// ForceReply
// Upon receiving a message with this object, Telegram clients will display a reply interface to
// the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be
// extremely useful if you want to create user-friendly step-by-step interfaces without having to
// sacrifice privacy mode.
type ForceReply struct {
	// ForceReply
	// Shows reply interface to the user, as if they manually selected the bot's message and tapped
	// 'Reply'
	ForceReply True `json:"force_reply"`
	// Selective
	// Use this parameter if you want to force reply from specific users only. Targets: 1) users
	// that are @mentioned in the text of the Message object; 2) if the bot's message is a reply
	// (has reply_to_message_id), sender of the original message.
	Selective *bool `json:"selective,omitempty"`
}

func (t *ForceReply) GetSelective() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Selective; field != nil {
		return *field
	}
	return res
}

// Game
// This object represents a game. Use BotFather to create and edit games, their short names will
// act as unique identifiers.
type Game struct {
	// Description
	// Description of the game
	Description string `json:"description"`
	// Photo
	// Photo that will be displayed in the game message in chats.
	Photo []PhotoSize `json:"photo"`
	// Title
	// Title of the game
	Title string `json:"title"`
	// Animation
	// Animation that will be displayed in the game message in chats. Upload via BotFather
	Animation *Animation `json:"animation,omitempty"`
	// Text
	// Brief description of the game or high scores included in the game message. Can be
	// automatically edited to include current high scores for the game when the bot calls
	// setGameScore, or manually edited using editMessageText. 0-4096 characters.
	Text *string `json:"text,omitempty"`
	// TextEntities
	// Special entities that appear in text, such as usernames, URLs, bot commands, etc.
	TextEntities []MessageEntity `json:"text_entities,omitempty"`
}

func (t *Game) GetAnimation() Animation {
	var res Animation
	if t == nil {
		return res
	}
	if field := t.Animation; field != nil {
		return *field
	}
	return res
}

func (t *Game) GetText() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Text; field != nil {
		return *field
	}
	return res
}

// GameHighScore
// This object represents one row of the high scores table for a game.
type GameHighScore struct {
	// Position
	// Position in high score table for the game
	Position int64 `json:"position"`
	// Score
	// Score
	Score int64 `json:"score"`
	// User
	// User
	User User `json:"user"`
}

// Games
// Your bot can offer users HTML5 games to play solo or to compete against each other in groups and
// one-on-one chats. Create games via @BotFather using the /newgame command. Please note that this
// kind of power requires responsibility: you will need to accept the terms for each game that your
// bots will be offering.
type Games struct {
	// ChatID
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`
	// GameShortName
	// Short name of the game, serves as the unique identifier for the game. Set up your games via
	// Botfather.
	GameShortName string `json:"game_short_name"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will
	// be shown. If not empty, the first button must launch the game.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID *int64 `json:"reply_to_message_id,omitempty"`
}

func (t *Games) GetDisableNotification() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableNotification; field != nil {
		return *field
	}
	return res
}

func (t *Games) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *Games) GetReplyToMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ReplyToMessageID; field != nil {
		return *field
	}
	return res
}

// InlineKeyboardButton
// This object represents one button of an inline keyboard. You must use exactly one of the
// optional fields.
type InlineKeyboardButton struct {
	// Text
	// Label text on the button
	Text string `json:"text"`
	// CallbackData
	// Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes
	CallbackData *string `json:"callback_data,omitempty"`
	// CallbackGame
	// Description of the game that will be launched when the user presses the button.NOTE: This
	// type of button must always be the first button in the first row.
	CallbackGame *CallbackGame `json:"callback_game,omitempty"`
	// LoginURL
	// An HTTP URL used to automatically authorize the user. Can be used as a replacement for the
	// Telegram Login Widget.
	LoginURL *LoginURL `json:"login_url,omitempty"`
	// Pay
	// Specify True, to send a Pay button.NOTE: This type of button must always be the first button
	// in the first row.
	Pay *bool `json:"pay,omitempty"`
	// SwitchInlineQuery
	// If set, pressing the button will prompt the user to select one of their chats, open that
	// chat and insert the bot's username and the specified inline query in the input field. Can be
	// empty, in which case just the bot's username will be inserted.Note: This offers an easy way
	// for users to start using your bot in inline mode when they are currently in a private chat
	// with it. Especially useful when combined with switch_pmâ€¦ actions - in this case the user
	// will be automatically returned to the chat they switched from, skipping the chat selection
	// screen.
	SwitchInlineQuery *string `json:"switch_inline_query,omitempty"`
	// SwitchInlineQueryCurrentChat
	// If set, pressing the button will insert the bot's username and the specified inline query in
	// the current chat's input field. Can be empty, in which case only the bot's username will be
	// inserted.This offers a quick way for the user to open your bot in inline mode in the same
	// chat - good for selecting something from multiple options.
	SwitchInlineQueryCurrentChat *string `json:"switch_inline_query_current_chat,omitempty"`
	// URL
	// HTTP or tg:// url to be opened when button is pressed
	URL *string `json:"url,omitempty"`
}

func (t *InlineKeyboardButton) GetCallbackData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CallbackData; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetCallbackGame() CallbackGame {
	var res CallbackGame
	if t == nil {
		return res
	}
	if field := t.CallbackGame; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetLoginURL() LoginURL {
	var res LoginURL
	if t == nil {
		return res
	}
	if field := t.LoginURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetPay() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Pay; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetSwitchInlineQuery() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SwitchInlineQuery; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetSwitchInlineQueryCurrentChat() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SwitchInlineQueryCurrentChat; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

// InlineKeyboardMarkup
// This object represents an inline keyboard that appears right next to the message it belongs to.
type InlineKeyboardMarkup struct {
	// InlineKeyboard
	// Array of button rows, each represented by an Array of InlineKeyboardButton objects
	InlineKeyboard [][]InlineKeyboardButton `json:"inline_keyboard"`
}

// InlineQuery
// This object represents an incoming inline query. When the user sends an empty query, your bot
// could return some default or trending results.
type InlineQuery struct {
	// From
	// Sender
	From User `json:"from"`
	// ID
	// Unique identifier for this query
	ID string `json:"id"`
	// Offset
	// Offset of the results to be returned, can be controlled by the bot
	Offset string `json:"offset"`
	// Query
	// Text of the query (up to 256 characters)
	Query string `json:"query"`
	// Location
	// Sender location, only for bots that request user location
	Location *Location `json:"location,omitempty"`
}

func (t *InlineQuery) GetLocation() Location {
	var res Location
	if t == nil {
		return res
	}
	if field := t.Location; field != nil {
		return *field
	}
	return res
}

// InlineQueryResult
// This object represents one result of an inline query. Telegram clients currently support results
// of the following 20 types:
type InlineQueryResult struct {
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// InputMessageContent
	// Content of the message to be sent
	InputMessageContent InputMessageContent `json:"input_message_content"`
	// Title
	// Title of the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be article
	Type InlineType `json:"type"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// HideURL
	// Pass True, if you don't want the URL to be shown in the message
	HideURL *bool `json:"hide_url,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbHeight
	// Thumbnail height
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// ThumbURL
	// Url of the thumbnail for the result
	ThumbURL *string `json:"thumb_url,omitempty"`
	// ThumbWidth
	// Thumbnail width
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
	// URL
	// URL of the result
	URL *string `json:"url,omitempty"`
}

func (t *InlineQueryResult) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetHideURL() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HideURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetThumbHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetThumbURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetThumbWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultArticle
// Represents a link to an article or web page.
type InlineQueryResultArticle struct {
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// InputMessageContent
	// Content of the message to be sent
	InputMessageContent InputMessageContent `json:"input_message_content"`
	// Title
	// Title of the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be article
	Type InlineType `json:"type"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// HideURL
	// Pass True, if you don't want the URL to be shown in the message
	HideURL *bool `json:"hide_url,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbHeight
	// Thumbnail height
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// ThumbURL
	// Url of the thumbnail for the result
	ThumbURL *string `json:"thumb_url,omitempty"`
	// ThumbWidth
	// Thumbnail width
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
	// URL
	// URL of the result
	URL *string `json:"url,omitempty"`
}

func (t *InlineQueryResultArticle) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetHideURL() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HideURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetThumbHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetThumbURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetThumbWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultAudio
// Represents a link to an MP3 audio file. By default, this audio file will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content
// instead of the audio.
type InlineQueryResultAudio struct {
	// AudioURL
	// A valid URL for the audio file
	AudioURL string `json:"audio_url"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Title
	Title string `json:"title"`
	// Type
	// Type of the result, must be audio
	Type InlineType `json:"type"`
	// AudioDuration
	// Audio duration in seconds
	AudioDuration *int64 `json:"audio_duration,omitempty"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the audio
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Performer
	// Performer
	Performer *string `json:"performer,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultAudio) GetAudioDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.AudioDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetPerformer() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Performer; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedAudio
// Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio
// file will be sent by the user. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the audio.
type InlineQueryResultCachedAudio struct {
	// AudioFileID
	// A valid file identifier for the audio file
	AudioFileID string `json:"audio_file_id"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Type
	// Type of the result, must be audio
	Type InlineType `json:"type"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the audio
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedAudio) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedAudio) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedAudio) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedAudio) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedDocument
// Represents a link to a file stored on the Telegram servers. By default, this file will be sent
// by the user with an optional caption. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the file.
type InlineQueryResultCachedDocument struct {
	// DocumentFileID
	// A valid file identifier for the file
	DocumentFileID string `json:"document_file_id"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be document
	Type InlineType `json:"type"`
	// Caption
	// Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the file
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedDocument) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedGif
// Represents a link to an animated GIF file stored on the Telegram servers. By default, this
// animated GIF file will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with specified content instead of the animation.
type InlineQueryResultCachedGif struct {
	// GifFileID
	// A valid file identifier for the GIF file
	GifFileID string `json:"gif_file_id"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Type
	// Type of the result, must be gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the GIF file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the GIF animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultCachedGif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedMpeg4Gif
// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the
// Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an
// optional caption. Alternatively, you can use input_message_content to send a message with the
// specified content instead of the animation.
type InlineQueryResultCachedMpeg4Gif struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Mpeg4FileID
	// A valid file identifier for the MP4 file
	Mpeg4FileID string `json:"mpeg4_file_id"`
	// Type
	// Type of the result, must be mpeg4_gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultCachedMpeg4Gif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedPhoto
// Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent
// by the user with an optional caption. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the photo.
type InlineQueryResultCachedPhoto struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// PhotoFileID
	// A valid file identifier of the photo
	PhotoFileID string `json:"photo_file_id"`
	// Type
	// Type of the result, must be photo
	Type InlineType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the photo
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultCachedPhoto) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedSticker
// Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be
// sent by the user. Alternatively, you can use input_message_content to send a message with the
// specified content instead of the sticker.
type InlineQueryResultCachedSticker struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// StickerFileID
	// A valid file identifier of the sticker
	StickerFileID string `json:"sticker_file_id"`
	// Type
	// Type of the result, must be sticker
	Type InlineType `json:"type"`
	// InputMessageContent
	// Content of the message to be sent instead of the sticker
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedSticker) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedSticker) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedVideo
// Represents a link to a video file stored on the Telegram servers. By default, this video file
// will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the video.
type InlineQueryResultCachedVideo struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be video
	Type InlineType `json:"type"`
	// VideoFileID
	// A valid file identifier for the video file
	VideoFileID string `json:"video_file_id"`
	// Caption
	// Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedVideo) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultCachedVoice
// Represents a link to a voice message stored on the Telegram servers. By default, this voice
// message will be sent by the user. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the voice message.
type InlineQueryResultCachedVoice struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Voice message title
	Title string `json:"title"`
	// Type
	// Type of the result, must be voice
	Type InlineType `json:"type"`
	// VoiceFileID
	// A valid file identifier for the voice message
	VoiceFileID string `json:"voice_file_id"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the voice message
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedVoice) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVoice) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVoice) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVoice) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultContact
// Represents a contact with a phone number. By default, this contact will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content
// instead of the contact.
type InlineQueryResultContact struct {
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// Type
	// Type of the result, must be contact
	Type InlineType `json:"type"`
	// InputMessageContent
	// Content of the message to be sent instead of the contact
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// LastName
	// Contact's last name
	LastName *string `json:"last_name,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbHeight
	// Thumbnail height
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// ThumbURL
	// Url of the thumbnail for the result
	ThumbURL *string `json:"thumb_url,omitempty"`
	// ThumbWidth
	// Thumbnail width
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

func (t *InlineQueryResultContact) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetThumbHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetThumbURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetThumbWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetVcard() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Vcard; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultDocument
// Represents a link to a file. By default, this file will be sent by the user with an optional
// caption. Alternatively, you can use input_message_content to send a message with the specified
// content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.
type InlineQueryResultDocument struct {
	// DocumentURL
	// A valid URL for the file
	DocumentURL string `json:"document_url"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// MimeType
	// Mime type of the content of the file, either "application/pdf" or "application/zip"
	MimeType string `json:"mime_type"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be document
	Type InlineType `json:"type"`
	// Caption
	// Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the file
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbHeight
	// Thumbnail height
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// ThumbURL
	// URL of the thumbnail (jpeg only) for the file
	ThumbURL *string `json:"thumb_url,omitempty"`
	// ThumbWidth
	// Thumbnail width
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
}

func (t *InlineQueryResultDocument) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetThumbHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetThumbURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetThumbWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbWidth; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultGame
// Represents a Game.
type InlineQueryResultGame struct {
	// GameShortName
	// Short name of the game
	GameShortName string `json:"game_short_name"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Type
	// Type of the result, must be game
	Type InlineType `json:"type"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultGame) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultGif
// Represents a link to an animated GIF file. By default, this animated GIF file will be sent by
// the user with optional caption. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the animation.
type InlineQueryResultGif struct {
	// GifURL
	// A valid URL for the GIF file. File size must not exceed 1MB
	GifURL string `json:"gif_url"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// ThumbURL
	// URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result
	ThumbURL string `json:"thumb_url"`
	// Type
	// Type of the result, must be gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the GIF file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// GifDuration
	// Duration of the GIF
	GifDuration *int64 `json:"gif_duration,omitempty"`
	// GifHeight
	// Height of the GIF
	GifHeight *int64 `json:"gif_height,omitempty"`
	// GifWidth
	// Width of the GIF
	GifWidth *int64 `json:"gif_width,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the GIF animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbMimeType
	// MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4".
	// Defaults to "image/jpeg"
	ThumbMimeType *string `json:"thumb_mime_type,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultGif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetGifDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.GifDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetGifHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.GifHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetGifWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.GifWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetThumbMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbMimeType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultLocation
// Represents a location on a map. By default, the location will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content
// instead of the location.
type InlineQueryResultLocation struct {
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// Latitude
	// Location latitude in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Location longitude in degrees
	Longitude float64 `json:"longitude"`
	// Title
	// Location title
	Title string `json:"title"`
	// Type
	// Type of the result, must be location
	Type InlineType `json:"type"`
	// InputMessageContent
	// Content of the message to be sent instead of the location
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// LivePeriod
	// Period in seconds for which the location can be updated, should be between 60 and 86400.
	LivePeriod *int64 `json:"live_period,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbHeight
	// Thumbnail height
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// ThumbURL
	// Url of the thumbnail for the result
	ThumbURL *string `json:"thumb_url,omitempty"`
	// ThumbWidth
	// Thumbnail width
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
}

func (t *InlineQueryResultLocation) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetLivePeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LivePeriod; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetThumbHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetThumbURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetThumbWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbWidth; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultMpeg4Gif
// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this
// animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the animation.
type InlineQueryResultMpeg4Gif struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Mpeg4URL
	// A valid URL for the MP4 file. File size must not exceed 1MB
	Mpeg4URL string `json:"mpeg4_url"`
	// ThumbURL
	// URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result
	ThumbURL string `json:"thumb_url"`
	// Type
	// Type of the result, must be mpeg4_gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// Mpeg4Duration
	// Video duration
	Mpeg4Duration *int64 `json:"mpeg4_duration,omitempty"`
	// Mpeg4Height
	// Video height
	Mpeg4Height *int64 `json:"mpeg4_height,omitempty"`
	// Mpeg4Width
	// Video width
	Mpeg4Width *int64 `json:"mpeg4_width,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbMimeType
	// MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4".
	// Defaults to "image/jpeg"
	ThumbMimeType *string `json:"thumb_mime_type,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultMpeg4Gif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4Duration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Mpeg4Duration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4Height() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Mpeg4Height; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4Width() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Mpeg4Width; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetThumbMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbMimeType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultPhoto
// Represents a link to a photo. By default, this photo will be sent by the user with optional
// caption. Alternatively, you can use input_message_content to send a message with the specified
// content instead of the photo.
type InlineQueryResultPhoto struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// PhotoURL
	// A valid URL of the photo. Photo must be in jpeg format. Photo size must not exceed 5MB
	PhotoURL string `json:"photo_url"`
	// ThumbURL
	// URL of the thumbnail for the photo
	ThumbURL string `json:"thumb_url"`
	// Type
	// Type of the result, must be photo
	Type InlineType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the photo
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// PhotoHeight
	// Height of the photo
	PhotoHeight *int64 `json:"photo_height,omitempty"`
	// PhotoWidth
	// Width of the photo
	PhotoWidth *int64 `json:"photo_width,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultPhoto) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetPhotoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetPhotoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultVenue
// Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the venue.
type InlineQueryResultVenue struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// Latitude
	// Latitude of the venue location in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue location in degrees
	Longitude float64 `json:"longitude"`
	// Title
	// Title of the venue
	Title string `json:"title"`
	// Type
	// Type of the result, must be venue
	Type InlineType `json:"type"`
	// FoursquareID
	// Foursquare identifier of the venue if known
	FoursquareID *string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType *string `json:"foursquare_type,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the venue
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbHeight
	// Thumbnail height
	ThumbHeight *int64 `json:"thumb_height,omitempty"`
	// ThumbURL
	// Url of the thumbnail for the result
	ThumbURL *string `json:"thumb_url,omitempty"`
	// ThumbWidth
	// Thumbnail width
	ThumbWidth *int64 `json:"thumb_width,omitempty"`
}

func (t *InlineQueryResultVenue) GetFoursquareID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareID; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetFoursquareType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetThumbHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetThumbURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetThumbWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbWidth; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultVideo
// Represents a link to a page containing an embedded video player or a video file. By default,
// this video file will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the video.
type InlineQueryResultVideo struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// MimeType
	// Mime type of the content of video url, "text/html" or "video/mp4"
	MimeType string `json:"mime_type"`
	// ThumbURL
	// URL of the thumbnail (jpeg only) for the video
	ThumbURL string `json:"thumb_url"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be video
	Type InlineType `json:"type"`
	// VideoURL
	// A valid URL for the embedded video player or video file
	VideoURL string `json:"video_url"`
	// Caption
	// Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video. This field is required if
	// InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video).
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// VideoDuration
	// Video duration in seconds
	VideoDuration *int64 `json:"video_duration,omitempty"`
	// VideoHeight
	// Video height
	VideoHeight *int64 `json:"video_height,omitempty"`
	// VideoWidth
	// Video width
	VideoWidth *int64 `json:"video_width,omitempty"`
}

func (t *InlineQueryResultVideo) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetVideoDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VideoDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetVideoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VideoHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetVideoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VideoWidth; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultVoice
// Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this
// voice recording will be sent by the user. Alternatively, you can use input_message_content to
// send a message with the specified content instead of the the voice message.
type InlineQueryResultVoice struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Recording title
	Title string `json:"title"`
	// Type
	// Type of the result, must be voice
	Type InlineType `json:"type"`
	// VoiceURL
	// A valid URL for the voice recording
	VoiceURL string `json:"voice_url"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the voice recording
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// VoiceDuration
	// Recording duration in seconds
	VoiceDuration *int64 `json:"voice_duration,omitempty"`
}

func (t *InlineQueryResultVoice) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetInputMessageContent() InputMessageContent {
	var res InputMessageContent
	if t == nil {
		return res
	}
	if field := t.InputMessageContent; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetVoiceDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VoiceDuration; field != nil {
		return *field
	}
	return res
}

// InputContactMessageContent
// Represents the content of a contact message to be sent as the result of an inline query.
type InputContactMessageContent struct {
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// LastName
	// Contact's last name
	LastName *string `json:"last_name,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

func (t *InputContactMessageContent) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *InputContactMessageContent) GetVcard() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Vcard; field != nil {
		return *field
	}
	return res
}

// InputFile
// This object represents the contents of a file to be uploaded. Must be posted using
// multipart/form-data in the usual way that files are uploaded via the browser.
type InputFile struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Text
	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID *int64 `json:"reply_to_message_id,omitempty"`
}

func (t *InputFile) GetDisableNotification() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableNotification; field != nil {
		return *field
	}
	return res
}

func (t *InputFile) GetDisableWebPagePreview() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableWebPagePreview; field != nil {
		return *field
	}
	return res
}

func (t *InputFile) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputFile) GetReplyMarkup() ReplyMarkup {
	var res ReplyMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *InputFile) GetReplyToMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ReplyToMessageID; field != nil {
		return *field
	}
	return res
}

// InputLocationMessageContent
// Represents the content of a location message to be sent as the result of an inline query.
type InputLocationMessageContent struct {
	// Latitude
	// Latitude of the location in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the location in degrees
	Longitude float64 `json:"longitude"`
	// LivePeriod
	// Period in seconds for which the location can be updated, should be between 60 and 86400.
	LivePeriod *int64 `json:"live_period,omitempty"`
}

func (t *InputLocationMessageContent) GetLivePeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LivePeriod; field != nil {
		return *field
	}
	return res
}

// InputMedia
// This object represents the content of a media message to be sent. It should be one of
type InputMedia struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name.
	Media string `json:"media"`
	// Type
	// Type of the result, must be photo
	Type InputType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputMedia) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMedia) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

// InputMediaAnimation
// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
type InputMediaAnimation struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name.
	Media string `json:"media"`
	// Type
	// Type of the result, must be animation
	Type InputType `json:"type"`
	// Caption
	// Caption of the animation to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Duration
	// Animation duration
	Duration *int64 `json:"duration,omitempty"`
	// Height
	// Animation height
	Height *int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the animation caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputDataType `json:"thumb,omitempty"`
	// Width
	// Animation width
	Width *int64 `json:"width,omitempty"`
}

func (t *InputMediaAnimation) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Duration; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Height; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetThumb() InputDataType {
	var res InputDataType
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Width; field != nil {
		return *field
	}
	return res
}

// InputMediaAudio
// Represents an audio file to be treated as music to be sent.
type InputMediaAudio struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name.
	Media string `json:"media"`
	// Type
	// Type of the result, must be audio
	Type InputType `json:"type"`
	// Caption
	// Caption of the audio to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Duration
	// Duration of the audio in seconds
	Duration *int64 `json:"duration,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Performer
	// Performer of the audio
	Performer *string `json:"performer,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputDataType `json:"thumb,omitempty"`
	// Title
	// Title of the audio
	Title *string `json:"title,omitempty"`
}

func (t *InputMediaAudio) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Duration; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetPerformer() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Performer; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetThumb() InputDataType {
	var res InputDataType
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// InputMediaDocument
// Represents a general file to be sent.
type InputMediaDocument struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name.
	Media string `json:"media"`
	// Type
	// Type of the result, must be document
	Type InputType `json:"type"`
	// Caption
	// Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputDataType `json:"thumb,omitempty"`
}

func (t *InputMediaDocument) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaDocument) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaDocument) GetThumb() InputDataType {
	var res InputDataType
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// InputMediaPhoto
// Represents a photo to be sent.
type InputMediaPhoto struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name.
	Media string `json:"media"`
	// Type
	// Type of the result, must be photo
	Type InputType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputMediaPhoto) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaPhoto) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

// InputMediaVideo
// Represents a video to be sent.
type InputMediaVideo struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name.
	Media string `json:"media"`
	// Type
	// Type of the result, must be video
	Type InputType `json:"type"`
	// Caption
	// Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// Duration
	// Video duration
	Duration *int64 `json:"duration,omitempty"`
	// Height
	// Video height
	Height *int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// SupportsStreaming
	// Pass True, if the uploaded video is suitable for streaming
	SupportsStreaming *bool `json:"supports_streaming,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputDataType `json:"thumb,omitempty"`
	// Width
	// Video width
	Width *int64 `json:"width,omitempty"`
}

func (t *InputMediaVideo) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Duration; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Height; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetSupportsStreaming() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SupportsStreaming; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetThumb() InputDataType {
	var res InputDataType
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Width; field != nil {
		return *field
	}
	return res
}

// InputMessageContent
// This object represents the content of a message to be sent as a result of an inline query.
// Telegram clients currently support the following 4 types:
type InputMessageContent struct {
	// MessageText
	// Text of the message to be sent, 1-4096 characters
	MessageText string `json:"message_text"`
	// DisableWebPagePreview
	// Disables link previews for links in the sent message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputMessageContent) GetDisableWebPagePreview() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableWebPagePreview; field != nil {
		return *field
	}
	return res
}

func (t *InputMessageContent) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

// InputTextMessageContent
// Represents the content of a text message to be sent as the result of an inline query.
type InputTextMessageContent struct {
	// MessageText
	// Text of the message to be sent, 1-4096 characters
	MessageText string `json:"message_text"`
	// DisableWebPagePreview
	// Disables link previews for links in the sent message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputTextMessageContent) GetDisableWebPagePreview() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableWebPagePreview; field != nil {
		return *field
	}
	return res
}

func (t *InputTextMessageContent) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

// InputVenueMessageContent
// Represents the content of a venue message to be sent as the result of an inline query.
type InputVenueMessageContent struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// Latitude
	// Latitude of the venue in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue in degrees
	Longitude float64 `json:"longitude"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// FoursquareID
	// Foursquare identifier of the venue, if known
	FoursquareID *string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType *string `json:"foursquare_type,omitempty"`
}

func (t *InputVenueMessageContent) GetFoursquareID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareID; field != nil {
		return *field
	}
	return res
}

func (t *InputVenueMessageContent) GetFoursquareType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareType; field != nil {
		return *field
	}
	return res
}

// Invoice
// This object contains basic information about an invoice.
type Invoice struct {
	// Currency
	// Three-letter ISO 4217 currency code
	Currency string `json:"currency"`
	// Description
	// Product description
	Description string `json:"description"`
	// StartParameter
	// Unique bot deep-linking parameter that can be used to generate this invoice
	StartParameter string `json:"start_parameter"`
	// Title
	// Product name
	Title string `json:"title"`
	// TotalAmount
	// Total price in the smallest units of the currency (integer, not float/double). For example,
	// for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it
	// shows the number of digits past the decimal point for each currency (2 for the majority of
	// currencies).
	TotalAmount int64 `json:"total_amount"`
}

// KeyboardButton
// This object represents one button of the reply keyboard. For simple text buttons String can be
// used instead of this object to specify text of the button. Optional fields request_contact,
// request_location, and request_poll are mutually exclusive.
type KeyboardButton struct {
	// Text
	// Text of the button. If none of the optional fields are used, it will be sent as a message
	// when the button is pressed
	Text string `json:"text"`
	// RequestContact
	// If True, the user's phone number will be sent as a contact when the button is pressed.
	// Available in private chats only
	RequestContact *bool `json:"request_contact,omitempty"`
	// RequestLocation
	// If True, the user's current location will be sent when the button is pressed. Available in
	// private chats only
	RequestLocation *bool `json:"request_location,omitempty"`
	// RequestPoll
	// If specified, the user will be asked to create a poll and send it to the bot when the button
	// is pressed. Available in private chats only
	RequestPoll *KeyboardButtonPollType `json:"request_poll,omitempty"`
}

func (t *KeyboardButton) GetRequestContact() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.RequestContact; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButton) GetRequestLocation() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.RequestLocation; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButton) GetRequestPoll() KeyboardButtonPollType {
	var res KeyboardButtonPollType
	if t == nil {
		return res
	}
	if field := t.RequestPoll; field != nil {
		return *field
	}
	return res
}

// KeyboardButtonPollType
// This object represents type of a poll, which is allowed to be created and sent when the
// corresponding button is pressed.
type KeyboardButtonPollType struct {
	// Type
	// If quiz is passed, the user will be allowed to create only polls in the quiz mode. If
	// regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed
	// to create a poll of any type.
	Type *KeyboardButtonType `json:"type,omitempty"`
}

func (t *KeyboardButtonPollType) GetType() KeyboardButtonType {
	var res KeyboardButtonType
	if t == nil {
		return res
	}
	if field := t.Type; field != nil {
		return *field
	}
	return res
}

// LabeledPrice
// This object represents a portion of the price for goods or services.
type LabeledPrice struct {
	// Amount
	// Price of the product in the smallest units of the currency (integer, not float/double). For
	// example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in
	// currencies.json, it shows the number of digits past the decimal point for each currency (2
	// for the majority of currencies).
	Amount int64 `json:"amount"`
	// Label
	// Portion label
	Label string `json:"label"`
}

// Location
// This object represents a point on the map.
type Location struct {
	// Latitude
	// Latitude as defined by sender
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude as defined by sender
	Longitude float64 `json:"longitude"`
}

// LoginURL
// This object represents a parameter of the inline keyboard button used to automatically authorize
// a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from
// Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
type LoginURL struct {
	// URL
	// An HTTP URL to be opened with user authorization data added to the query string when the
	// button is pressed. If the user refuses to provide authorization data, the original URL
	// without information about the user will be opened. The data added is the same as described
	// in Receiving authorization data.NOTE: You must always check the hash of the received data to
	// verify the authentication and the integrity of the data as described in Checking
	// authorization.
	URL string `json:"url"`
	// BotUsername
	// Username of a bot, which will be used for user authorization. See Setting up a bot for more
	// details. If not specified, the current bot's username will be assumed. The url's domain must
	// be the same as the domain linked with the bot. See Linking your domain to the bot for more
	// details.
	BotUsername *string `json:"bot_username,omitempty"`
	// ForwardText
	// New text of the button in forwarded messages.
	ForwardText *string `json:"forward_text,omitempty"`
	// RequestWriteAccess
	// Pass True to request the permission for your bot to send messages to the user.
	RequestWriteAccess *bool `json:"request_write_access,omitempty"`
}

func (t *LoginURL) GetBotUsername() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.BotUsername; field != nil {
		return *field
	}
	return res
}

func (t *LoginURL) GetForwardText() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ForwardText; field != nil {
		return *field
	}
	return res
}

func (t *LoginURL) GetRequestWriteAccess() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.RequestWriteAccess; field != nil {
		return *field
	}
	return res
}

// MaskPosition
// This object describes the position on faces where a mask should be placed by default.
type MaskPosition struct {
	// Point
	// The part of the face relative to which the mask should be placed. One of "forehead", "eyes",
	// "mouth", or "chin".
	Point string `json:"point"`
	// Scale
	// Mask scaling coefficient. For example, 2.0 means double size.
	Scale float64 `json:"scale"`
	// XShift
	// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right.
	// For example, choosing -1.0 will place mask just to the left of the default mask position.
	XShift float64 `json:"x_shift"`
	// YShift
	// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom.
	// For example, 1.0 will place the mask just below the default mask position.
	YShift float64 `json:"y_shift"`
}

// Message
// This object represents a message.
type Message struct {
	// Chat
	// Conversation the message belongs to
	Chat Chat `json:"chat"`
	// Date
	// Date the message was sent in Unix time
	Date int64 `json:"date"`
	// MessageID
	// Unique message identifier inside this chat
	MessageID int64 `json:"message_id"`
	// Animation
	// Message is an animation, information about the animation. For backward compatibility, when
	// this field is set, the document field will also be set
	Animation *Animation `json:"animation,omitempty"`
	// Audio
	// Message is an audio file, information about the file
	Audio *Audio `json:"audio,omitempty"`
	// AuthorSignature
	// Signature of the post author for messages in channels
	AuthorSignature *string `json:"author_signature,omitempty"`
	// Caption
	// Caption for the animation, audio, document, photo, video or voice, 0-1024 characters
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// For messages with a caption, special entities like usernames, URLs, bot commands, etc. that
	// appear in the caption
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// ChannelChatCreated
	// Service message: the channel has been created. This field can't be received in a message
	// coming through updates, because bot can't be a member of a channel when it is created. It
	// can only be found in reply_to_message if someone replies to a very first message in a
	// channel.
	ChannelChatCreated *True `json:"channel_chat_created,omitempty"`
	// ConnectedWebsite
	// The domain name of the website on which the user has logged in. More about Telegram Login Â»
	ConnectedWebsite *string `json:"connected_website,omitempty"`
	// Contact
	// Message is a shared contact, information about the contact
	Contact *Contact `json:"contact,omitempty"`
	// DeleteChatPhoto
	// Service message: the chat photo was deleted
	DeleteChatPhoto *True `json:"delete_chat_photo,omitempty"`
	// Dice
	// Message is a dice with random value from 1 to 6
	Dice *Dice `json:"dice,omitempty"`
	// Document
	// Message is a general file, information about the file
	Document *Document `json:"document,omitempty"`
	// EditDate
	// Date the message was last edited in Unix time
	EditDate *int64 `json:"edit_date,omitempty"`
	// Entities
	// For text messages, special entities like usernames, URLs, bot commands, etc. that appear in
	// the text
	Entities []MessageEntity `json:"entities,omitempty"`
	// ForwardDate
	// For forwarded messages, date the original message was sent in Unix time
	ForwardDate *int64 `json:"forward_date,omitempty"`
	// ForwardFrom
	// For forwarded messages, sender of the original message
	ForwardFrom *User `json:"forward_from,omitempty"`
	// ForwardFromChat
	// For messages forwarded from channels, information about the original channel
	ForwardFromChat *Chat `json:"forward_from_chat,omitempty"`
	// ForwardFromMessageID
	// For messages forwarded from channels, identifier of the original message in the channel
	ForwardFromMessageID *int64 `json:"forward_from_message_id,omitempty"`
	// ForwardSenderName
	// Sender's name for messages forwarded from users who disallow adding a link to their account
	// in forwarded messages
	ForwardSenderName *string `json:"forward_sender_name,omitempty"`
	// ForwardSignature
	// For messages forwarded from channels, signature of the post author if present
	ForwardSignature *string `json:"forward_signature,omitempty"`
	// From
	// Sender, empty for messages sent to channels
	From *User `json:"from,omitempty"`
	// Game
	// Message is a game, information about the game. More about games Â»
	Game *Game `json:"game,omitempty"`
	// GroupChatCreated
	// Service message: the group has been created
	GroupChatCreated *True `json:"group_chat_created,omitempty"`
	// Invoice
	// Message is an invoice for a payment, information about the invoice. More about payments Â»
	Invoice *Invoice `json:"invoice,omitempty"`
	// LeftChatMember
	// A member was removed from the group, information about them (this member may be the bot
	// itself)
	LeftChatMember *User `json:"left_chat_member,omitempty"`
	// Location
	// Message is a shared location, information about the location
	Location *Location `json:"location,omitempty"`
	// MediaGroupID
	// The unique identifier of a media message group this message belongs to
	MediaGroupID *string `json:"media_group_id,omitempty"`
	// MigrateFromChatID
	// The supergroup has been migrated from a group with the specified identifier. This number may
	// be greater than 32 bits and some programming languages may have difficulty/silent defects in
	// interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or
	// double-precision float type are safe for storing this identifier.
	MigrateFromChatID *int64 `json:"migrate_from_chat_id,omitempty"`
	// MigrateToChatID
	// The group has been migrated to a supergroup with the specified identifier. This number may
	// be greater than 32 bits and some programming languages may have difficulty/silent defects in
	// interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or
	// double-precision float type are safe for storing this identifier.
	MigrateToChatID *int64 `json:"migrate_to_chat_id,omitempty"`
	// NewChatMembers
	// New members that were added to the group or supergroup and information about them (the bot
	// itself may be one of these members)
	NewChatMembers []User `json:"new_chat_members,omitempty"`
	// NewChatPhoto
	// A chat photo was change to this value
	NewChatPhoto []PhotoSize `json:"new_chat_photo,omitempty"`
	// NewChatTitle
	// A chat title was changed to this value
	NewChatTitle *string `json:"new_chat_title,omitempty"`
	// PassportData
	// Telegram Passport data
	PassportData *PassportData `json:"passport_data,omitempty"`
	// Photo
	// Message is a photo, available sizes of the photo
	Photo []PhotoSize `json:"photo,omitempty"`
	// PinnedMessage
	// Specified message was pinned. Note that the Message object in this field will not contain
	// further reply_to_message fields even if it is itself a reply.
	PinnedMessage *Message `json:"pinned_message,omitempty"`
	// Poll
	// Message is a native poll, information about the poll
	Poll *Poll `json:"poll,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message. login_url buttons are represented as ordinary url
	// buttons.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessage
	// For replies, the original message. Note that the Message object in this field will not
	// contain further reply_to_message fields even if it itself is a reply.
	ReplyToMessage *Message `json:"reply_to_message,omitempty"`
	// Sticker
	// Message is a sticker, information about the sticker
	Sticker *Sticker `json:"sticker,omitempty"`
	// SuccessfulPayment
	// Message is a service message about a successful payment, information about the payment. More
	// about payments Â»
	SuccessfulPayment *SuccessfulPayment `json:"successful_payment,omitempty"`
	// SupergroupChatCreated
	// Service message: the supergroup has been created. This field can't be received in a message
	// coming through updates, because bot can't be a member of a supergroup when it is created. It
	// can only be found in reply_to_message if someone replies to a very first message in a
	// directly created supergroup.
	SupergroupChatCreated *True `json:"supergroup_chat_created,omitempty"`
	// Text
	// For text messages, the actual UTF-8 text of the message, 0-4096 characters
	Text *string `json:"text,omitempty"`
	// Venue
	// Message is a venue, information about the venue. For backward compatibility, when this field
	// is set, the location field will also be set
	Venue *Venue `json:"venue,omitempty"`
	// ViaBot
	// Bot through which the message was sent
	ViaBot *User `json:"via_bot,omitempty"`
	// Video
	// Message is a video, information about the video
	Video *Video `json:"video,omitempty"`
	// VideoNote
	// Message is a video note, information about the video message
	VideoNote *VideoNote `json:"video_note,omitempty"`
	// Voice
	// Message is a voice message, information about the file
	Voice *Voice `json:"voice,omitempty"`
}

func (t *Message) GetAnimation() Animation {
	var res Animation
	if t == nil {
		return res
	}
	if field := t.Animation; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetAudio() Audio {
	var res Audio
	if t == nil {
		return res
	}
	if field := t.Audio; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetAuthorSignature() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.AuthorSignature; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetChannelChatCreated() True {
	var res True
	if t == nil {
		return res
	}
	if field := t.ChannelChatCreated; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetConnectedWebsite() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ConnectedWebsite; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetContact() Contact {
	var res Contact
	if t == nil {
		return res
	}
	if field := t.Contact; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetDeleteChatPhoto() True {
	var res True
	if t == nil {
		return res
	}
	if field := t.DeleteChatPhoto; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetDice() Dice {
	var res Dice
	if t == nil {
		return res
	}
	if field := t.Dice; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetDocument() Document {
	var res Document
	if t == nil {
		return res
	}
	if field := t.Document; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetEditDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.EditDate; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ForwardDate; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardFrom() User {
	var res User
	if t == nil {
		return res
	}
	if field := t.ForwardFrom; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardFromChat() Chat {
	var res Chat
	if t == nil {
		return res
	}
	if field := t.ForwardFromChat; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardFromMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ForwardFromMessageID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardSenderName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ForwardSenderName; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardSignature() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ForwardSignature; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetFrom() User {
	var res User
	if t == nil {
		return res
	}
	if field := t.From; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetGame() Game {
	var res Game
	if t == nil {
		return res
	}
	if field := t.Game; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetGroupChatCreated() True {
	var res True
	if t == nil {
		return res
	}
	if field := t.GroupChatCreated; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetInvoice() Invoice {
	var res Invoice
	if t == nil {
		return res
	}
	if field := t.Invoice; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetLeftChatMember() User {
	var res User
	if t == nil {
		return res
	}
	if field := t.LeftChatMember; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetLocation() Location {
	var res Location
	if t == nil {
		return res
	}
	if field := t.Location; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetMediaGroupID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MediaGroupID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetMigrateFromChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MigrateFromChatID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetMigrateToChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MigrateToChatID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetNewChatTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.NewChatTitle; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetPassportData() PassportData {
	var res PassportData
	if t == nil {
		return res
	}
	if field := t.PassportData; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetPinnedMessage() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.PinnedMessage; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetPoll() Poll {
	var res Poll
	if t == nil {
		return res
	}
	if field := t.Poll; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetReplyToMessage() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.ReplyToMessage; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetSticker() Sticker {
	var res Sticker
	if t == nil {
		return res
	}
	if field := t.Sticker; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetSuccessfulPayment() SuccessfulPayment {
	var res SuccessfulPayment
	if t == nil {
		return res
	}
	if field := t.SuccessfulPayment; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetSupergroupChatCreated() True {
	var res True
	if t == nil {
		return res
	}
	if field := t.SupergroupChatCreated; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetText() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Text; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetVenue() Venue {
	var res Venue
	if t == nil {
		return res
	}
	if field := t.Venue; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetViaBot() User {
	var res User
	if t == nil {
		return res
	}
	if field := t.ViaBot; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetVideo() Video {
	var res Video
	if t == nil {
		return res
	}
	if field := t.Video; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetVideoNote() VideoNote {
	var res VideoNote
	if t == nil {
		return res
	}
	if field := t.VideoNote; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetVoice() Voice {
	var res Voice
	if t == nil {
		return res
	}
	if field := t.Voice; field != nil {
		return *field
	}
	return res
}

// MessageEntity
// This object represents one special entity in a text message. For example, hashtags, usernames,
// URLs, etc.
type MessageEntity struct {
	// Length
	// Length of the entity in UTF-16 code units
	Length int64 `json:"length"`
	// Offset
	// Offset in UTF-16 code units to the start of the entity
	Offset int64 `json:"offset"`
	// Type
	// Type of the entity. Can be "mention" (@username), "hashtag" (#hashtag), "cashtag" ($USD),
	// "bot_command" (/start@jobs_bot), "url" (https://telegram.org), "email"
	// (do-not-reply@telegram.org), "phone_number" (+1-212-555-0123), "bold" (bold text), "italic"
	// (italic text), "underline" (underlined text), "strikethrough" (strikethrough text), "code"
	// (monowidth string), "pre" (monowidth block), "text_link" (for clickable text URLs),
	// "text_mention" (for users without usernames)
	Type EntityType `json:"type"`
	// Language
	// For "pre" only, the programming language of the entity text
	Language *string `json:"language,omitempty"`
	// URL
	// For "text_link" only, url that will be opened after user taps on the text
	URL *string `json:"url,omitempty"`
	// User
	// For "text_mention" only, the mentioned user
	User *User `json:"user,omitempty"`
}

func (t *MessageEntity) GetLanguage() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Language; field != nil {
		return *field
	}
	return res
}

func (t *MessageEntity) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

func (t *MessageEntity) GetUser() User {
	var res User
	if t == nil {
		return res
	}
	if field := t.User; field != nil {
		return *field
	}
	return res
}

// OrderInfo
// This object represents information about an order.
type OrderInfo struct {
	// Email
	// User email
	Email *string `json:"email,omitempty"`
	// Name
	// User name
	Name *string `json:"name,omitempty"`
	// PhoneNumber
	// User's phone number
	PhoneNumber *string `json:"phone_number,omitempty"`
	// ShippingAddress
	// User shipping address
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

func (t *OrderInfo) GetEmail() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Email; field != nil {
		return *field
	}
	return res
}

func (t *OrderInfo) GetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Name; field != nil {
		return *field
	}
	return res
}

func (t *OrderInfo) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *OrderInfo) GetShippingAddress() ShippingAddress {
	var res ShippingAddress
	if t == nil {
		return res
	}
	if field := t.ShippingAddress; field != nil {
		return *field
	}
	return res
}

// PassportData
// Contains information about Telegram Passport data shared with the bot by the user.
type PassportData struct {
	// Credentials
	// Encrypted credentials required to decrypt the data
	Credentials EncryptedCredentials `json:"credentials"`
	// Data
	// Array with information about documents and other Telegram Passport elements that was shared
	// with the bot
	Data []EncryptedPassportElement `json:"data"`
}

// PassportElementError
// This object represents an error in the Telegram Passport element which was submitted that should
// be resolved by the user. It should be one of:
type PassportElementError struct {
	// DataHash
	// Base64-encoded data hash
	DataHash string `json:"data_hash"`
	// FieldName
	// Name of the data field which has the error
	FieldName string `json:"field_name"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be data
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the error, one of "personal_details",
	// "passport", "driver_license", "identity_card", "internal_passport", "address"
	Type PassportType `json:"type"`
}

// PassportElementErrorDataField
// Represents an issue in one of the data fields that was provided by the user. The error is
// considered resolved when the field's value changes.
type PassportElementErrorDataField struct {
	// DataHash
	// Base64-encoded data hash
	DataHash string `json:"data_hash"`
	// FieldName
	// Name of the data field which has the error
	FieldName string `json:"field_name"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be data
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the error, one of "personal_details",
	// "passport", "driver_license", "identity_card", "internal_passport", "address"
	Type PassportType `json:"type"`
}

// PassportElementErrorFile
// Represents an issue with a document scan. The error is considered resolved when the file with
// the document scan changes.
type PassportElementErrorFile struct {
	// FileHash
	// Base64-encoded file hash
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be file
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "utility_bill",
	// "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

// PassportElementErrorFiles
// Represents an issue with a list of scans. The error is considered resolved when the list of
// files containing the scans changes.
type PassportElementErrorFiles struct {
	// FileHashes
	// List of base64-encoded file hashes
	FileHashes []string `json:"file_hashes"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be files
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "utility_bill",
	// "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

// PassportElementErrorFrontSide
// Represents an issue with the front side of a document. The error is considered resolved when the
// file with the front side of the document changes.
type PassportElementErrorFrontSide struct {
	// FileHash
	// Base64-encoded hash of the file with the front side of the document
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be front_side
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport"
	Type PassportType `json:"type"`
}

// PassportElementErrorReverseSide
// Represents an issue with the reverse side of a document. The error is considered resolved when
// the file with reverse side of the document changes.
type PassportElementErrorReverseSide struct {
	// FileHash
	// Base64-encoded hash of the file with the reverse side of the document
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be reverse_side
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "driver_license",
	// "identity_card"
	Type PassportType `json:"type"`
}

// PassportElementErrorSelfie
// Represents an issue with the selfie with a document. The error is considered resolved when the
// file with the selfie changes.
type PassportElementErrorSelfie struct {
	// FileHash
	// Base64-encoded hash of the file with the selfie
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be selfie
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport"
	Type PassportType `json:"type"`
}

// PassportElementErrorTranslationFile
// Represents an issue with one of the files that constitute the translation of a document. The
// error is considered resolved when the file changes.
type PassportElementErrorTranslationFile struct {
	// FileHash
	// Base64-encoded file hash
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be translation_file
	Source string `json:"source"`
	// Type
	// Type of element of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement",
	// "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

// PassportElementErrorTranslationFiles
// Represents an issue with the translated version of a document. The error is considered resolved
// when a file with the document translation change.
type PassportElementErrorTranslationFiles struct {
	// FileHashes
	// List of base64-encoded file hashes
	FileHashes []string `json:"file_hashes"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be translation_files
	Source string `json:"source"`
	// Type
	// Type of element of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement",
	// "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

// PassportElementErrorUnspecified
// Represents an issue in an unspecified place. The error is considered resolved when new data is
// added.
type PassportElementErrorUnspecified struct {
	// ElementHash
	// Base64-encoded element hash
	ElementHash string `json:"element_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be unspecified
	Source string `json:"source"`
	// Type
	// Type of element of the user's Telegram Passport which has the issue
	Type PassportType `json:"type"`
}

// PassportFile
// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport
// files are in JPEG format when decrypted and don't exceed 10MB.
type PassportFile struct {
	// FileDate
	// Unix time when the file was uploaded
	FileDate int64 `json:"file_date"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileSize
	// File size
	FileSize int64 `json:"file_size"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
}

// Payments
// Your bot can accept payments from Telegram users. Please see the introduction to payments for
// more details on the process and how to set up payments for your bot. Please note that users will
// need Telegram v.4.0 or higher to use payments (released on May 18, 2017).
type Payments struct {
	// ChatID
	// Unique identifier for the target private chat
	ChatID int64 `json:"chat_id"`
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payments provider token, obtained via Botfather
	ProviderToken string `json:"provider_token"`
	// StartParameter
	// Unique deep-linking parameter that can be used to generate this invoice when used as a start
	// parameter
	StartParameter string `json:"start_parameter"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`
	// IsFlexible
	// Pass True, if the final price depends on the shipping method
	IsFlexible *bool `json:"is_flexible,omitempty"`
	// NeedEmail
	// Pass True, if you require the user's email address to complete the order
	NeedEmail *bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True, if you require the user's full name to complete the order
	NeedName *bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True, if you require the user's phone number to complete the order
	NeedPhoneNumber *bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True, if you require the user's shipping address to complete the order
	NeedShippingAddress *bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight *int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size
	PhotoSize *int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service. People like it better when they see what they are paying for.
	PhotoURL *string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth *int64 `json:"photo_width,omitempty"`
	// ProviderData
	// A JSON-serialized data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData *string `json:"provider_data,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will
	// be shown. If not empty, the first button must be a Pay button.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID *int64 `json:"reply_to_message_id,omitempty"`
	// SendEmailToProvider
	// Pass True, if user's email address should be sent to provider
	SendEmailToProvider *bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True, if user's phone number should be sent to provider
	SendPhoneNumberToProvider *bool `json:"send_phone_number_to_provider,omitempty"`
}

func (t *Payments) GetDisableNotification() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableNotification; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetIsFlexible() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.IsFlexible; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedEmail() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedEmail; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedName() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedName; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedPhoneNumber() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedPhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedShippingAddress() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedShippingAddress; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoHeight; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoSize; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhotoURL; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoWidth; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetProviderData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ProviderData; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetReplyMarkup() InlineKeyboardMarkup {
	var res InlineKeyboardMarkup
	if t == nil {
		return res
	}
	if field := t.ReplyMarkup; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetReplyToMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ReplyToMessageID; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetSendEmailToProvider() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SendEmailToProvider; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetSendPhoneNumberToProvider() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SendPhoneNumberToProvider; field != nil {
		return *field
	}
	return res
}

// PhotoSize
// This object represents one size of a photo or a file / sticker thumbnail.
type PhotoSize struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Photo height
	Height int64 `json:"height"`
	// Width
	// Photo width
	Width int64 `json:"width"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
}

func (t *PhotoSize) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

// Poll
// This object contains information about a poll.
type Poll struct {
	// AllowsMultipleAnswers
	// True, if the poll allows multiple answers
	AllowsMultipleAnswers bool `json:"allows_multiple_answers"`
	// ID
	// Unique poll identifier
	ID string `json:"id"`
	// IsAnonymous
	// True, if the poll is anonymous
	IsAnonymous bool `json:"is_anonymous"`
	// IsClosed
	// True, if the poll is closed
	IsClosed bool `json:"is_closed"`
	// Options
	// List of poll options
	Options []PollOption `json:"options"`
	// Question
	// Poll question, 1-255 characters
	Question string `json:"question"`
	// TotalVoterCount
	// Total number of users that voted in the poll
	TotalVoterCount int64 `json:"total_voter_count"`
	// Type
	// Poll type, currently can be "regular" or "quiz"
	Type PollType `json:"type"`
	// CloseDate
	// Point in time (Unix timestamp) when the poll will be automatically closed
	CloseDate *int64 `json:"close_date,omitempty"`
	// CorrectOptionID
	// 0-based identifier of the correct answer option. Available only for polls in the quiz mode,
	// which are closed, or was sent (not forwarded) by the bot or to the private chat with the
	// bot.
	CorrectOptionID *int64 `json:"correct_option_id,omitempty"`
	// Explanation
	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a
	// quiz-style poll, 0-200 characters
	Explanation *string `json:"explanation,omitempty"`
	// ExplanationEntities
	// Special entities like usernames, URLs, bot commands, etc. that appear in the explanation
	ExplanationEntities []MessageEntity `json:"explanation_entities,omitempty"`
	// OpenPeriod
	// Amount of time in seconds the poll will be active after creation
	OpenPeriod *int64 `json:"open_period,omitempty"`
}

func (t *Poll) GetCloseDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.CloseDate; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetCorrectOptionID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.CorrectOptionID; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetExplanation() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Explanation; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetOpenPeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.OpenPeriod; field != nil {
		return *field
	}
	return res
}

// PollAnswer
// This object represents an answer of a user in a non-anonymous poll.
type PollAnswer struct {
	// OptionIds
	// 0-based identifiers of answer options, chosen by the user. May be empty if the user
	// retracted their vote.
	OptionIds []int64 `json:"option_ids"`
	// PollID
	// Unique poll identifier
	PollID string `json:"poll_id"`
	// User
	// The user, who changed the answer to the poll
	User User `json:"user"`
}

// PollOption
// This object contains information about one answer option in a poll.
type PollOption struct {
	// Text
	// Option text, 1-100 characters
	Text string `json:"text"`
	// VoterCount
	// Number of users that voted for this option
	VoterCount int64 `json:"voter_count"`
}

// PreCheckoutQuery
// This object contains information about an incoming pre-checkout query.
type PreCheckoutQuery struct {
	// Currency
	// Three-letter ISO 4217 currency code
	Currency string `json:"currency"`
	// From
	// User who sent the query
	From User `json:"from"`
	// ID
	// Unique query identifier
	ID string `json:"id"`
	// InvoicePayload
	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// TotalAmount
	// Total price in the smallest units of the currency (integer, not float/double). For example,
	// for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it
	// shows the number of digits past the decimal point for each currency (2 for the majority of
	// currencies).
	TotalAmount int64 `json:"total_amount"`
	// OrderInfo
	// Order info provided by the user
	OrderInfo *OrderInfo `json:"order_info,omitempty"`
	// ShippingOptionID
	// Identifier of the shipping option chosen by the user
	ShippingOptionID *string `json:"shipping_option_id,omitempty"`
}

func (t *PreCheckoutQuery) GetOrderInfo() OrderInfo {
	var res OrderInfo
	if t == nil {
		return res
	}
	if field := t.OrderInfo; field != nil {
		return *field
	}
	return res
}

func (t *PreCheckoutQuery) GetShippingOptionID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ShippingOptionID; field != nil {
		return *field
	}
	return res
}

// ReplyKeyboardMarkup
// This object represents a custom keyboard with reply options (see Introduction to bots for
// details and examples).
type ReplyKeyboardMarkup struct {
	// Keyboard
	// Array of button rows, each represented by an Array of KeyboardButton objects
	Keyboard [][]KeyboardButton `json:"keyboard"`
	// OneTimeKeyboard
	// Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be
	// available, but clients will automatically display the usual letter-keyboard in the chat -
	// the user can press a special button in the input field to see the custom keyboard again.
	// Defaults to false.
	OneTimeKeyboard *bool `json:"one_time_keyboard,omitempty"`
	// ResizeKeyboard
	// Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard
	// smaller if there are just two rows of buttons). Defaults to false, in which case the custom
	// keyboard is always of the same height as the app's standard keyboard.
	ResizeKeyboard *bool `json:"resize_keyboard,omitempty"`
	// Selective
	// Use this parameter if you want to show the keyboard to specific users only. Targets: 1)
	// users that are @mentioned in the text of the Message object; 2) if the bot's message is a
	// reply (has reply_to_message_id), sender of the original message. Example: A user requests to
	// change the bot's language, bot replies to the request with a keyboard to select the new
	// language. Other users in the group don't see the keyboard.
	Selective *bool `json:"selective,omitempty"`
}

func (t *ReplyKeyboardMarkup) GetOneTimeKeyboard() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.OneTimeKeyboard; field != nil {
		return *field
	}
	return res
}

func (t *ReplyKeyboardMarkup) GetResizeKeyboard() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ResizeKeyboard; field != nil {
		return *field
	}
	return res
}

func (t *ReplyKeyboardMarkup) GetSelective() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Selective; field != nil {
		return *field
	}
	return res
}

// ReplyKeyboardRemove
// Upon receiving a message with this object, Telegram clients will remove the current custom
// keyboard and display the default letter-keyboard. By default, custom keyboards are displayed
// until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are
// hidden immediately after the user presses a button (see ReplyKeyboardMarkup).
type ReplyKeyboardRemove struct {
	// RemoveKeyboard
	// Requests clients to remove the custom keyboard (user will not be able to summon this
	// keyboard; if you want to hide the keyboard from sight but keep it accessible, use
	// one_time_keyboard in ReplyKeyboardMarkup)
	RemoveKeyboard True `json:"remove_keyboard"`
	// Selective
	// Use this parameter if you want to remove the keyboard for specific users only. Targets: 1)
	// users that are @mentioned in the text of the Message object; 2) if the bot's message is a
	// reply (has reply_to_message_id), sender of the original message. Example: A user votes in a
	// poll, bot returns confirmation message in reply to the vote and removes the keyboard for
	// that user, while still showing the keyboard with poll options to users who haven't voted
	// yet.
	Selective *bool `json:"selective,omitempty"`
}

func (t *ReplyKeyboardRemove) GetSelective() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Selective; field != nil {
		return *field
	}
	return res
}

// ResponseParameters
// Contains information about why a request was unsuccessful.
type ResponseParameters struct {
	// MigrateToChatID
	// The group has been migrated to a supergroup with the specified identifier. This number may
	// be greater than 32 bits and some programming languages may have difficulty/silent defects in
	// interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or
	// double-precision float type are safe for storing this identifier.
	MigrateToChatID *int64 `json:"migrate_to_chat_id,omitempty"`
	// RetryAfter
	// In case of exceeding flood control, the number of seconds left to wait before the request
	// can be repeated
	RetryAfter *int64 `json:"retry_after,omitempty"`
}

func (t *ResponseParameters) GetMigrateToChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MigrateToChatID; field != nil {
		return *field
	}
	return res
}

func (t *ResponseParameters) GetRetryAfter() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.RetryAfter; field != nil {
		return *field
	}
	return res
}

// ShippingAddress
// This object represents a shipping address.
type ShippingAddress struct {
	// City
	// City
	City string `json:"city"`
	// CountryCode
	// ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// PostCode
	// Address post code
	PostCode string `json:"post_code"`
	// State
	// State, if applicable
	State string `json:"state"`
	// StreetLine1
	// First line for the address
	StreetLine1 string `json:"street_line1"`
	// StreetLine2
	// Second line for the address
	StreetLine2 string `json:"street_line2"`
}

// ShippingOption
// This object represents one shipping option.
type ShippingOption struct {
	// ID
	// Shipping option identifier
	ID string `json:"id"`
	// Prices
	// List of price portions
	Prices []LabeledPrice `json:"prices"`
	// Title
	// Option title
	Title string `json:"title"`
}

// ShippingQuery
// This object contains information about an incoming shipping query.
type ShippingQuery struct {
	// From
	// User who sent the query
	From User `json:"from"`
	// ID
	// Unique query identifier
	ID string `json:"id"`
	// InvoicePayload
	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// ShippingAddress
	// User specified shipping address
	ShippingAddress ShippingAddress `json:"shipping_address"`
}

// Sticker
// This object represents a sticker.
type Sticker struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Sticker height
	Height int64 `json:"height"`
	// IsAnimated
	// True, if the sticker is animated
	IsAnimated bool `json:"is_animated"`
	// Width
	// Sticker width
	Width int64 `json:"width"`
	// Emoji
	// Emoji associated with the sticker
	Emoji *string `json:"emoji,omitempty"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MaskPosition
	// For mask stickers, the position where the mask should be placed
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// SetName
	// Name of the sticker set to which the sticker belongs
	SetName *string `json:"set_name,omitempty"`
	// Thumb
	// Sticker thumbnail in the .WEBP or .JPG format
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *Sticker) GetEmoji() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Emoji; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetMaskPosition() MaskPosition {
	var res MaskPosition
	if t == nil {
		return res
	}
	if field := t.MaskPosition; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetSetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SetName; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// StickerSet
// This object represents a sticker set.
type StickerSet struct {
	// ContainsMasks
	// True, if the sticker set contains masks
	ContainsMasks bool `json:"contains_masks"`
	// IsAnimated
	// True, if the sticker set contains animated stickers
	IsAnimated bool `json:"is_animated"`
	// Name
	// Sticker set name
	Name string `json:"name"`
	// Stickers
	// List of all set stickers
	Stickers []Sticker `json:"stickers"`
	// Title
	// Sticker set title
	Title string `json:"title"`
	// Thumb
	// Sticker set thumbnail in the .WEBP or .TGS format
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *StickerSet) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// Stickers
// The following methods and objects allow your bot to handle stickers and sticker sets.
type Stickers struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Sticker height
	Height int64 `json:"height"`
	// IsAnimated
	// True, if the sticker is animated
	IsAnimated bool `json:"is_animated"`
	// Width
	// Sticker width
	Width int64 `json:"width"`
	// Emoji
	// Emoji associated with the sticker
	Emoji *string `json:"emoji,omitempty"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MaskPosition
	// For mask stickers, the position where the mask should be placed
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// SetName
	// Name of the sticker set to which the sticker belongs
	SetName *string `json:"set_name,omitempty"`
	// Thumb
	// Sticker thumbnail in the .WEBP or .JPG format
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *Stickers) GetEmoji() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Emoji; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetMaskPosition() MaskPosition {
	var res MaskPosition
	if t == nil {
		return res
	}
	if field := t.MaskPosition; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetSetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SetName; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// SuccessfulPayment
// This object contains basic information about a successful payment.
type SuccessfulPayment struct {
	// Currency
	// Three-letter ISO 4217 currency code
	Currency string `json:"currency"`
	// InvoicePayload
	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// ProviderPaymentChargeID
	// Provider payment identifier
	ProviderPaymentChargeID string `json:"provider_payment_charge_id"`
	// TelegramPaymentChargeID
	// Telegram payment identifier
	TelegramPaymentChargeID string `json:"telegram_payment_charge_id"`
	// TotalAmount
	// Total price in the smallest units of the currency (integer, not float/double). For example,
	// for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it
	// shows the number of digits past the decimal point for each currency (2 for the majority of
	// currencies).
	TotalAmount int64 `json:"total_amount"`
	// OrderInfo
	// Order info provided by the user
	OrderInfo *OrderInfo `json:"order_info,omitempty"`
	// ShippingOptionID
	// Identifier of the shipping option chosen by the user
	ShippingOptionID *string `json:"shipping_option_id,omitempty"`
}

func (t *SuccessfulPayment) GetOrderInfo() OrderInfo {
	var res OrderInfo
	if t == nil {
		return res
	}
	if field := t.OrderInfo; field != nil {
		return *field
	}
	return res
}

func (t *SuccessfulPayment) GetShippingOptionID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ShippingOptionID; field != nil {
		return *field
	}
	return res
}

// Update
// This object represents an incoming update.At most one of the optional parameters can be present
// in any given update.
type Update struct {
	// UpdateID
	// The update's unique identifier. Update identifiers start from a certain positive number and
	// increase sequentially. This ID becomes especially handy if you're using Webhooks, since it
	// allows you to ignore repeated updates or to restore the correct update sequence, should they
	// get out of order. If there are no new updates for at least a week, then identifier of the
	// next update will be chosen randomly instead of sequentially.
	UpdateID int64 `json:"update_id"`
	// CallbackQuery
	// New incoming callback query
	CallbackQuery *CallbackQuery `json:"callback_query,omitempty"`
	// ChannelPost
	// New incoming channel post of any kind - text, photo, sticker, etc.
	ChannelPost *Message `json:"channel_post,omitempty"`
	// ChosenInlineResult
	// The result of an inline query that was chosen by a user and sent to their chat partner.
	// Please see our documentation on the feedback collecting for details on how to enable these
	// updates for your bot.
	ChosenInlineResult *ChosenInlineResult `json:"chosen_inline_result,omitempty"`
	// EditedChannelPost
	// New version of a channel post that is known to the bot and was edited
	EditedChannelPost *Message `json:"edited_channel_post,omitempty"`
	// EditedMessage
	// New version of a message that is known to the bot and was edited
	EditedMessage *Message `json:"edited_message,omitempty"`
	// InlineQuery
	// New incoming inline query
	InlineQuery *InlineQuery `json:"inline_query,omitempty"`
	// Message
	// New incoming message of any kind - text, photo, sticker, etc.
	Message *Message `json:"message,omitempty"`
	// Poll
	// New poll state. Bots receive only updates about stopped polls and polls, which are sent by
	// the bot
	Poll *Poll `json:"poll,omitempty"`
	// PollAnswer
	// A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls
	// that were sent by the bot itself.
	PollAnswer *PollAnswer `json:"poll_answer,omitempty"`
	// PreCheckoutQuery
	// New incoming pre-checkout query. Contains full information about checkout
	PreCheckoutQuery *PreCheckoutQuery `json:"pre_checkout_query,omitempty"`
	// ShippingQuery
	// New incoming shipping query. Only for invoices with flexible price
	ShippingQuery *ShippingQuery `json:"shipping_query,omitempty"`
}

func (t *Update) GetCallbackQuery() CallbackQuery {
	var res CallbackQuery
	if t == nil {
		return res
	}
	if field := t.CallbackQuery; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetChannelPost() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.ChannelPost; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetChosenInlineResult() ChosenInlineResult {
	var res ChosenInlineResult
	if t == nil {
		return res
	}
	if field := t.ChosenInlineResult; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetEditedChannelPost() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.EditedChannelPost; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetEditedMessage() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.EditedMessage; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetInlineQuery() InlineQuery {
	var res InlineQuery
	if t == nil {
		return res
	}
	if field := t.InlineQuery; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetMessage() Message {
	var res Message
	if t == nil {
		return res
	}
	if field := t.Message; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetPoll() Poll {
	var res Poll
	if t == nil {
		return res
	}
	if field := t.Poll; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetPollAnswer() PollAnswer {
	var res PollAnswer
	if t == nil {
		return res
	}
	if field := t.PollAnswer; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetPreCheckoutQuery() PreCheckoutQuery {
	var res PreCheckoutQuery
	if t == nil {
		return res
	}
	if field := t.PreCheckoutQuery; field != nil {
		return *field
	}
	return res
}

func (t *Update) GetShippingQuery() ShippingQuery {
	var res ShippingQuery
	if t == nil {
		return res
	}
	if field := t.ShippingQuery; field != nil {
		return *field
	}
	return res
}

// User
// This object represents a Telegram user or bot.
type User struct {
	// FirstName
	// User's or bot's first name
	FirstName string `json:"first_name"`
	// ID
	// Unique identifier for this user or bot
	ID int64 `json:"id"`
	// IsBot
	// True, if this user is a bot
	IsBot bool `json:"is_bot"`
	// CanJoinGroups
	// True, if the bot can be invited to groups. Returned only in getMe.
	CanJoinGroups *bool `json:"can_join_groups,omitempty"`
	// CanReadAllGroupMessages
	// True, if privacy mode is disabled for the bot. Returned only in getMe.
	CanReadAllGroupMessages *bool `json:"can_read_all_group_messages,omitempty"`
	// LanguageCode
	// IETF language tag of the user's language
	LanguageCode *string `json:"language_code,omitempty"`
	// LastName
	// User's or bot's last name
	LastName *string `json:"last_name,omitempty"`
	// SupportsInlineQueries
	// True, if the bot supports inline queries. Returned only in getMe.
	SupportsInlineQueries *bool `json:"supports_inline_queries,omitempty"`
	// Username
	// User's or bot's username
	Username *string `json:"username,omitempty"`
}

func (t *User) GetCanJoinGroups() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanJoinGroups; field != nil {
		return *field
	}
	return res
}

func (t *User) GetCanReadAllGroupMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanReadAllGroupMessages; field != nil {
		return *field
	}
	return res
}

func (t *User) GetLanguageCode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LanguageCode; field != nil {
		return *field
	}
	return res
}

func (t *User) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *User) GetSupportsInlineQueries() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SupportsInlineQueries; field != nil {
		return *field
	}
	return res
}

func (t *User) GetUsername() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Username; field != nil {
		return *field
	}
	return res
}

// UserProfilePhotos
// This object represent a user's profile pictures.
type UserProfilePhotos struct {
	// Photos
	// Requested profile pictures (in up to 4 sizes each)
	Photos [][]PhotoSize `json:"photos"`
	// TotalCount
	// Total number of profile pictures the target user has
	TotalCount int64 `json:"total_count"`
}

// Venue
// This object represents a venue.
type Venue struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// Location
	// Venue location
	Location Location `json:"location"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// FoursquareID
	// Foursquare identifier of the venue
	FoursquareID *string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType *string `json:"foursquare_type,omitempty"`
}

func (t *Venue) GetFoursquareID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareID; field != nil {
		return *field
	}
	return res
}

func (t *Venue) GetFoursquareType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareType; field != nil {
		return *field
	}
	return res
}

// Video
// This object represents a video file.
type Video struct {
	// Duration
	// Duration of the video in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Video height as defined by sender
	Height int64 `json:"height"`
	// Width
	// Video width as defined by sender
	Width int64 `json:"width"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// Mime type of a file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Thumb
	// Video thumbnail
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *Video) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Video) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Video) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// VideoNote
// This object represents a video message (available in Telegram apps as of v.4.0).
type VideoNote struct {
	// Duration
	// Duration of the video in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Length
	// Video width and height (diameter of the video message) as defined by sender
	Length int64 `json:"length"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// Thumb
	// Video thumbnail
	Thumb *PhotoSize `json:"thumb,omitempty"`
}

func (t *VideoNote) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *VideoNote) GetThumb() PhotoSize {
	var res PhotoSize
	if t == nil {
		return res
	}
	if field := t.Thumb; field != nil {
		return *field
	}
	return res
}

// Voice
// This object represents a voice note.
type Voice struct {
	// Duration
	// Duration of the audio in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FileSize
	// File size
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
}

func (t *Voice) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Voice) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

// WebhookInfo
// Contains information about the current status of a webhook.
type WebhookInfo struct {
	// HasCustomCertificate
	// True, if a custom certificate was provided for webhook certificate checks
	HasCustomCertificate bool `json:"has_custom_certificate"`
	// PendingUpdateCount
	// Number of updates awaiting delivery
	PendingUpdateCount int64 `json:"pending_update_count"`
	// URL
	// Webhook URL, may be empty if webhook is not set up
	URL string `json:"url"`
	// AllowedUpdates
	// A list of update types the bot is subscribed to. Defaults to all update types
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// LastErrorDate
	// Unix time for the most recent error that happened when trying to deliver an update via
	// webhook
	LastErrorDate *int64 `json:"last_error_date,omitempty"`
	// LastErrorMessage
	// Error message in human-readable format for the most recent error that happened when trying
	// to deliver an update via webhook
	LastErrorMessage *string `json:"last_error_message,omitempty"`
	// MaxConnections
	// Maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery
	MaxConnections *int64 `json:"max_connections,omitempty"`
}

func (t *WebhookInfo) GetLastErrorDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LastErrorDate; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetLastErrorMessage() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastErrorMessage; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetMaxConnections() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MaxConnections; field != nil {
		return *field
	}
	return res
}
