// Generated by: github.com/Feresey/gen-tgbotapi

package tgapi

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
)

// AddStickerToSet
// Use this method to add a new sticker to a set created by the bot. The format of the added
// sticker must match the format of the other stickers in the set. Emoji sticker sets can have up
// to 200 stickers. Animated and video sticker sets can have up to 50 stickers. Static sticker sets
// can have up to 120 stickers. Returns True on success.
type AddStickerToSetConfig struct {
	// Name
	// Sticker set name
	Name string `json:"name"`
	// Sticker
	// A JSON-serialized object with information about the added sticker. If exactly the same
	// sticker had already been added to the set, then the set isn't changed.
	Sticker InputSticker `json:"sticker"`
	// UserID
	// User identifier of sticker set owner
	UserID int64 `json:"user_id"`
}

// AddStickerToSet
// Use this method to add a new sticker to a set created by the bot. The format of the added
// sticker must match the format of the other stickers in the set. Emoji sticker sets can have up
// to 200 stickers. Animated and video sticker sets can have up to 50 stickers. Static sticker sets
// can have up to 120 stickers. Returns True on success.
func (api *API) AddStickerToSet(
	ctx context.Context,
	args *AddStickerToSetConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "addStickerToSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// AnswerCallbackQuery
// Use this method to send answers to callback queries sent from inline keyboards. The answer will
// be displayed to the user as a notification at the top of the chat screen or as an alert. On
// success, True is returned.
type AnswerCallbackQueryConfig struct {
	// CallbackQueryID
	// Unique identifier for the query to be answered
	CallbackQueryID string `json:"callback_query_id"`
	// CacheTime
	// The maximum amount of time in seconds that the result of the callback query may be cached
	// client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.
	CacheTime int64 `json:"cache_time,omitempty"`
	// ShowAlert
	// If True, an alert will be shown by the client instead of a notification at the top of the
	// chat screen. Defaults to false.
	ShowAlert bool `json:"show_alert,omitempty"`
	// Text
	// Text of the notification. If not specified, nothing will be shown to the user, 0-200
	// characters
	Text string `json:"text,omitempty"`
	// URL
	// URL that will be opened by the user's client. If you have created a Game and accepted the
	// conditions via @BotFather, specify the URL that opens your game - note that this will only
	// work if the query comes from a callback_game button.Otherwise, you may use links like
	// t.me/your_bot?start=XXXX that open your bot with a parameter.
	URL string `json:"url,omitempty"`
}

// AnswerCallbackQuery
// Use this method to send answers to callback queries sent from inline keyboards. The answer will
// be displayed to the user as a notification at the top of the chat screen or as an alert. On
// success, True is returned.
func (api *API) AnswerCallbackQuery(
	ctx context.Context,
	args *AnswerCallbackQueryConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "answerCallbackQuery", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// AnswerInlineQuery
// Use this method to send answers to an inline query. On success, True is returned.No more than 50
// results per query are allowed.
type AnswerInlineQueryConfig struct {
	// InlineQueryID
	// Unique identifier for the answered query
	InlineQueryID string `json:"inline_query_id"`
	// Results
	// A JSON-serialized array of results for the inline query
	Results []InlineQueryResult `json:"results"`
	// Button
	// A JSON-serialized object describing a button to be shown above inline query results
	Button *InlineQueryResultsButton `json:"button,omitempty"`
	// CacheTime
	// The maximum amount of time in seconds that the result of the inline query may be cached on
	// the server. Defaults to 300.
	CacheTime int64 `json:"cache_time,omitempty"`
	// IsPersonal
	// Pass True if results may be cached on the server side only for the user that sent the query.
	// By default, results may be returned to any user who sends the same query.
	IsPersonal bool `json:"is_personal,omitempty"`
	// NextOffset
	// Pass the offset that a client should send in the next query with the same text to receive
	// more results. Pass an empty string if there are no more results or if you don't support
	// pagination. Offset length can't exceed 64 bytes.
	NextOffset string `json:"next_offset,omitempty"`
}

// AnswerInlineQuery
// Use this method to send answers to an inline query. On success, True is returned.No more than 50
// results per query are allowed.
func (api *API) AnswerInlineQuery(
	ctx context.Context,
	args *AnswerInlineQueryConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "answerInlineQuery", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// AnswerPreCheckoutQuery
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an Update with the field pre_checkout_query. Use this method to
// respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must
// receive an answer within 10 seconds after the pre-checkout query was sent.
type AnswerPreCheckoutQueryConfig struct {
	// Ok
	// Specify True if everything is alright (goods are available, etc.) and the bot is ready to
	// proceed with the order. Use False if there are any problems.
	Ok bool `json:"ok"`
	// PreCheckoutQueryID
	// Unique identifier for the query to be answered
	PreCheckoutQueryID string `json:"pre_checkout_query_id"`
	// ErrorMessage
	// Required if ok is False. Error message in human readable form that explains the reason for
	// failure to proceed with the checkout (e.g. "Sorry, somebody just bought the last of our
	// amazing black T-shirts while you were busy filling out your payment details. Please choose a
	// different color or garment!"). Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
}

// AnswerPreCheckoutQuery
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an Update with the field pre_checkout_query. Use this method to
// respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must
// receive an answer within 10 seconds after the pre-checkout query was sent.
func (api *API) AnswerPreCheckoutQuery(
	ctx context.Context,
	args *AnswerPreCheckoutQueryConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "answerPreCheckoutQuery", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// AnswerShippingQuery
// If you sent an invoice requesting a shipping address and the parameter is_flexible was
// specified, the Bot API will send an Update with a shipping_query field to the bot. Use this
// method to reply to shipping queries. On success, True is returned.
type AnswerShippingQueryConfig struct {
	// Ok
	// Pass True if delivery to the specified address is possible and False if there are any
	// problems (for example, if delivery to the specified address is not possible)
	Ok bool `json:"ok"`
	// ShippingQueryID
	// Unique identifier for the query to be answered
	ShippingQueryID string `json:"shipping_query_id"`
	// ErrorMessage
	// Required if ok is False. Error message in human readable form that explains why it is
	// impossible to complete the order (e.g. "Sorry, delivery to your desired address is
	// unavailable'). Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
	// ShippingOptions
	// Required if ok is True. A JSON-serialized array of available shipping options.
	ShippingOptions []ShippingOption `json:"shipping_options,omitempty"`
}

// AnswerShippingQuery
// If you sent an invoice requesting a shipping address and the parameter is_flexible was
// specified, the Bot API will send an Update with a shipping_query field to the bot. Use this
// method to reply to shipping queries. On success, True is returned.
func (api *API) AnswerShippingQuery(
	ctx context.Context,
	args *AnswerShippingQueryConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "answerShippingQuery", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// AnswerWebAppQuery
// Use this method to set the result of an interaction with a Web App and send a corresponding
// message on behalf of the user to the chat from which the query originated. On success, a
// SentWebAppMessage object is returned.
func (api *API) AnswerWebAppQuery(
	ctx context.Context,
	// required.
	// A JSON-serialized object describing the message to be sent
	result InlineQueryResult,
	// required.
	// Unique identifier for the query to be answered
	webAppQueryID string,
) (*SentWebAppMessage, error) {
	args := map[string]interface{}{
		"result":           result,
		"web_app_query_id": webAppQueryID,
	}
	resp, err := api.MakeRequest(ctx, "answerWebAppQuery", args)
	if err != nil {
		return nil, err
	}
	var data SentWebAppMessage
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// ApproveChatJoinRequest
// Use this method to approve a chat join request. The bot must be an administrator in the chat for
// this to work and must have the can_invite_users administrator right. Returns True on success.
func (api *API) ApproveChatJoinRequest(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// Unique identifier of the target user
	userID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
		"user_id": userID,
	}
	resp, err := api.MakeRequest(ctx, "approveChatJoinRequest", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// BanChatMember
// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups
// and channels, the user will not be able to return to the chat on their own using invite links,
// etc., unless unbanned first. The bot must be an administrator in the chat for this to work and
// must have the appropriate administrator rights. Returns True on success.
type BanChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target group or username of the target supergroup or channel (in
	// the format @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// RevokeMessages
	// Pass True to delete all messages from the chat for the user that is being removed. If False,
	// the user will be able to see messages in the group that were sent before the user was
	// removed. Always True for supergroups and channels.
	RevokeMessages bool `json:"revoke_messages,omitempty"`
	// UntilDate
	// Date when the user will be unbanned, unix time. If user is banned for more than 366 days or
	// less than 30 seconds from the current time they are considered to be banned forever. Applied
	// for supergroups and channels only.
	UntilDate int64 `json:"until_date,omitempty"`
}

// BanChatMember
// Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups
// and channels, the user will not be able to return to the chat on their own using invite links,
// etc., unless unbanned first. The bot must be an administrator in the chat for this to work and
// must have the appropriate administrator rights. Returns True on success.
func (api *API) BanChatMember(
	ctx context.Context,
	args *BanChatMemberConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "banChatMember", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// BanChatSenderChat
// Use this method to ban a channel chat in a supergroup or a channel. Until the chat is unbanned,
// the owner of the banned chat won't be able to send messages on behalf of any of their channels.
// The bot must be an administrator in the supergroup or channel for this to work and must have the
// appropriate administrator rights. Returns True on success.
func (api *API) BanChatSenderChat(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// Unique identifier of the target sender chat
	senderChatID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":        chatID,
		"sender_chat_id": senderChatID,
	}
	resp, err := api.MakeRequest(ctx, "banChatSenderChat", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// Close
// Use this method to close the bot instance before moving it from one local server to another. You
// need to delete the webhook before calling this method to ensure that the bot isn't launched
// again after server restart. The method will return error 429 in the first 10 minutes after the
// bot is launched. Returns True on success. Requires no parameters.
func (api *API) Close(
	ctx context.Context,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "close", nil)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CloseForumTopic
// Use this method to close an open topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_manage_topics administrator
// rights, unless it is the creator of the topic. Returns True on success.
func (api *API) CloseForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// Unique identifier for the target message thread of the forum topic
	messageThreadID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
	}
	resp, err := api.MakeRequest(ctx, "closeForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CloseGeneralForumTopic
// Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_manage_topics administrator
// rights. Returns True on success.
func (api *API) CloseGeneralForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "closeGeneralForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CopyMessage
// Use this method to copy messages of any kind. Service messages and invoice messages can't be
// copied. A quiz poll can be copied only if the value of the field correct_option_id is known to
// the bot. The method is analogous to the method forwardMessage, but the copied message doesn't
// have a link to the original message. Returns the MessageId of the sent message on success.
type CopyMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FromChatID
	// Unique identifier for the chat where the original message was sent (or channel username in
	// the format @channelusername)
	FromChatID IntStr `json:"from_chat_id"`
	// MessageID
	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// New caption for media, 0-1024 characters after entities parsing. If not specified, the
	// original caption is kept
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the new caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the new caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// CopyMessage
// Use this method to copy messages of any kind. Service messages and invoice messages can't be
// copied. A quiz poll can be copied only if the value of the field correct_option_id is known to
// the bot. The method is analogous to the method forwardMessage, but the copied message doesn't
// have a link to the original message. Returns the MessageId of the sent message on success.
func (api *API) CopyMessage(
	ctx context.Context,
	args *CopyMessageConfig,
) (*MessageID, error) {
	resp, err := api.MakeRequest(ctx, "copyMessage", args)
	if err != nil {
		return nil, err
	}
	var data MessageID
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CreateChatInviteLink
// Use this method to create an additional invite link for a chat. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. The link can be
// revoked using the method revokeChatInviteLink. Returns the new invite link as ChatInviteLink
// object.
type CreateChatInviteLinkConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// CreatesJoinRequest
	// True, if users joining the chat via the link need to be approved by chat administrators. If
	// True, member_limit can't be specified
	CreatesJoinRequest bool `json:"creates_join_request,omitempty"`
	// ExpireDate
	// Point in time (Unix timestamp) when the link will expire
	ExpireDate int64 `json:"expire_date,omitempty"`
	// MemberLimit
	// The maximum number of users that can be members of the chat simultaneously after joining the
	// chat via this invite link; 1-99999
	MemberLimit int64 `json:"member_limit,omitempty"`
	// Name
	// Invite link name; 0-32 characters
	Name string `json:"name,omitempty"`
}

// CreateChatInviteLink
// Use this method to create an additional invite link for a chat. The bot must be an administrator
// in the chat for this to work and must have the appropriate administrator rights. The link can be
// revoked using the method revokeChatInviteLink. Returns the new invite link as ChatInviteLink
// object.
func (api *API) CreateChatInviteLink(
	ctx context.Context,
	args *CreateChatInviteLinkConfig,
) (*ChatInviteLink, error) {
	resp, err := api.MakeRequest(ctx, "createChatInviteLink", args)
	if err != nil {
		return nil, err
	}
	var data ChatInviteLink
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CreateForumTopic
// Use this method to create a topic in a forum supergroup chat. The bot must be an administrator
// in the chat for this to work and must have the can_manage_topics administrator rights. Returns
// information about the created topic as a ForumTopic object.
type CreateForumTopicConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Name
	// Topic name, 1-128 characters
	Name string `json:"name"`
	// IconColor
	// Color of the topic icon in RGB format. Currently, must be one of 7322096 (0x6FB9F0),
	// 16766590 (0xFFD67E), 13338331 (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or
	// 16478047 (0xFB6F5F)
	IconColor int64 `json:"icon_color,omitempty"`
	// IconCustomEmojiID
	// Unique identifier of the custom emoji shown as the topic icon. Use getForumTopicIconStickers
	// to get all allowed custom emoji identifiers.
	IconCustomEmojiID string `json:"icon_custom_emoji_id,omitempty"`
}

// CreateForumTopic
// Use this method to create a topic in a forum supergroup chat. The bot must be an administrator
// in the chat for this to work and must have the can_manage_topics administrator rights. Returns
// information about the created topic as a ForumTopic object.
func (api *API) CreateForumTopic(
	ctx context.Context,
	args *CreateForumTopicConfig,
) (*ForumTopic, error) {
	resp, err := api.MakeRequest(ctx, "createForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data ForumTopic
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CreateInvoiceLink
// Use this method to create a link for an invoice. Returns the created invoice link as String on
// success.
type CreateInvoiceLinkConfig struct {
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payment provider token, obtained via BotFather
	ProviderToken string `json:"provider_token"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// IsFlexible
	// Pass True if the final price depends on the shipping method
	IsFlexible bool `json:"is_flexible,omitempty"`
	// MaxTipAmount
	// The maximum accepted amount for tips in the smallest units of the currency (integer, not
	// float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the
	// exp parameter in currencies.json, it shows the number of digits past the decimal point for
	// each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount int64 `json:"max_tip_amount,omitempty"`
	// NeedEmail
	// Pass True if you require the user's email address to complete the order
	NeedEmail bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True if you require the user's full name to complete the order
	NeedName bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True if you require the user's phone number to complete the order
	NeedPhoneNumber bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True if you require the user's shipping address to complete the order
	NeedShippingAddress bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size in bytes
	PhotoSize int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service.
	PhotoURL string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth int64 `json:"photo_width,omitempty"`
	// ProviderData
	// JSON-serialized data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData string `json:"provider_data,omitempty"`
	// SendEmailToProvider
	// Pass True if the user's email address should be sent to the provider
	SendEmailToProvider bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True if the user's phone number should be sent to the provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider,omitempty"`
	// SuggestedTipAmounts
	// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency
	// (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested
	// tip amounts must be positive, passed in a strictly increased order and must not exceed
	// max_tip_amount.
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts,omitempty"`
}

// CreateInvoiceLink
// Use this method to create a link for an invoice. Returns the created invoice link as String on
// success.
func (api *API) CreateInvoiceLink(
	ctx context.Context,
	args *CreateInvoiceLinkConfig,
) (string, error) {
	resp, err := api.MakeRequest(ctx, "createInvoiceLink", args)
	if err != nil {
		return "", err
	}
	var data string
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// CreateNewStickerSet
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. Returns True on success.
type CreateNewStickerSetConfig struct {
	// Name
	// Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals). Can contain
	// only English letters, digits and underscores. Must begin with a letter, can't contain
	// consecutive underscores and must end in "_by_<bot_username>". <bot_username> is case
	// insensitive. 1-64 characters.
	Name string `json:"name"`
	// StickerFormat
	// Format of stickers in the set, must be one of "static", "animated", "video"
	StickerFormat string `json:"sticker_format"`
	// Stickers
	// A JSON-serialized list of 1-50 initial stickers to be added to the sticker set
	Stickers []InputSticker `json:"stickers"`
	// Title
	// Sticker set title, 1-64 characters
	Title string `json:"title"`
	// UserID
	// User identifier of created sticker set owner
	UserID int64 `json:"user_id"`
	// NeedsRepainting
	// Pass True if stickers in the sticker set must be repainted to the color of text when used in
	// messages, the accent color if used as emoji status, white on chat photos, or another
	// appropriate color based on context; for custom emoji sticker sets only
	NeedsRepainting bool `json:"needs_repainting,omitempty"`
	// StickerType
	// Type of stickers in the set, pass "regular", "mask", or "custom_emoji". By default, a
	// regular sticker set is created.
	StickerType string `json:"sticker_type,omitempty"`
}

// CreateNewStickerSet
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. Returns True on success.
func (api *API) CreateNewStickerSet(
	ctx context.Context,
	args *CreateNewStickerSetConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "createNewStickerSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeclineChatJoinRequest
// Use this method to decline a chat join request. The bot must be an administrator in the chat for
// this to work and must have the can_invite_users administrator right. Returns True on success.
func (api *API) DeclineChatJoinRequest(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// Unique identifier of the target user
	userID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
		"user_id": userID,
	}
	resp, err := api.MakeRequest(ctx, "declineChatJoinRequest", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteChatPhoto
// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must
// be an administrator in the chat for this to work and must have the appropriate administrator
// rights. Returns True on success.
func (api *API) DeleteChatPhoto(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "deleteChatPhoto", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteChatStickerSet
// Use this method to delete a group sticker set from a supergroup. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Use the field can_set_sticker_set optionally returned in getChat requests to check if the bot
// can use this method. Returns True on success.
func (api *API) DeleteChatStickerSet(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "deleteChatStickerSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteForumTopic
// Use this method to delete a forum topic along with all its messages in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the
// can_delete_messages administrator rights. Returns True on success.
func (api *API) DeleteForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// Unique identifier for the target message thread of the forum topic
	messageThreadID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
	}
	resp, err := api.MakeRequest(ctx, "deleteForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteMessage
// Use this method to delete a message, including service messages, with the following
// limitations:- A message can only be deleted if it was sent less than 48 hours ago.- Service
// messages about a supergroup, channel, or forum topic creation can't be deleted.- A dice message
// in a private chat can only be deleted if it was sent more than 24 hours ago.- Bots can delete
// outgoing messages in private chats, groups, and supergroups.- Bots can delete incoming messages
// in private chats.- Bots granted can_post_messages permissions can delete outgoing messages in
// channels.- If the bot is an administrator of a group, it can delete any message there.- If the
// bot has can_delete_messages permission in a supergroup or a channel, it can delete any message
// there.Returns True on success.
func (api *API) DeleteMessage(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// Identifier of the message to delete
	messageID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":    chatID,
		"message_id": messageID,
	}
	resp, err := api.MakeRequest(ctx, "deleteMessage", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteMyCommands
// Use this method to delete the list of the bot's commands for the given scope and user language.
// After deletion, higher level commands will be shown to affected users. Returns True on success.
func (api *API) DeleteMyCommands(
	ctx context.Context,
	// not required.
	// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users
	// from the given scope, for whose language there are no dedicated commands
	languageCode *string,
	// not required.
	// A JSON-serialized object, describing scope of users for which the commands are relevant.
	// Defaults to BotCommandScopeDefault.
	scope *BotCommandScope,
) (*bool, error) {
	args := map[string]interface{}{
		"language_code": languageCode,
		"scope":         scope,
	}
	resp, err := api.MakeRequest(ctx, "deleteMyCommands", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteStickerFromSet
// Use this method to delete a sticker from a set created by the bot. Returns True on success.
func (api *API) DeleteStickerFromSet(
	ctx context.Context,
	// required.
	// File identifier of the sticker
	sticker string,
) (*bool, error) {
	args := map[string]interface{}{
		"sticker": sticker,
	}
	resp, err := api.MakeRequest(ctx, "deleteStickerFromSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteStickerSet
// Use this method to delete a sticker set that was created by the bot. Returns True on success.
func (api *API) DeleteStickerSet(
	ctx context.Context,
	// required.
	// Sticker set name
	name string,
) (*bool, error) {
	args := map[string]interface{}{
		"name": name,
	}
	resp, err := api.MakeRequest(ctx, "deleteStickerSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// DeleteWebhook
// Use this method to remove webhook integration if you decide to switch back to getUpdates.
// Returns True on success.
func (api *API) DeleteWebhook(
	ctx context.Context,
	// not required.
	// Pass True to drop all pending updates
	dropPendingUpdates *bool,
) (*bool, error) {
	args := map[string]interface{}{
		"drop_pending_updates": dropPendingUpdates,
	}
	resp, err := api.MakeRequest(ctx, "deleteWebhook", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditChatInviteLink
// Use this method to edit a non-primary invite link created by the bot. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the edited invite link as a ChatInviteLink object.
type EditChatInviteLinkConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// InviteLink
	// The invite link to edit
	InviteLink string `json:"invite_link"`
	// CreatesJoinRequest
	// True, if users joining the chat via the link need to be approved by chat administrators. If
	// True, member_limit can't be specified
	CreatesJoinRequest bool `json:"creates_join_request,omitempty"`
	// ExpireDate
	// Point in time (Unix timestamp) when the link will expire
	ExpireDate int64 `json:"expire_date,omitempty"`
	// MemberLimit
	// The maximum number of users that can be members of the chat simultaneously after joining the
	// chat via this invite link; 1-99999
	MemberLimit int64 `json:"member_limit,omitempty"`
	// Name
	// Invite link name; 0-32 characters
	Name string `json:"name,omitempty"`
}

// EditChatInviteLink
// Use this method to edit a non-primary invite link created by the bot. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the edited invite link as a ChatInviteLink object.
func (api *API) EditChatInviteLink(
	ctx context.Context,
	args *EditChatInviteLinkConfig,
) (*ChatInviteLink, error) {
	resp, err := api.MakeRequest(ctx, "editChatInviteLink", args)
	if err != nil {
		return nil, err
	}
	var data ChatInviteLink
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditForumTopic
// Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have can_manage_topics administrator rights,
// unless it is the creator of the topic. Returns True on success.
type EditForumTopicConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// MessageThreadID
	// Unique identifier for the target message thread of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`
	// IconCustomEmojiID
	// New unique identifier of the custom emoji shown as the topic icon. Use
	// getForumTopicIconStickers to get all allowed custom emoji identifiers. Pass an empty string
	// to remove the icon. If not specified, the current icon will be kept
	IconCustomEmojiID string `json:"icon_custom_emoji_id,omitempty"`
	// Name
	// New topic name, 0-128 characters. If not specified or empty, the current name of the topic
	// will be kept
	Name string `json:"name,omitempty"`
}

// EditForumTopic
// Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have can_manage_topics administrator rights,
// unless it is the creator of the topic. Returns True on success.
func (api *API) EditForumTopic(
	ctx context.Context,
	args *EditForumTopicConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "editForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditGeneralForumTopic
// Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must
// be an administrator in the chat for this to work and must have can_manage_topics administrator
// rights. Returns True on success.
func (api *API) EditGeneralForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// New topic name, 1-128 characters
	name string,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
		"name":    name,
	}
	resp, err := api.MakeRequest(ctx, "editGeneralForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageCaption
// Use this method to edit captions of messages. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
type EditMessageCaptionConfig struct {
	// Caption
	// New caption of the message, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageCaption
// Use this method to edit captions of messages. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageCaption(
	ctx context.Context,
	args *EditMessageCaptionConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageCaption", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageLiveLocation
// Use this method to edit live location messages. A location can be edited until its live_period
// expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if
// the edited message is not an inline message, the edited Message is returned, otherwise True is
// returned.
type EditMessageLiveLocationConfig struct {
	// Latitude
	// Latitude of new location
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of new location
	Longitude float64 `json:"longitude"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// Heading
	// Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
	Heading int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ProximityAlertRadius
	// The maximum distance for proximity alerts about approaching another chat member, in meters.
	// Must be between 1 and 100000 if specified.
	ProximityAlertRadius int64 `json:"proximity_alert_radius,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageLiveLocation
// Use this method to edit live location messages. A location can be edited until its live_period
// expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if
// the edited message is not an inline message, the edited Message is returned, otherwise True is
// returned.
func (api *API) EditMessageLiveLocation(
	ctx context.Context,
	args *EditMessageLiveLocationConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageLiveLocation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageMedia
// Use this method to edit animation, audio, document, photo, or video messages. If a message is
// part of a message album, then it can be edited only to an audio for audio albums, only to a
// document for document albums and to a photo or a video otherwise. When an inline message is
// edited, a new file can't be uploaded; use a previously uploaded file via its file_id or specify
// a URL. On success, if the edited message is not an inline message, the edited Message is
// returned, otherwise True is returned.
type EditMessageMediaConfig struct {
	// Media
	// A JSON-serialized object for a new media content of the message
	Media InputMedia `json:"media"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageMedia
// Use this method to edit animation, audio, document, photo, or video messages. If a message is
// part of a message album, then it can be edited only to an audio for audio albums, only to a
// document for document albums and to a photo or a video otherwise. When an inline message is
// edited, a new file can't be uploaded; use a previously uploaded file via its file_id or specify
// a URL. On success, if the edited message is not an inline message, the edited Message is
// returned, otherwise True is returned.
func (api *API) EditMessageMedia(
	ctx context.Context,
	args *EditMessageMediaConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageMedia", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageReplyMarkup
// Use this method to edit only the reply markup of messages. On success, if the edited message is
// not an inline message, the edited Message is returned, otherwise True is returned.
type EditMessageReplyMarkupConfig struct {
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageReplyMarkup
// Use this method to edit only the reply markup of messages. On success, if the edited message is
// not an inline message, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageReplyMarkup(
	ctx context.Context,
	args *EditMessageReplyMarkupConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageReplyMarkup", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageText
// Use this method to edit text and game messages. On success, if the edited message is not an
// inline message, the edited Message is returned, otherwise True is returned.
type EditMessageTextConfig struct {
	// Text
	// New text of the message, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`
	// Entities
	// A JSON-serialized list of special entities that appear in message text, which can be
	// specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageText
// Use this method to edit text and game messages. On success, if the edited message is not an
// inline message, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageText(
	ctx context.Context,
	args *EditMessageTextConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageText", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// ExportChatInviteLink
// Use this method to generate a new primary invite link for a chat; any previously generated
// primary link is revoked. The bot must be an administrator in the chat for this to work and must
// have the appropriate administrator rights. Returns the new invite link as String on success.
func (api *API) ExportChatInviteLink(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) (string, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "exportChatInviteLink", args)
	if err != nil {
		return "", err
	}
	var data string
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// ForwardMessage
// Use this method to forward messages of any kind. Service messages can't be forwarded. On
// success, the sent Message is returned.
type ForwardMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FromChatID
	// Unique identifier for the chat where the original message was sent (or channel username in
	// the format @channelusername)
	FromChatID IntStr `json:"from_chat_id"`
	// MessageID
	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the forwarded message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
}

// ForwardMessage
// Use this method to forward messages of any kind. Service messages can't be forwarded. On
// success, the sent Message is returned.
func (api *API) ForwardMessage(
	ctx context.Context,
	args *ForwardMessageConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "forwardMessage", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetChat
// Use this method to get up to date information about the chat (current name of the user for
// one-on-one conversations, current username of a user, group or channel, etc.). Returns a Chat
// object on success.
func (api *API) GetChat(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) (*Chat, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChat", args)
	if err != nil {
		return nil, err
	}
	var data Chat
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetChatAdministrators
// Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array
// of ChatMember objects.
func (api *API) GetChatAdministrators(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) ([]ChatMember, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChatAdministrators", args)
	if err != nil {
		return nil, err
	}
	var data []ChatMember
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetChatMember
// Use this method to get information about a member of a chat. The method is only guaranteed to
// work for other users if the bot is an administrator in the chat. Returns a ChatMember object on
// success.
func (api *API) GetChatMember(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
	// required.
	// Unique identifier of the target user
	userID int64,
) (*ChatMember, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
		"user_id": userID,
	}
	resp, err := api.MakeRequest(ctx, "getChatMember", args)
	if err != nil {
		return nil, err
	}
	var data ChatMember
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetChatMemberCount
// Use this method to get the number of members in a chat. Returns Int on success.
func (api *API) GetChatMemberCount(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) (int64, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChatMemberCount", args)
	if err != nil {
		return 0, err
	}
	var data int64
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetChatMenuButton
// Use this method to get the current value of the bot's menu button in a private chat, or the
// default menu button. Returns MenuButton on success.
func (api *API) GetChatMenuButton(
	ctx context.Context,
	// not required.
	// Unique identifier for the target private chat. If not specified, default bot's menu
	// button will be returned
	chatID *int64,
) (*MenuButton, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChatMenuButton", args)
	if err != nil {
		return nil, err
	}
	var data MenuButton
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetCustomEmojiStickers
// Use this method to get information about custom emoji stickers by their identifiers. Returns an
// Array of Sticker objects.
func (api *API) GetCustomEmojiStickers(
	ctx context.Context,
	// required.
	// List of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.
	customEmojiIDs []string,
) ([]Sticker, error) {
	args := map[string]interface{}{
		"custom_emoji_ids": customEmojiIDs,
	}
	resp, err := api.MakeRequest(ctx, "getCustomEmojiStickers", args)
	if err != nil {
		return nil, err
	}
	var data []Sticker
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetFile
// Use this method to get basic information about a file and prepare it for downloading. For the
// moment, bots can download files of up to 20MB in size. On success, a File object is returned.
// The file can then be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the
// response. It is guaranteed that the link will be valid for at least 1 hour. When the link
// expires, a new one can be requested by calling getFile again.
func (api *API) GetFile(
	ctx context.Context,
	// required.
	// File identifier to get information about
	fileID string,
) (*File, error) {
	args := map[string]interface{}{
		"file_id": fileID,
	}
	resp, err := api.MakeRequest(ctx, "getFile", args)
	if err != nil {
		return nil, err
	}
	var data File
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetForumTopicIconStickers
// Use this method to get custom emoji stickers, which can be used as a forum topic icon by any
// user. Requires no parameters. Returns an Array of Sticker objects.
func (api *API) GetForumTopicIconStickers(
	ctx context.Context,
) ([]Sticker, error) {
	resp, err := api.MakeRequest(ctx, "getForumTopicIconStickers", nil)
	if err != nil {
		return nil, err
	}
	var data []Sticker
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetGameHighScores
// Use this method to get data for high score tables. Will return the score of the specified user
// and several of their neighbors in a game. Returns an Array of GameHighScore objects.
type GetGameHighScoresConfig struct {
	// UserID
	// Target user id
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`
}

// GetGameHighScores
// Use this method to get data for high score tables. Will return the score of the specified user
// and several of their neighbors in a game. Returns an Array of GameHighScore objects.
func (api *API) GetGameHighScores(
	ctx context.Context,
	args *GetGameHighScoresConfig,
) ([]GameHighScore, error) {
	resp, err := api.MakeRequest(ctx, "getGameHighScores", args)
	if err != nil {
		return nil, err
	}
	var data []GameHighScore
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetMe
// A simple method for testing your bot's authentication token. Requires no parameters. Returns
// basic information about the bot in form of a User object.
func (api *API) GetMe(
	ctx context.Context,
) (*User, error) {
	resp, err := api.MakeRequest(ctx, "getMe", nil)
	if err != nil {
		return nil, err
	}
	var data User
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetMyCommands
// Use this method to get the current list of the bot's commands for the given scope and user
// language. Returns an Array of BotCommand objects. If commands aren't set, an empty list is
// returned.
func (api *API) GetMyCommands(
	ctx context.Context,
) ([]BotCommand, error) {
	args := map[string]interface{}{}
	resp, err := api.MakeRequest(ctx, "getMyCommands", args)
	if err != nil {
		return nil, err
	}
	var data []BotCommand
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetMyDefaultAdministratorRights
// Use this method to get the current default administrator rights of the bot. Returns
// ChatAdministratorRights on success.
func (api *API) GetMyDefaultAdministratorRights(
	ctx context.Context,
	// not required.
	// Pass True to get default administrator rights of the bot in channels. Otherwise, default
	// administrator rights of the bot for groups and supergroups will be returned.
	forChannels *bool,
) (*ChatAdministratorRights, error) {
	args := map[string]interface{}{
		"for_channels": forChannels,
	}
	resp, err := api.MakeRequest(ctx, "getMyDefaultAdministratorRights", args)
	if err != nil {
		return nil, err
	}
	var data ChatAdministratorRights
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetMyDescription
// Use this method to get the current bot description for the given user language. Returns
// BotDescription on success.
func (api *API) GetMyDescription(
	ctx context.Context,
	// not required.
	// A two-letter ISO 639-1 language code or an empty string
	languageCode *string,
) (*BotDescription, error) {
	args := map[string]interface{}{
		"language_code": languageCode,
	}
	resp, err := api.MakeRequest(ctx, "getMyDescription", args)
	if err != nil {
		return nil, err
	}
	var data BotDescription
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetMyName
// Use this method to get the current bot name for the given user language. Returns BotName on
// success.
func (api *API) GetMyName(
	ctx context.Context,
	// not required.
	// A two-letter ISO 639-1 language code or an empty string
	languageCode *string,
) (*BotName, error) {
	args := map[string]interface{}{
		"language_code": languageCode,
	}
	resp, err := api.MakeRequest(ctx, "getMyName", args)
	if err != nil {
		return nil, err
	}
	var data BotName
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetMyShortDescription
// Use this method to get the current bot short description for the given user language. Returns
// BotShortDescription on success.
func (api *API) GetMyShortDescription(
	ctx context.Context,
	// not required.
	// A two-letter ISO 639-1 language code or an empty string
	languageCode *string,
) (*BotShortDescription, error) {
	args := map[string]interface{}{
		"language_code": languageCode,
	}
	resp, err := api.MakeRequest(ctx, "getMyShortDescription", args)
	if err != nil {
		return nil, err
	}
	var data BotShortDescription
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetStickerSet
// Use this method to get a sticker set. On success, a StickerSet object is returned.
func (api *API) GetStickerSet(
	ctx context.Context,
	// required.
	// Name of the sticker set
	name string,
) (*StickerSet, error) {
	args := map[string]interface{}{
		"name": name,
	}
	resp, err := api.MakeRequest(ctx, "getStickerSet", args)
	if err != nil {
		return nil, err
	}
	var data StickerSet
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetUpdates
// Use this method to receive incoming updates using long polling (wiki). Returns an Array of
// Update objects.
type GetUpdatesConfig struct {
	// AllowedUpdates
	// A JSON-serialized list of the update types you want your bot to receive. For example,
	// specify ["message", "edited_channel_post", "callback_query"] to only receive updates of
	// these types. See Update for a complete list of available update types. Specify an empty list
	// to receive all update types except chat_member (default). If not specified, the previous
	// setting will be used.Please note that this parameter doesn't affect updates created before
	// the call to the getUpdates, so unwanted updates may be received for a short period of time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// Limit
	// Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to
	// 100.
	Limit int64 `json:"limit,omitempty"`
	// Offset
	// Identifier of the first update to be returned. Must be greater by one than the highest among
	// the identifiers of previously received updates. By default, updates starting with the
	// earliest unconfirmed update are returned. An update is considered confirmed as soon as
	// getUpdates is called with an offset higher than its update_id. The negative offset can be
	// specified to retrieve updates starting from -offset update from the end of the updates
	// queue. All previous updates will be forgotten.
	Offset int64 `json:"offset,omitempty"`
	// Timeout
	// Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be
	// positive, short polling should be used for testing purposes only.
	Timeout int64 `json:"timeout,omitempty"`
}

// GetUpdates
// Use this method to receive incoming updates using long polling (wiki). Returns an Array of
// Update objects.
func (api *API) GetUpdates(
	ctx context.Context,
	args *GetUpdatesConfig,
) ([]Update, error) {
	resp, err := api.MakeRequest(ctx, "getUpdates", args)
	if err != nil {
		return nil, err
	}
	var data []Update
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetUserProfilePhotos
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos
// object.
type GetUserProfilePhotosConfig struct {
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// Limit
	// Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to
	// 100.
	Limit int64 `json:"limit,omitempty"`
	// Offset
	// Sequential number of the first photo to be returned. By default, all photos are returned.
	Offset int64 `json:"offset,omitempty"`
}

// GetUserProfilePhotos
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos
// object.
func (api *API) GetUserProfilePhotos(
	ctx context.Context,
	args *GetUserProfilePhotosConfig,
) (*UserProfilePhotos, error) {
	resp, err := api.MakeRequest(ctx, "getUserProfilePhotos", args)
	if err != nil {
		return nil, err
	}
	var data UserProfilePhotos
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetWebhookInfo
// Use this method to get current webhook status. Requires no parameters. On success, returns a
// WebhookInfo object. If the bot is using getUpdates, will return an object with the url field
// empty.
func (api *API) GetWebhookInfo(
	ctx context.Context,
) (*WebhookInfo, error) {
	resp, err := api.MakeRequest(ctx, "getWebhookInfo", nil)
	if err != nil {
		return nil, err
	}
	var data WebhookInfo
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// HideGeneralForumTopic
// Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_manage_topics administrator
// rights. The topic will be automatically closed if it was open. Returns True on success.
func (api *API) HideGeneralForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "hideGeneralForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// LeaveChat
// Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
func (api *API) LeaveChat(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "leaveChat", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// LogOut
// Use this method to log out from the cloud Bot API server before launching the bot locally. You
// must log out the bot before running it locally, otherwise there is no guarantee that the bot
// will receive updates. After a successful call, you can immediately log in on a local server, but
// will not be able to log in back to the cloud Bot API server for 10 minutes. Returns True on
// success. Requires no parameters.
func (api *API) LogOut(
	ctx context.Context,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "logOut", nil)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// PinChatMessage
// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
// private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator
// right in a channel. Returns True on success.
type PinChatMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageID
	// Identifier of a message to pin
	MessageID int64 `json:"message_id"`
	// DisableNotification
	// Pass True if it is not necessary to send a notification to all chat members about the new
	// pinned message. Notifications are always disabled in channels and private chats.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// PinChatMessage
// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
// private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator
// right in a channel. Returns True on success.
func (api *API) PinChatMessage(
	ctx context.Context,
	args *PinChatMessageConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "pinChatMessage", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// PromoteChatMember
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Pass False for all boolean parameters to demote a user. Returns True on success.
type PromoteChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// CanChangeInfo
	// Pass True if the administrator can change chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info,omitempty"`
	// CanDeleteMessages
	// Pass True if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages,omitempty"`
	// CanEditMessages
	// Pass True if the administrator can edit messages of other users and can pin messages,
	// channels only
	CanEditMessages bool `json:"can_edit_messages,omitempty"`
	// CanInviteUsers
	// Pass True if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users,omitempty"`
	// CanManageChat
	// Pass True if the administrator can access the chat event log, chat statistics, message
	// statistics in channels, see channel members, see anonymous administrators in supergroups and
	// ignore slow mode. Implied by any other administrator privilege
	CanManageChat bool `json:"can_manage_chat,omitempty"`
	// CanManageTopics
	// Pass True if the user is allowed to create, rename, close, and reopen forum topics,
	// supergroups only
	CanManageTopics bool `json:"can_manage_topics,omitempty"`
	// CanManageVideoChats
	// Pass True if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats,omitempty"`
	// CanPinMessages
	// Pass True if the administrator can pin messages, supergroups only
	CanPinMessages bool `json:"can_pin_messages,omitempty"`
	// CanPostMessages
	// Pass True if the administrator can create channel posts, channels only
	CanPostMessages bool `json:"can_post_messages,omitempty"`
	// CanPromoteMembers
	// Pass True if the administrator can add new administrators with a subset of their own
	// privileges or demote administrators that they have promoted, directly or indirectly
	// (promoted by administrators that were appointed by him)
	CanPromoteMembers bool `json:"can_promote_members,omitempty"`
	// CanRestrictMembers
	// Pass True if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members,omitempty"`
	// IsAnonymous
	// Pass True if the administrator's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous,omitempty"`
}

// PromoteChatMember
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Pass False for all boolean parameters to demote a user. Returns True on success.
func (api *API) PromoteChatMember(
	ctx context.Context,
	args *PromoteChatMemberConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "promoteChatMember", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// ReopenForumTopic
// Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_manage_topics administrator
// rights, unless it is the creator of the topic. Returns True on success.
func (api *API) ReopenForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// Unique identifier for the target message thread of the forum topic
	messageThreadID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
	}
	resp, err := api.MakeRequest(ctx, "reopenForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// ReopenGeneralForumTopic
// Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be
// an administrator in the chat for this to work and must have the can_manage_topics administrator
// rights. The topic will be automatically unhidden if it was hidden. Returns True on success.
func (api *API) ReopenGeneralForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "reopenGeneralForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// RestrictChatMember
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate administrator rights. Pass True for
// all permissions to lift restrictions from a user. Returns True on success.
type RestrictChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Permissions
	// A JSON-serialized object for new user permissions
	Permissions ChatPermissions `json:"permissions"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// UntilDate
	// Date when restrictions will be lifted for the user, unix time. If user is restricted for
	// more than 366 days or less than 30 seconds from the current time, they are considered to be
	// restricted forever
	UntilDate int64 `json:"until_date,omitempty"`
	// UseIndependentChatPermissions
	// Pass True if chat permissions are set independently. Otherwise, the can_send_other_messages
	// and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios,
	// can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and
	// can_send_voice_notes permissions; the can_send_polls permission will imply the
	// can_send_messages permission.
	UseIndependentChatPermissions bool `json:"use_independent_chat_permissions,omitempty"`
}

// RestrictChatMember
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate administrator rights. Pass True for
// all permissions to lift restrictions from a user. Returns True on success.
func (api *API) RestrictChatMember(
	ctx context.Context,
	args *RestrictChatMemberConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "restrictChatMember", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// RevokeChatInviteLink
// Use this method to revoke an invite link created by the bot. If the primary link is revoked, a
// new link is automatically generated. The bot must be an administrator in the chat for this to
// work and must have the appropriate administrator rights. Returns the revoked invite link as
// ChatInviteLink object.
func (api *API) RevokeChatInviteLink(
	ctx context.Context,
	// required.
	// Unique identifier of the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// The invite link to revoke
	inviteLink string,
) (*ChatInviteLink, error) {
	args := map[string]interface{}{
		"chat_id":     chatID,
		"invite_link": inviteLink,
	}
	resp, err := api.MakeRequest(ctx, "revokeChatInviteLink", args)
	if err != nil {
		return nil, err
	}
	var data ChatInviteLink
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendAnimation
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On
// success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in
// size, this limit may be changed in the future.
type SendAnimationConfig struct {
	// Animation
	// Animation to send. Pass a file_id as String to send an animation that exists on the Telegram
	// servers (recommended), pass an HTTP URL as a String for Telegram to get an animation from
	// the Internet, or upload a new animation using multipart/form-data. More information on
	// Sending Files »
	Animation InputFile `json:"animation"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Animation caption (may also be used when resending animation by file_id), 0-1024 characters
	// after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent animation in seconds
	Duration int64 `json:"duration,omitempty"`
	// HasSpoiler
	// Pass True if the animation needs to be covered with a spoiler animation
	HasSpoiler bool `json:"has_spoiler,omitempty"`
	// Height
	// Animation height
	Height int64 `json:"height,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the animation caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *InputFile `json:"thumbnail,omitempty"`
	// Width
	// Animation width
	Width int64 `json:"width,omitempty"`
}

func (t SendAnimationConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("has_spoiler", strconv.FormatBool(t.HasSpoiler))
	res.Add("height", strconv.FormatInt(t.Height, 10))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	res.Add("width", strconv.FormatInt(t.Width, 10))
	return res, nil
}

// SendAnimation
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On
// success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in
// size, this limit may be changed in the future.}}
func (api *API) SendAnimation(
	ctx context.Context,
	args *SendAnimationConfig,
) (*Message, error) {
	if args.Animation.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendAnimation", "animation", &args.Animation)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendAnimation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendAudio
// Use this method to send audio files, if you want Telegram clients to display them in the music
// player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the
// future.
type SendAudioConfig struct {
	// Audio
	// Audio file to send. Pass a file_id as String to send an audio file that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an audio
	// file from the Internet, or upload a new one using multipart/form-data. More information on
	// Sending Files »
	Audio InputFile `json:"audio"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Audio caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of the audio in seconds
	Duration int64 `json:"duration,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// Performer
	// Performer
	Performer string `json:"performer,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *InputFile `json:"thumbnail,omitempty"`
	// Title
	// Track name
	Title string `json:"title,omitempty"`
}

func (t SendAudioConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("performer", t.Performer)
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	res.Add("title", t.Title)
	return res, nil
}

// SendAudio
// Use this method to send audio files, if you want Telegram clients to display them in the music
// player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the
// future.}}
func (api *API) SendAudio(
	ctx context.Context,
	args *SendAudioConfig,
) (*Message, error) {
	if args.Audio.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendAudio", "audio", &args.Audio)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendAudio", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendChatAction
// Use this method when you need to tell the user that something is happening on the bot's side.
// The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients
// clear its typing status). Returns True on success.
type SendChatActionConfig struct {
	// Action
	// Type of action to broadcast. Choose one, depending on what the user is about to receive:
	// typing for text messages, upload_photo for photos, record_video or upload_video for videos,
	// record_voice or upload_voice for voice notes, upload_document for general files,
	// choose_sticker for stickers, find_location for location data, record_video_note or
	// upload_video_note for video notes.
	Action string `json:"action"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageThreadID
	// Unique identifier for the target message thread; supergroups only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
}

// SendChatAction
// Use this method when you need to tell the user that something is happening on the bot's side.
// The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients
// clear its typing status). Returns True on success.
func (api *API) SendChatAction(
	ctx context.Context,
	args *SendChatActionConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "sendChatAction", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendContact
// Use this method to send phone contacts. On success, the sent Message is returned.
type SendContactConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// LastName
	// Contact's last name
	LastName string `json:"last_name,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard string `json:"vcard,omitempty"`
}

// SendContact
// Use this method to send phone contacts. On success, the sent Message is returned.
func (api *API) SendContact(
	ctx context.Context,
	args *SendContactConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendContact", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendDice
// Use this method to send an animated emoji that will display a random value. On success, the sent
// Message is returned.
type SendDiceConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Emoji
	// Emoji on which the dice throw animation is based. Currently, must be one of "", "", "", "",
	// "", or "". Dice can have values 1-6 for "", "" and "", values 1-5 for "" and "", and values
	// 1-64 for "". Defaults to ""
	Emoji string `json:"emoji,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendDice
// Use this method to send an animated emoji that will display a random value. On success, the sent
// Message is returned.
func (api *API) SendDice(
	ctx context.Context,
	args *SendDiceConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendDice", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendDocument
// Use this method to send general files. On success, the sent Message is returned. Bots can
// currently send files of any type of up to 50 MB in size, this limit may be changed in the
// future.
type SendDocumentConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Document
	// File to send. Pass a file_id as String to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or
	// upload a new one using multipart/form-data. More information on Sending Files »
	Document InputFile `json:"document"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Document caption (may also be used when resending documents by file_id), 0-1024 characters
	// after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableContentTypeDetection
	// Disables automatic server-side content type detection for files uploaded using
	// multipart/form-data
	DisableContentTypeDetection bool `json:"disable_content_type_detection,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *InputFile `json:"thumbnail,omitempty"`
}

func (t SendDocumentConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_content_type_detection", strconv.FormatBool(t.DisableContentTypeDetection))
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendDocument
// Use this method to send general files. On success, the sent Message is returned. Bots can
// currently send files of any type of up to 50 MB in size, this limit may be changed in the
// future.}}
func (api *API) SendDocument(
	ctx context.Context,
	args *SendDocumentConfig,
) (*Message, error) {
	if args.Document.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendDocument", "document", &args.Document)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendDocument", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendGame
// Use this method to send a game. On success, the sent Message is returned.
type SendGameConfig struct {
	// ChatID
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`
	// GameShortName
	// Short name of the game, serves as the unique identifier for the game. Set up your games via
	// @BotFather.
	GameShortName string `json:"game_short_name"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will
	// be shown. If not empty, the first button must launch the game.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendGame
// Use this method to send a game. On success, the sent Message is returned.
func (api *API) SendGame(
	ctx context.Context,
	args *SendGameConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendGame", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendInvoice
// Use this method to send invoices. On success, the sent Message is returned.
type SendInvoiceConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payment provider token, obtained via @BotFather
	ProviderToken string `json:"provider_token"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// IsFlexible
	// Pass True if the final price depends on the shipping method
	IsFlexible bool `json:"is_flexible,omitempty"`
	// MaxTipAmount
	// The maximum accepted amount for tips in the smallest units of the currency (integer, not
	// float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the
	// exp parameter in currencies.json, it shows the number of digits past the decimal point for
	// each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount int64 `json:"max_tip_amount,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// NeedEmail
	// Pass True if you require the user's email address to complete the order
	NeedEmail bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True if you require the user's full name to complete the order
	NeedName bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True if you require the user's phone number to complete the order
	NeedPhoneNumber bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True if you require the user's shipping address to complete the order
	NeedShippingAddress bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size in bytes
	PhotoSize int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service. People like it better when they see what they are paying for.
	PhotoURL string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth int64 `json:"photo_width,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ProviderData
	// JSON-serialized data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData string `json:"provider_data,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will
	// be shown. If not empty, the first button must be a Pay button.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// SendEmailToProvider
	// Pass True if the user's email address should be sent to provider
	SendEmailToProvider bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True if the user's phone number should be sent to provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider,omitempty"`
	// StartParameter
	// Unique deep-linking parameter. If left empty, forwarded copies of the sent message will have
	// a Pay button, allowing multiple users to pay directly from the forwarded message, using the
	// same invoice. If non-empty, forwarded copies of the sent message will have a URL button with
	// a deep link to the bot (instead of a Pay button), with the value used as the start parameter
	StartParameter string `json:"start_parameter,omitempty"`
	// SuggestedTipAmounts
	// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency
	// (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested
	// tip amounts must be positive, passed in a strictly increased order and must not exceed
	// max_tip_amount.
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts,omitempty"`
}

// SendInvoice
// Use this method to send invoices. On success, the sent Message is returned.
func (api *API) SendInvoice(
	ctx context.Context,
	args *SendInvoiceConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendInvoice", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendLocation
// Use this method to send point on the map. On success, the sent Message is returned.
type SendLocationConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Latitude
	// Latitude of the location
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the location
	Longitude float64 `json:"longitude"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Heading
	// For live locations, a direction in which the user is moving, in degrees. Must be between 1
	// and 360 if specified.
	Heading int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// LivePeriod
	// Period in seconds for which the location will be updated (see Live Locations, should be
	// between 60 and 86400.
	LivePeriod int64 `json:"live_period,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ProximityAlertRadius
	// For live locations, a maximum distance for proximity alerts about approaching another chat
	// member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius int64 `json:"proximity_alert_radius,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendLocation
// Use this method to send point on the map. On success, the sent Message is returned.
func (api *API) SendLocation(
	ctx context.Context,
	args *SendLocationConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendLocation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendMediaGroup
// Use this method to send a group of photos, videos, documents or audios as an album. Documents
// and audio files can be only grouped in an album with messages of the same type. On success, an
// array of Messages that were sent is returned.
type SendMediaGroupConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Media
	// A JSON-serialized array describing messages to be sent, must include 2-10 items
	Media []InputMediaGraphics `json:"media"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends messages silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent messages from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyToMessageID
	// If the messages are a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendMediaGroup
// Use this method to send a group of photos, videos, documents or audios as an album. Documents
// and audio files can be only grouped in an album with messages of the same type. On success, an
// array of Messages that were sent is returned.
func (api *API) SendMediaGroup(
	ctx context.Context,
	args *SendMediaGroupConfig,
) ([]Message, error) {
	resp, err := api.MakeRequest(ctx, "sendMediaGroup", args)
	if err != nil {
		return nil, err
	}
	var data []Message
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// SendMessage
// Use this method to send text messages. On success, the sent Message is returned.
type SendMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Text
	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`
	// Entities
	// A JSON-serialized list of special entities that appear in message text, which can be
	// specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendMessage
// Use this method to send text messages. On success, the sent Message is returned.
func (api *API) SendMessage(
	ctx context.Context,
	args *SendMessageConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendMessage", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendPhoto
// Use this method to send photos. On success, the sent Message is returned.
type SendPhotoConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Photo
	// Photo to send. Pass a file_id as String to send a photo that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet,
	// or upload a new photo using multipart/form-data. The photo must be at most 10 MB in size.
	// The photo's width and height must not exceed 10000 in total. Width and height ratio must be
	// at most 20. More information on Sending Files »
	Photo InputFile `json:"photo"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Photo caption (may also be used when resending photos by file_id), 0-1024 characters after
	// entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// HasSpoiler
	// Pass True if the photo needs to be covered with a spoiler animation
	HasSpoiler bool `json:"has_spoiler,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

func (t SendPhotoConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("has_spoiler", strconv.FormatBool(t.HasSpoiler))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendPhoto
// Use this method to send photos. On success, the sent Message is returned.}}
func (api *API) SendPhoto(
	ctx context.Context,
	args *SendPhotoConfig,
) (*Message, error) {
	if args.Photo.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendPhoto", "photo", &args.Photo)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendPhoto", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendPoll
// Use this method to send a native poll. On success, the sent Message is returned.
type SendPollConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Options
	// A JSON-serialized list of answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`
	// Question
	// Poll question, 1-300 characters
	Question string `json:"question"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// AllowsMultipleAnswers
	// True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False
	AllowsMultipleAnswers bool `json:"allows_multiple_answers,omitempty"`
	// CloseDate
	// Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least
	// 5 and no more than 600 seconds in the future. Can't be used together with open_period.
	CloseDate int64 `json:"close_date,omitempty"`
	// CorrectOptionID
	// 0-based identifier of the correct answer option, required for polls in quiz mode
	CorrectOptionID int64 `json:"correct_option_id,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Explanation
	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a
	// quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
	Explanation string `json:"explanation,omitempty"`
	// ExplanationEntities
	// A JSON-serialized list of special entities that appear in the poll explanation, which can be
	// specified instead of parse_mode
	ExplanationEntities []MessageEntity `json:"explanation_entities,omitempty"`
	// ExplanationParseMode
	// Mode for parsing entities in the explanation. See formatting options for more details.
	ExplanationParseMode string `json:"explanation_parse_mode,omitempty"`
	// IsAnonymous
	// True, if the poll needs to be anonymous, defaults to True
	IsAnonymous bool `json:"is_anonymous,omitempty"`
	// IsClosed
	// Pass True if the poll needs to be immediately closed. This can be useful for poll preview.
	IsClosed bool `json:"is_closed,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// OpenPeriod
	// Amount of time in seconds the poll will be active after creation, 5-600. Can't be used
	// together with close_date.
	OpenPeriod int64 `json:"open_period,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Type
	// Poll type, "quiz" or "regular", defaults to "regular"
	Type *SendType `json:"type,omitempty"`
}

// SendPoll
// Use this method to send a native poll. On success, the sent Message is returned.
func (api *API) SendPoll(
	ctx context.Context,
	args *SendPollConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendPoll", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendSticker
// Use this method to send static .WEBP, animated .TGS, or video .WEBM stickers. On success, the
// sent Message is returned.
type SendStickerConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Sticker
	// Sticker to send. Pass a file_id as String to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a .WEBP sticker from the
	// Internet, or upload a new .WEBP or .TGS sticker using multipart/form-data. More information
	// on Sending Files ». Video stickers can only be sent by a file_id. Animated stickers can't
	// be sent via an HTTP URL.
	Sticker InputFile `json:"sticker"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Emoji
	// Emoji associated with the sticker; only for just uploaded stickers
	Emoji string `json:"emoji,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

func (t SendStickerConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("emoji", t.Emoji)
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendSticker
// Use this method to send static .WEBP, animated .TGS, or video .WEBM stickers. On success, the
// sent Message is returned.}}
func (api *API) SendSticker(
	ctx context.Context,
	args *SendStickerConfig,
) (*Message, error) {
	if args.Sticker.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendSticker", "sticker", &args.Sticker)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendSticker", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVenue
// Use this method to send information about a venue. On success, the sent Message is returned.
type SendVenueConfig struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Latitude
	// Latitude of the venue
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue
	Longitude float64 `json:"longitude"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// FoursquareID
	// Foursquare identifier of the venue
	FoursquareID string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType string `json:"foursquare_type,omitempty"`
	// GooglePlaceID
	// Google Places identifier of the venue
	GooglePlaceID string `json:"google_place_id,omitempty"`
	// GooglePlaceType
	// Google Places type of the venue. (See supported types.)
	GooglePlaceType string `json:"google_place_type,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendVenue
// Use this method to send information about a venue. On success, the sent Message is returned.
func (api *API) SendVenue(
	ctx context.Context,
	args *SendVenueConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendVenue", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVideo
// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be
// sent as Document). On success, the sent Message is returned. Bots can currently send video files
// of up to 50 MB in size, this limit may be changed in the future.
type SendVideoConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Video
	// Video to send. Pass a file_id as String to send a video that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet,
	// or upload a new video using multipart/form-data. More information on Sending Files »
	Video InputFile `json:"video"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Video caption (may also be used when resending videos by file_id), 0-1024 characters after
	// entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`
	// HasSpoiler
	// Pass True if the video needs to be covered with a spoiler animation
	HasSpoiler bool `json:"has_spoiler,omitempty"`
	// Height
	// Video height
	Height int64 `json:"height,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// SupportsStreaming
	// Pass True if the uploaded video is suitable for streaming
	SupportsStreaming bool `json:"supports_streaming,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *InputFile `json:"thumbnail,omitempty"`
	// Width
	// Video width
	Width int64 `json:"width,omitempty"`
}

func (t SendVideoConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("has_spoiler", strconv.FormatBool(t.HasSpoiler))
	res.Add("height", strconv.FormatInt(t.Height, 10))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	res.Add("supports_streaming", strconv.FormatBool(t.SupportsStreaming))
	res.Add("width", strconv.FormatInt(t.Width, 10))
	return res, nil
}

// SendVideo
// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be
// sent as Document). On success, the sent Message is returned. Bots can currently send video files
// of up to 50 MB in size, this limit may be changed in the future.}}
func (api *API) SendVideo(
	ctx context.Context,
	args *SendVideoConfig,
) (*Message, error) {
	if args.Video.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendVideo", "video", &args.Video)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendVideo", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVideoNote
// As of v.4.0, Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use
// this method to send video messages. On success, the sent Message is returned.
type SendVideoNoteConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// VideoNote
	// Video note to send. Pass a file_id as String to send a video note that exists on the
	// Telegram servers (recommended) or upload a new video using multipart/form-data. More
	// information on Sending Files ». Sending video notes by a URL is currently unsupported
	VideoNote InputFile `json:"video_note"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`
	// Length
	// Video width and height, i.e. diameter of the video message
	Length int64 `json:"length,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *InputFile `json:"thumbnail,omitempty"`
}

func (t SendVideoNoteConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("length", strconv.FormatInt(t.Length, 10))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendVideoNote
// As of v.4.0, Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use
// this method to send video messages. On success, the sent Message is returned.}}
func (api *API) SendVideoNote(
	ctx context.Context,
	args *SendVideoNoteConfig,
) (*Message, error) {
	if args.VideoNote.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendVideoNote", "videonote", &args.VideoNote)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendVideoNote", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVoice
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots
// can currently send voice messages of up to 50 MB in size, this limit may be changed in the
// future.
type SendVoiceConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Voice
	// Audio file to send. Pass a file_id as String to send a file that exists on the Telegram
	// servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the
	// Internet, or upload a new one using multipart/form-data. More information on Sending Files
	// »
	Voice InputFile `json:"voice"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Voice message caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// A JSON-serialized list of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of the voice message in seconds
	Duration int64 `json:"duration,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

func (t SendVoiceConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("message_thread_id", strconv.FormatInt(t.MessageThreadID, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("protect_content", strconv.FormatBool(t.ProtectContent))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendVoice
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots
// can currently send voice messages of up to 50 MB in size, this limit may be changed in the
// future.}}
func (api *API) SendVoice(
	ctx context.Context,
	args *SendVoiceConfig,
) (*Message, error) {
	if args.Voice.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendVoice", "voice", &args.Voice)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendVoice", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatAdministratorCustomTitle
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
type SetChatAdministratorCustomTitleConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// CustomTitle
	// New custom title for the administrator; 0-16 characters, emoji are not allowed
	CustomTitle string `json:"custom_title"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// SetChatAdministratorCustomTitle
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
func (api *API) SetChatAdministratorCustomTitle(
	ctx context.Context,
	args *SetChatAdministratorCustomTitleConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "setChatAdministratorCustomTitle", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatDescription
// Use this method to change the description of a group, a supergroup or a channel. The bot must be
// an administrator in the chat for this to work and must have the appropriate administrator
// rights. Returns True on success.
func (api *API) SetChatDescription(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// not required.
	// New chat description, 0-255 characters
	description *string,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":     chatID,
		"description": description,
	}
	resp, err := api.MakeRequest(ctx, "setChatDescription", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatMenuButton
// Use this method to change the bot's menu button in a private chat, or the default menu button.
// Returns True on success.
func (api *API) SetChatMenuButton(
	ctx context.Context,
	// not required.
	// Unique identifier for the target private chat. If not specified, default bot's menu
	// button will be changed
	chatID *int64,
	// not required.
	// A JSON-serialized object for the bot's new menu button. Defaults to MenuButtonDefault
	menuButton *MenuButton,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":     chatID,
		"menu_button": menuButton,
	}
	resp, err := api.MakeRequest(ctx, "setChatMenuButton", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatPermissions
// Use this method to set default chat permissions for all members. The bot must be an
// administrator in the group or a supergroup for this to work and must have the
// can_restrict_members administrator rights. Returns True on success.
type SetChatPermissionsConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Permissions
	// A JSON-serialized object for new default chat permissions
	Permissions ChatPermissions `json:"permissions"`
	// UseIndependentChatPermissions
	// Pass True if chat permissions are set independently. Otherwise, the can_send_other_messages
	// and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios,
	// can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and
	// can_send_voice_notes permissions; the can_send_polls permission will imply the
	// can_send_messages permission.
	UseIndependentChatPermissions bool `json:"use_independent_chat_permissions,omitempty"`
}

// SetChatPermissions
// Use this method to set default chat permissions for all members. The bot must be an
// administrator in the group or a supergroup for this to work and must have the
// can_restrict_members administrator rights. Returns True on success.
func (api *API) SetChatPermissions(
	ctx context.Context,
	args *SetChatPermissionsConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "setChatPermissions", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatPhoto
// Use this method to set a new profile photo for the chat. Photos can't be changed for private
// chats. The bot must be an administrator in the chat for this to work and must have the
// appropriate administrator rights. Returns True on success.}}
func (api *API) SetChatPhoto(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// New chat photo, uploaded using multipart/form-data
	photo InputFile,
) (*bool, error) {
	if photo.Reader != nil {
		values := url.Values{
			"chat_id": []string{chatID.String()},
		}
		resp, err := api.UploadFile(ctx, values, "setChatPhoto", "setchatphoto", &photo)
		if err != nil {
			return nil, err
		}

		var res bool
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	args := map[string]interface{}{
		"chat_id": chatID,
		"photo":   photo,
	}
	resp, err := api.MakeRequest(ctx, "setChatPhoto", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatStickerSet
// Use this method to set a new group sticker set for a supergroup. The bot must be an
// administrator in the chat for this to work and must have the appropriate administrator rights.
// Use the field can_set_sticker_set optionally returned in getChat requests to check if the bot
// can use this method. Returns True on success.
func (api *API) SetChatStickerSet(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// Name of the sticker set to be set as the group sticker set
	stickerSetName string,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":          chatID,
		"sticker_set_name": stickerSetName,
	}
	resp, err := api.MakeRequest(ctx, "setChatStickerSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatTitle
// Use this method to change the title of a chat. Titles can't be changed for private chats. The
// bot must be an administrator in the chat for this to work and must have the appropriate
// administrator rights. Returns True on success.
func (api *API) SetChatTitle(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// New chat title, 1-128 characters
	title string,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
		"title":   title,
	}
	resp, err := api.MakeRequest(ctx, "setChatTitle", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetCustomEmojiStickerSetThumbnail
// Use this method to set the thumbnail of a custom emoji sticker set. Returns True on success.
func (api *API) SetCustomEmojiStickerSetThumbnail(
	ctx context.Context,
	// not required.
	// Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop
	// the thumbnail and use the first sticker as the thumbnail.
	customEmojiID *string,
	// required.
	// Sticker set name
	name string,
) (*bool, error) {
	args := map[string]interface{}{
		"custom_emoji_id": customEmojiID,
		"name":            name,
	}
	resp, err := api.MakeRequest(ctx, "setCustomEmojiStickerSetThumbnail", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetGameScore
// Use this method to set the score of the specified user in a game message. On success, if the
// message is not an inline message, the Message is returned, otherwise True is returned. Returns
// an error, if the new score is not greater than the user's current score in the chat and force is
// False.
type SetGameScoreConfig struct {
	// Score
	// New score, must be non-negative
	Score int64 `json:"score"`
	// UserID
	// User identifier
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`
	// DisableEditMessage
	// Pass True if the game message should not be automatically edited to include the current
	// scoreboard
	DisableEditMessage bool `json:"disable_edit_message,omitempty"`
	// Force
	// Pass True if the high score is allowed to decrease. This can be useful when fixing mistakes
	// or banning cheaters
	Force bool `json:"force,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`
}

// SetGameScore
// Use this method to set the score of the specified user in a game message. On success, if the
// message is not an inline message, the Message is returned, otherwise True is returned. Returns
// an error, if the new score is not greater than the user's current score in the chat and force is
// False.
func (api *API) SetGameScore(
	ctx context.Context,
	args *SetGameScoreConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "setGameScore", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetMyCommands
// Use this method to change the list of the bot's commands. See this manual for more details about
// bot commands. Returns True on success.
type SetMyCommandsConfig struct {
	// Commands
	// A JSON-serialized list of bot commands to be set as the list of the bot's commands. At most
	// 100 commands can be specified.
	Commands []BotCommand `json:"commands"`
	// LanguageCode
	// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from
	// the given scope, for whose language there are no dedicated commands
	LanguageCode string `json:"language_code,omitempty"`
	// Scope
	// A JSON-serialized object, describing scope of users for which the commands are relevant.
	// Defaults to BotCommandScopeDefault.
	Scope *BotCommandScope `json:"scope,omitempty"`
}

// SetMyCommands
// Use this method to change the list of the bot's commands. See this manual for more details about
// bot commands. Returns True on success.
func (api *API) SetMyCommands(
	ctx context.Context,
	args *SetMyCommandsConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "setMyCommands", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetMyDefaultAdministratorRights
// Use this method to change the default administrator rights requested by the bot when it's added
// as an administrator to groups or channels. These rights will be suggested to users, but they are
// free to modify the list before adding the bot. Returns True on success.
func (api *API) SetMyDefaultAdministratorRights(
	ctx context.Context,
	// not required.
	// Pass True to change the default administrator rights of the bot in channels. Otherwise,
	// the default administrator rights of the bot for groups and supergroups will be changed.
	forChannels *bool,
	// not required.
	// A JSON-serialized object describing new default administrator rights. If not specified,
	// the default administrator rights will be cleared.
	rights *ChatAdministratorRights,
) (*bool, error) {
	args := map[string]interface{}{
		"for_channels": forChannels,
		"rights":       rights,
	}
	resp, err := api.MakeRequest(ctx, "setMyDefaultAdministratorRights", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetMyDescription
// Use this method to change the bot's description, which is shown in the chat with the bot if the
// chat is empty. Returns True on success.
func (api *API) SetMyDescription(
	ctx context.Context,
	// not required.
	// New bot description; 0-512 characters. Pass an empty string to remove the dedicated
	// description for the given language.
	description *string,
	// not required.
	// A two-letter ISO 639-1 language code. If empty, the description will be applied to all
	// users for whose language there is no dedicated description.
	languageCode *string,
) (*bool, error) {
	args := map[string]interface{}{
		"description":   description,
		"language_code": languageCode,
	}
	resp, err := api.MakeRequest(ctx, "setMyDescription", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetMyName
// Use this method to change the bot's name. Returns True on success.
func (api *API) SetMyName(
	ctx context.Context,
	// not required.
	// A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for
	// whose language there is no dedicated name.
	languageCode *string,
	// not required.
	// New bot name; 0-64 characters. Pass an empty string to remove the dedicated name for the
	// given language.
	name *string,
) (*bool, error) {
	args := map[string]interface{}{
		"language_code": languageCode,
		"name":          name,
	}
	resp, err := api.MakeRequest(ctx, "setMyName", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetMyShortDescription
// Use this method to change the bot's short description, which is shown on the bot's profile page
// and is sent together with the link when users share the bot. Returns True on success.
func (api *API) SetMyShortDescription(
	ctx context.Context,
	// not required.
	// A two-letter ISO 639-1 language code. If empty, the short description will be applied to
	// all users for whose language there is no dedicated short description.
	languageCode *string,
	// not required.
	// New short description for the bot; 0-120 characters. Pass an empty string to remove the
	// dedicated short description for the given language.
	shortDescription *string,
) (*bool, error) {
	args := map[string]interface{}{
		"language_code":     languageCode,
		"short_description": shortDescription,
	}
	resp, err := api.MakeRequest(ctx, "setMyShortDescription", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetPassportDataErrors
// Informs a user that some of the Telegram Passport elements they provided contains errors. The
// user will not be able to re-submit their Passport to you until the errors are fixed (the
// contents of the field for which you returned the error must change). Returns True on success.
func (api *API) SetPassportDataErrors(
	ctx context.Context,
	// required.
	// A JSON-serialized array describing the errors
	errors []PassportElementError,
	// required.
	// User identifier
	userID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"errors":  errors,
		"user_id": userID,
	}
	resp, err := api.MakeRequest(ctx, "setPassportDataErrors", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetStickerEmojiList
// Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The
// sticker must belong to a sticker set created by the bot. Returns True on success.
func (api *API) SetStickerEmojiList(
	ctx context.Context,
	// required.
	// A JSON-serialized list of 1-20 emoji associated with the sticker
	emojiList []string,
	// required.
	// File identifier of the sticker
	sticker string,
) (*bool, error) {
	args := map[string]interface{}{
		"emoji_list": emojiList,
		"sticker":    sticker,
	}
	resp, err := api.MakeRequest(ctx, "setStickerEmojiList", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetStickerKeywords
// Use this method to change search keywords assigned to a regular or custom emoji sticker. The
// sticker must belong to a sticker set created by the bot. Returns True on success.
func (api *API) SetStickerKeywords(
	ctx context.Context,
	// not required.
	// A JSON-serialized list of 0-20 search keywords for the sticker with total length of up
	// to 64 characters
	keywords []string,
	// required.
	// File identifier of the sticker
	sticker string,
) (*bool, error) {
	args := map[string]interface{}{
		"keywords": keywords,
		"sticker":  sticker,
	}
	resp, err := api.MakeRequest(ctx, "setStickerKeywords", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetStickerMaskPosition
// Use this method to change the mask position of a mask sticker. The sticker must belong to a
// sticker set that was created by the bot. Returns True on success.
func (api *API) SetStickerMaskPosition(
	ctx context.Context,
	// not required.
	// A JSON-serialized object with the position where the mask should be placed on faces.
	// Omit the parameter to remove the mask position.
	maskPosition *MaskPosition,
	// required.
	// File identifier of the sticker
	sticker string,
) (*bool, error) {
	args := map[string]interface{}{
		"mask_position": maskPosition,
		"sticker":       sticker,
	}
	resp, err := api.MakeRequest(ctx, "setStickerMaskPosition", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetStickerPositionInSet
// Use this method to move a sticker in a set created by the bot to a specific position. Returns
// True on success.
func (api *API) SetStickerPositionInSet(
	ctx context.Context,
	// required.
	// New sticker position in the set, zero-based
	position int64,
	// required.
	// File identifier of the sticker
	sticker string,
) (*bool, error) {
	args := map[string]interface{}{
		"position": position,
		"sticker":  sticker,
	}
	resp, err := api.MakeRequest(ctx, "setStickerPositionInSet", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetStickerSetThumbnail
// Use this method to set the thumbnail of a regular or mask sticker set. The format of the
// thumbnail file must match the format of the stickers in the set. Returns True on success.
type SetStickerSetThumbnailConfig struct {
	// Name
	// Sticker set name
	Name string `json:"name"`
	// UserID
	// User identifier of the sticker set owner
	UserID int64 `json:"user_id"`
	// Thumbnail
	// A .WEBP or .PNG image with the thumbnail, must be up to 128 kilobytes in size and have a
	// width and height of exactly 100px, or a .TGS animation with a thumbnail up to 32 kilobytes
	// in size (see https://core.telegram.org/stickers#animated-sticker-requirements for animated
	// sticker technical requirements), or a WEBM video with the thumbnail up to 32 kilobytes in
	// size; see https://core.telegram.org/stickers#video-sticker-requirements for video sticker
	// technical requirements. Pass a file_id as a String to send a file that already exists on the
	// Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet,
	// or upload a new one using multipart/form-data. More information on Sending Files ».
	// Animated and video sticker set thumbnails can't be uploaded via HTTP URL. If omitted, then
	// the thumbnail is dropped and the first sticker is used as the thumbnail.
	Thumbnail *InputFile `json:"thumbnail,omitempty"`
}

// SetStickerSetThumbnail
// Use this method to set the thumbnail of a regular or mask sticker set. The format of the
// thumbnail file must match the format of the stickers in the set. Returns True on success.
func (api *API) SetStickerSetThumbnail(
	ctx context.Context,
	args *SetStickerSetThumbnailConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "setStickerSetThumbnail", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetStickerSetTitle
// Use this method to set the title of a created sticker set. Returns True on success.
func (api *API) SetStickerSetTitle(
	ctx context.Context,
	// required.
	// Sticker set name
	name string,
	// required.
	// Sticker set title, 1-64 characters
	title string,
) (*bool, error) {
	args := map[string]interface{}{
		"name":  name,
		"title": title,
	}
	resp, err := api.MakeRequest(ctx, "setStickerSetTitle", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetWebhook
// Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever
// there is an update for the bot, we will send an HTTPS POST request to the specified URL,
// containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a
// reasonable amount of attempts. Returns True on success.
type SetWebhookConfig struct {
	// URL
	// HTTPS URL to send updates to. Use an empty string to remove webhook integration
	URL string `json:"url"`
	// AllowedUpdates
	// A JSON-serialized list of the update types you want your bot to receive. For example,
	// specify ["message", "edited_channel_post", "callback_query"] to only receive updates of
	// these types. See Update for a complete list of available update types. Specify an empty list
	// to receive all update types except chat_member (default). If not specified, the previous
	// setting will be used.Please note that this parameter doesn't affect updates created before
	// the call to the setWebhook, so unwanted updates may be received for a short period of time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// Certificate
	// Upload your public key certificate so that the root certificate in use can be checked. See
	// our self-signed guide for details.
	Certificate *InputFile `json:"certificate,omitempty"`
	// DropPendingUpdates
	// Pass True to drop all pending updates
	DropPendingUpdates bool `json:"drop_pending_updates,omitempty"`
	// IPAddress
	// The fixed IP address which will be used to send webhook requests instead of the IP address
	// resolved through DNS
	IPAddress string `json:"ip_address,omitempty"`
	// MaxConnections
	// The maximum allowed number of simultaneous HTTPS connections to the webhook for update
	// delivery, 1-100. Defaults to 40. Use lower values to limit the load on your bot's server,
	// and higher values to increase your bot's throughput.
	MaxConnections int64 `json:"max_connections,omitempty"`
	// SecretToken
	// A secret token to be sent in a header "X-Telegram-Bot-Api-Secret-Token" in every webhook
	// request, 1-256 characters. Only characters A-Z, a-z, 0-9, _ and - are allowed. The header is
	// useful to ensure that the request comes from a webhook set by you.
	SecretToken string `json:"secret_token,omitempty"`
}

// SetWebhook
// Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever
// there is an update for the bot, we will send an HTTPS POST request to the specified URL,
// containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a
// reasonable amount of attempts. Returns True on success.
func (api *API) SetWebhook(
	ctx context.Context,
	args *SetWebhookConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "setWebhook", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// StopMessageLiveLocation
// Use this method to stop updating a live location message before live_period expires. On success,
// if the message is not an inline message, the edited Message is returned, otherwise True is
// returned.
type StopMessageLiveLocationConfig struct {
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message with live location
	// to stop
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopMessageLiveLocation
// Use this method to stop updating a live location message before live_period expires. On success,
// if the message is not an inline message, the edited Message is returned, otherwise True is
// returned.
func (api *API) StopMessageLiveLocation(
	ctx context.Context,
	args *StopMessageLiveLocationConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "stopMessageLiveLocation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// StopPoll
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll is
// returned.
type StopPollConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageID
	// Identifier of the original message with the poll
	MessageID int64 `json:"message_id"`
	// ReplyMarkup
	// A JSON-serialized object for a new message inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopPoll
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll is
// returned.
func (api *API) StopPoll(
	ctx context.Context,
	args *StopPollConfig,
) (*Poll, error) {
	resp, err := api.MakeRequest(ctx, "stopPoll", args)
	if err != nil {
		return nil, err
	}
	var data Poll
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnbanChatMember
// Use this method to unban a previously banned user in a supergroup or channel. The user will not
// return to the group or channel automatically, but will be able to join via link, etc. The bot
// must be an administrator for this to work. By default, this method guarantees that after the
// call the user is not a member of the chat, but will be able to join it. So if the user is a
// member of the chat they will also be removed from the chat. If you don't want this, use the
// parameter only_if_banned. Returns True on success.
type UnbanChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target group or username of the target supergroup or channel (in
	// the format @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// OnlyIfBanned
	// Do nothing if the user is not banned
	OnlyIfBanned bool `json:"only_if_banned,omitempty"`
}

// UnbanChatMember
// Use this method to unban a previously banned user in a supergroup or channel. The user will not
// return to the group or channel automatically, but will be able to join via link, etc. The bot
// must be an administrator for this to work. By default, this method guarantees that after the
// call the user is not a member of the chat, but will be able to join it. So if the user is a
// member of the chat they will also be removed from the chat. If you don't want this, use the
// parameter only_if_banned. Returns True on success.
func (api *API) UnbanChatMember(
	ctx context.Context,
	args *UnbanChatMemberConfig,
) (*bool, error) {
	resp, err := api.MakeRequest(ctx, "unbanChatMember", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnbanChatSenderChat
// Use this method to unban a previously banned channel chat in a supergroup or channel. The bot
// must be an administrator for this to work and must have the appropriate administrator rights.
// Returns True on success.
func (api *API) UnbanChatSenderChat(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// Unique identifier of the target sender chat
	senderChatID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":        chatID,
		"sender_chat_id": senderChatID,
	}
	resp, err := api.MakeRequest(ctx, "unbanChatSenderChat", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnhideGeneralForumTopic
// Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an
// administrator in the chat for this to work and must have the can_manage_topics administrator
// rights. Returns True on success.
func (api *API) UnhideGeneralForumTopic(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "unhideGeneralForumTopic", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnpinAllChatMessages
// Use this method to clear the list of pinned messages in a chat. If the chat is not a private
// chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator
// right in a channel. Returns True on success.
func (api *API) UnpinAllChatMessages(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "unpinAllChatMessages", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnpinAllForumTopicMessages
// Use this method to clear the list of pinned messages in a forum topic. The bot must be an
// administrator in the chat for this to work and must have the can_pin_messages administrator
// right in the supergroup. Returns True on success.
func (api *API) UnpinAllForumTopicMessages(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// Unique identifier for the target message thread of the forum topic
	messageThreadID int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":           chatID,
		"message_thread_id": messageThreadID,
	}
	resp, err := api.MakeRequest(ctx, "unpinAllForumTopicMessages", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnpinChatMessage
// Use this method to remove a message from the list of pinned messages in a chat. If the chat is
// not a private chat, the bot must be an administrator in the chat for this to work and must have
// the 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator
// right in a channel. Returns True on success.
func (api *API) UnpinChatMessage(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// not required.
	// Identifier of a message to unpin. If not specified, the most recent pinned message (by
	// sending date) will be unpinned.
	messageID *int64,
) (*bool, error) {
	args := map[string]interface{}{
		"chat_id":    chatID,
		"message_id": messageID,
	}
	resp, err := api.MakeRequest(ctx, "unpinChatMessage", args)
	if err != nil {
		return nil, err
	}
	var data bool
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UploadStickerFile
// Use this method to upload a file with a sticker for later use in the createNewStickerSet and
// addStickerToSet methods (the file can be used multiple times). Returns the uploaded File on
// success.
type UploadStickerFileConfig struct {
	// Sticker
	// A file with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. See
	// https://core.telegram.org/stickers for technical requirements. More information on Sending
	// Files »
	Sticker InputFile `json:"sticker"`
	// StickerFormat
	// Format of the sticker, must be one of "static", "animated", "video"
	StickerFormat string `json:"sticker_format"`
	// UserID
	// User identifier of sticker file owner
	UserID int64 `json:"user_id"`
}
