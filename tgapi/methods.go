// Generated by: github.com/Feresey/gen-tgbotapi

package tgapi

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
)

// AddStickerToSet
// Use this method to add a new sticker to a set created by the bot. You must use exactly one of
// the fields png_sticker or tgs_sticker. Animated stickers can be added to animated sticker sets
// and only to them. Animated sticker sets can have up to 50 stickers. Static sticker sets can have
// up to 120 stickers. Returns True on success.
type AddStickerToSetConfig struct {
	// Emojis
	// One or more emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// Name
	// Sticker set name
	Name string `json:"name"`
	// UserID
	// User identifier of sticker set owner
	UserID int64 `json:"user_id"`
	// MaskPosition
	// A JSON-serialized object for position where the mask should be placed on faces
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// PngSticker
	// PNG image with the sticker, must be up to 512 kilobytes in size, dimensions must not exceed
	// 512px, and either width or height must be exactly 512px. Pass a file_id as a String to send
	// a file that already exists on the Telegram servers, pass an HTTP URL as a String for
	// Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	PngSticker *InputFile `json:"png_sticker,omitempty"`
	// TgsSticker
	// TGS animation with the sticker, uploaded using multipart/form-data. See
	// https://core.telegram.org/animated_stickers#technical-requirements for technical
	// requirements
	TgsSticker *InputFile `json:"tgs_sticker,omitempty"`
}

// AddStickerToSet
// Use this method to add a new sticker to a set created by the bot. You must use exactly one of
// the fields png_sticker or tgs_sticker. Animated stickers can be added to animated sticker sets
// and only to them. Animated sticker sets can have up to 50 stickers. Static sticker sets can have
// up to 120 stickers. Returns True on success.
func (api *API) AddStickerToSet(
	ctx context.Context,
	args *AddStickerToSetConfig,
) error {
	_, err := api.MakeRequest(ctx, "addStickerToSet", args)
	return err
}

// AnswerCallbackQuery
// Use this method to send answers to callback queries sent from inline keyboards. The answer will
// be displayed to the user as a notification at the top of the chat screen or as an alert. On
// success, True is returned.
type AnswerCallbackQueryConfig struct {
	// CallbackQueryID
	// Unique identifier for the query to be answered
	CallbackQueryID string `json:"callback_query_id"`
	// CacheTime
	// The maximum amount of time in seconds that the result of the callback query may be cached
	// client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.
	CacheTime int64 `json:"cache_time,omitempty"`
	// ShowAlert
	// If true, an alert will be shown by the client instead of a notification at the top of the
	// chat screen. Defaults to false.
	ShowAlert bool `json:"show_alert,omitempty"`
	// Text
	// Text of the notification. If not specified, nothing will be shown to the user, 0-200
	// characters
	Text string `json:"text,omitempty"`
	// URL
	// URL that will be opened by the user's client. If you have created a Game and accepted the
	// conditions via @Botfather, specify the URL that opens your game - note that this will only
	// work if the query comes from a callback_game button.Otherwise, you may use links like
	// t.me/your_bot?start=XXXX that open your bot with a parameter.
	URL string `json:"url,omitempty"`
}

// AnswerCallbackQuery
// Use this method to send answers to callback queries sent from inline keyboards. The answer will
// be displayed to the user as a notification at the top of the chat screen or as an alert. On
// success, True is returned.
func (api *API) AnswerCallbackQuery(
	ctx context.Context,
	args *AnswerCallbackQueryConfig,
) error {
	_, err := api.MakeRequest(ctx, "answerCallbackQuery", args)
	return err
}

// AnswerInlineQuery
// Use this method to send answers to an inline query. On success, True is returned.No more than 50
// results per query are allowed.
type AnswerInlineQueryConfig struct {
	// InlineQueryID
	// Unique identifier for the answered query
	InlineQueryID string `json:"inline_query_id"`
	// Results
	// A JSON-serialized array of results for the inline query
	Results []InlineQueryResult `json:"results"`
	// CacheTime
	// The maximum amount of time in seconds that the result of the inline query may be cached on
	// the server. Defaults to 300.
	CacheTime int64 `json:"cache_time,omitempty"`
	// IsPersonal
	// Pass True, if results may be cached on the server side only for the user that sent the
	// query. By default, results may be returned to any user who sends the same query
	IsPersonal bool `json:"is_personal,omitempty"`
	// NextOffset
	// Pass the offset that a client should send in the next query with the same text to receive
	// more results. Pass an empty string if there are no more results or if you don't support
	// pagination. Offset length can't exceed 64 bytes.
	NextOffset string `json:"next_offset,omitempty"`
	// SwitchPmParameter
	// Deep-linking parameter for the /start message sent to the bot when user presses the switch
	// button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot
	// that sends YouTube videos can ask the user to connect the bot to their YouTube account to
	// adapt search results accordingly. To do this, it displays a 'Connect your YouTube account'
	// button above the results, or even before showing any. The user presses the button, switches
	// to a private chat with the bot and, in doing so, passes a start parameter that instructs the
	// bot to return an oauth link. Once done, the bot can offer a switch_inline button so that the
	// user can easily return to the chat where they wanted to use the bot's inline capabilities.
	SwitchPmParameter string `json:"switch_pm_parameter,omitempty"`
	// SwitchPmText
	// If passed, clients will display a button with specified text that switches the user to a
	// private chat with the bot and sends the bot a start message with the parameter
	// switch_pm_parameter
	SwitchPmText string `json:"switch_pm_text,omitempty"`
}

// AnswerInlineQuery
// Use this method to send answers to an inline query. On success, True is returned.No more than 50
// results per query are allowed.
func (api *API) AnswerInlineQuery(
	ctx context.Context,
	args *AnswerInlineQueryConfig,
) error {
	_, err := api.MakeRequest(ctx, "answerInlineQuery", args)
	return err
}

// AnswerPreCheckoutQuery
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an Update with the field pre_checkout_query. Use this method to
// respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must
// receive an answer within 10 seconds after the pre-checkout query was sent.
type AnswerPreCheckoutQueryConfig struct {
	// Ok
	// Specify True if everything is alright (goods are available, etc.) and the bot is ready to
	// proceed with the order. Use False if there are any problems.
	Ok bool `json:"ok"`
	// PreCheckoutQueryID
	// Unique identifier for the query to be answered
	PreCheckoutQueryID string `json:"pre_checkout_query_id"`
	// ErrorMessage
	// Required if ok is False. Error message in human readable form that explains the reason for
	// failure to proceed with the checkout (e.g. "Sorry, somebody just bought the last of our
	// amazing black T-shirts while you were busy filling out your payment details. Please choose a
	// different color or garment!"). Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
}

// AnswerPreCheckoutQuery
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an Update with the field pre_checkout_query. Use this method to
// respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must
// receive an answer within 10 seconds after the pre-checkout query was sent.
func (api *API) AnswerPreCheckoutQuery(
	ctx context.Context,
	args *AnswerPreCheckoutQueryConfig,
) error {
	_, err := api.MakeRequest(ctx, "answerPreCheckoutQuery", args)
	return err
}

// AnswerShippingQuery
// If you sent an invoice requesting a shipping address and the parameter is_flexible was
// specified, the Bot API will send an Update with a shipping_query field to the bot. Use this
// method to reply to shipping queries. On success, True is returned.
type AnswerShippingQueryConfig struct {
	// Ok
	// Specify True if delivery to the specified address is possible and False if there are any
	// problems (for example, if delivery to the specified address is not possible)
	Ok bool `json:"ok"`
	// ShippingQueryID
	// Unique identifier for the query to be answered
	ShippingQueryID string `json:"shipping_query_id"`
	// ErrorMessage
	// Required if ok is False. Error message in human readable form that explains why it is
	// impossible to complete the order (e.g. "Sorry, delivery to your desired address is
	// unavailable'). Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
	// ShippingOptions
	// Required if ok is True. A JSON-serialized array of available shipping options.
	ShippingOptions []ShippingOption `json:"shipping_options,omitempty"`
}

// AnswerShippingQuery
// If you sent an invoice requesting a shipping address and the parameter is_flexible was
// specified, the Bot API will send an Update with a shipping_query field to the bot. Use this
// method to reply to shipping queries. On success, True is returned.
func (api *API) AnswerShippingQuery(
	ctx context.Context,
	args *AnswerShippingQueryConfig,
) error {
	_, err := api.MakeRequest(ctx, "answerShippingQuery", args)
	return err
}

// Close
// Use this method to close the bot instance before moving it from one local server to another. You
// need to delete the webhook before calling this method to ensure that the bot isn't launched
// again after server restart. The method will return error 429 in the first 10 minutes after the
// bot is launched. Returns True on success. Requires no parameters.
func (api *API) Close(
	ctx context.Context,
) error {
	_, err := api.MakeRequest(ctx, "close", nil)
	return err
}

// CopyMessage
// Use this method to copy messages of any kind. The method is analogous to the method
// forwardMessages, but the copied message doesn't have a link to the original message. Returns the
// MessageId of the sent message on success.
type CopyMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FromChatID
	// Unique identifier for the chat where the original message was sent (or channel username in
	// the format @channelusername)
	FromChatID IntStr `json:"from_chat_id"`
	// MessageID
	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// New caption for media, 0-1024 characters after entities parsing. If not specified, the
	// original caption is kept
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the new caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ParseMode
	// Mode for parsing entities in the new caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// CopyMessage
// Use this method to copy messages of any kind. The method is analogous to the method
// forwardMessages, but the copied message doesn't have a link to the original message. Returns the
// MessageId of the sent message on success.
func (api *API) CopyMessage(
	ctx context.Context,
	args *CopyMessageConfig,
) (*MessageID, error) {
	resp, err := api.MakeRequest(ctx, "copyMessage", args)
	if err != nil {
		return nil, err
	}
	var data MessageID
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// CreateNewStickerSet
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. You must use exactly one of the fields png_sticker or tgs_sticker.
// Returns True on success.
type CreateNewStickerSetConfig struct {
	// Emojis
	// One or more emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// Name
	// Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals). Can contain
	// only english letters, digits and underscores. Must begin with a letter, can't contain
	// consecutive underscores and must end in "_by_<bot username>". <bot_username> is case
	// insensitive. 1-64 characters.
	Name string `json:"name"`
	// Title
	// Sticker set title, 1-64 characters
	Title string `json:"title"`
	// UserID
	// User identifier of created sticker set owner
	UserID int64 `json:"user_id"`
	// ContainsMasks
	// Pass True, if a set of mask stickers should be created
	ContainsMasks bool `json:"contains_masks,omitempty"`
	// MaskPosition
	// A JSON-serialized object for position where the mask should be placed on faces
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// PngSticker
	// PNG image with the sticker, must be up to 512 kilobytes in size, dimensions must not exceed
	// 512px, and either width or height must be exactly 512px. Pass a file_id as a String to send
	// a file that already exists on the Telegram servers, pass an HTTP URL as a String for
	// Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	PngSticker *InputFile `json:"png_sticker,omitempty"`
	// TgsSticker
	// TGS animation with the sticker, uploaded using multipart/form-data. See
	// https://core.telegram.org/animated_stickers#technical-requirements for technical
	// requirements
	TgsSticker *InputFile `json:"tgs_sticker,omitempty"`
}

// CreateNewStickerSet
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. You must use exactly one of the fields png_sticker or tgs_sticker.
// Returns True on success.
func (api *API) CreateNewStickerSet(
	ctx context.Context,
	args *CreateNewStickerSetConfig,
) error {
	_, err := api.MakeRequest(ctx, "createNewStickerSet", args)
	return err
}

// DeleteChatPhoto
// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must
// be an administrator in the chat for this to work and must have the appropriate admin rights.
// Returns True on success.
func (api *API) DeleteChatPhoto(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) error {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	_, err := api.MakeRequest(ctx, "deleteChatPhoto", args)
	return err
}

// DeleteChatStickerSet
// Use this method to delete a group sticker set from a supergroup. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Use the
// field can_set_sticker_set optionally returned in getChat requests to check if the bot can use
// this method. Returns True on success.
func (api *API) DeleteChatStickerSet(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
) error {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	_, err := api.MakeRequest(ctx, "deleteChatStickerSet", args)
	return err
}

// DeleteMessage
// Use this method to delete a message, including service messages, with the following
// limitations:- A message can only be deleted if it was sent less than 48 hours ago.- A dice
// message in a private chat can only be deleted if it was sent more than 24 hours ago.- Bots can
// delete outgoing messages in private chats, groups, and supergroups.- Bots can delete incoming
// messages in private chats.- Bots granted can_post_messages permissions can delete outgoing
// messages in channels.- If the bot is an administrator of a group, it can delete any message
// there.- If the bot has can_delete_messages permission in a supergroup or a channel, it can
// delete any message there.Returns True on success.
func (api *API) DeleteMessage(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// Identifier of the message to delete
	messageID int64,
) error {
	args := map[string]interface{}{
		"chat_id":    chatID,
		"message_id": messageID,
	}
	_, err := api.MakeRequest(ctx, "deleteMessage", args)
	return err
}

// DeleteStickerFromSet
// Use this method to delete a sticker from a set created by the bot. Returns True on success.
func (api *API) DeleteStickerFromSet(
	ctx context.Context,
	// required.
	// File identifier of the sticker
	sticker string,
) error {
	args := map[string]interface{}{
		"sticker": sticker,
	}
	_, err := api.MakeRequest(ctx, "deleteStickerFromSet", args)
	return err
}

// DeleteWebhook
// Use this method to remove webhook integration if you decide to switch back to getUpdates.
// Returns True on success.
func (api *API) DeleteWebhook(
	ctx context.Context,
	// not required.
	// Pass True to drop all pending updates
	dropPendingUpdates *bool,
) error {
	args := map[string]interface{}{
		"drop_pending_updates": dropPendingUpdates,
	}
	_, err := api.MakeRequest(ctx, "deleteWebhook", args)
	return err
}

// EditMessageCaption
// Use this method to edit captions of messages. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
type EditMessageCaptionConfig struct {
	// Caption
	// New caption of the message, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageCaption
// Use this method to edit captions of messages. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageCaption(
	ctx context.Context,
	args *EditMessageCaptionConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageCaption", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageLiveLocation
// Use this method to edit live location messages. A location can be edited until its live_period
// expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if
// the edited message is not an inline message, the edited Message is returned, otherwise True is
// returned.
type EditMessageLiveLocationConfig struct {
	// Latitude
	// Latitude of new location
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of new location
	Longitude float64 `json:"longitude"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// Heading
	// Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
	Heading int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ProximityAlertRadius
	// Maximum distance for proximity alerts about approaching another chat member, in meters. Must
	// be between 1 and 100000 if specified.
	ProximityAlertRadius int64 `json:"proximity_alert_radius,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageLiveLocation
// Use this method to edit live location messages. A location can be edited until its live_period
// expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if
// the edited message is not an inline message, the edited Message is returned, otherwise True is
// returned.
func (api *API) EditMessageLiveLocation(
	ctx context.Context,
	args *EditMessageLiveLocationConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageLiveLocation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageMedia
// Use this method to edit animation, audio, document, photo, or video messages. If a message is
// part of a message album, then it can be edited only to an audio for audio albums, only to a
// document for document albums and to a photo or a video otherwise. When an inline message is
// edited, a new file can't be uploaded. Use a previously uploaded file via its file_id or specify
// a URL. On success, if the edited message was sent by the bot, the edited Message is returned,
// otherwise True is returned.
type EditMessageMediaConfig struct {
	// Media
	// A JSON-serialized object for a new media content of the message
	Media InputMedia `json:"media"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageMedia
// Use this method to edit animation, audio, document, photo, or video messages. If a message is
// part of a message album, then it can be edited only to an audio for audio albums, only to a
// document for document albums and to a photo or a video otherwise. When an inline message is
// edited, a new file can't be uploaded. Use a previously uploaded file via its file_id or specify
// a URL. On success, if the edited message was sent by the bot, the edited Message is returned,
// otherwise True is returned.
func (api *API) EditMessageMedia(
	ctx context.Context,
	args *EditMessageMediaConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageMedia", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageReplyMarkup
// Use this method to edit only the reply markup of messages. On success, if the edited message is
// not an inline message, the edited Message is returned, otherwise True is returned.
type EditMessageReplyMarkupConfig struct {
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageReplyMarkup
// Use this method to edit only the reply markup of messages. On success, if the edited message is
// not an inline message, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageReplyMarkup(
	ctx context.Context,
	args *EditMessageReplyMarkupConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageReplyMarkup", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// EditMessageText
// Use this method to edit text and game messages. On success, if the edited message is not an
// inline message, the edited Message is returned, otherwise True is returned.
type EditMessageTextConfig struct {
	// Text
	// New text of the message, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`
	// Entities
	// List of special entities that appear in message text, which can be specified instead of
	// parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageText
// Use this method to edit text and game messages. On success, if the edited message is not an
// inline message, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageText(
	ctx context.Context,
	args *EditMessageTextConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "editMessageText", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// ExportChatInviteLink
// Use this method to generate a new invite link for a chat; any previously generated link is
// revoked. The bot must be an administrator in the chat for this to work and must have the
// appropriate admin rights. Returns the new invite link as String on success.
func (api *API) ExportChatInviteLink(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) (string, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "exportChatInviteLink", args)
	if err != nil {
		return "", err
	}
	var data string
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// ForwardMessage
// Use this method to forward messages of any kind. On success, the sent Message is returned.
type ForwardMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FromChatID
	// Unique identifier for the chat where the original message was sent (or channel username in
	// the format @channelusername)
	FromChatID IntStr `json:"from_chat_id"`
	// MessageID
	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// ForwardMessage
// Use this method to forward messages of any kind. On success, the sent Message is returned.
func (api *API) ForwardMessage(
	ctx context.Context,
	args *ForwardMessageConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "forwardMessage", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetChat
// Use this method to get up to date information about the chat (current name of the user for
// one-on-one conversations, current username of a user, group or channel, etc.). Returns a Chat
// object on success.
func (api *API) GetChat(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) (*Chat, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChat", args)
	if err != nil {
		return nil, err
	}
	var data Chat
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetChatAdministrators
// Use this method to get a list of administrators in a chat. On success, returns an Array of
// ChatMember objects that contains information about all chat administrators except other bots. If
// the chat is a group or a supergroup and no administrators were appointed, only the creator will
// be returned.
func (api *API) GetChatAdministrators(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) ([]ChatMember, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChatAdministrators", args)
	if err != nil {
		return nil, err
	}
	var data []ChatMember
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetChatMember
// Use this method to get information about a member of a chat. Returns a ChatMember object on
// success.
func (api *API) GetChatMember(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
	// required.
	// Unique identifier of the target user
	userID int64,
) (*ChatMember, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
		"user_id": userID,
	}
	resp, err := api.MakeRequest(ctx, "getChatMember", args)
	if err != nil {
		return nil, err
	}
	var data ChatMember
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetChatMembersCount
// Use this method to get the number of members in a chat. Returns Int on success.
func (api *API) GetChatMembersCount(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) (int64, error) {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest(ctx, "getChatMembersCount", args)
	if err != nil {
		return 0, err
	}
	var data int64
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetFile
// Use this method to get basic info about a file and prepare it for downloading. For the moment,
// bots can download files of up to 20MB in size. On success, a File object is returned. The file
// can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where
// <file_path> is taken from the response. It is guaranteed that the link will be valid for at
// least 1 hour. When the link expires, a new one can be requested by calling getFile again.
func (api *API) GetFile(
	ctx context.Context,
	// required.
	// File identifier to get info about
	fileID string,
) (*File, error) {
	args := map[string]interface{}{
		"file_id": fileID,
	}
	resp, err := api.MakeRequest(ctx, "getFile", args)
	if err != nil {
		return nil, err
	}
	var data File
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetGameHighScores
// Use this method to get data for high score tables. Will return the score of the specified user
// and several of their neighbors in a game. On success, returns an Array of GameHighScore objects.
type GetGameHighScoresConfig struct {
	// UserID
	// Target user id
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`
}

// GetGameHighScores
// Use this method to get data for high score tables. Will return the score of the specified user
// and several of their neighbors in a game. On success, returns an Array of GameHighScore objects.
func (api *API) GetGameHighScores(
	ctx context.Context,
	args *GetGameHighScoresConfig,
) ([]GameHighScore, error) {
	resp, err := api.MakeRequest(ctx, "getGameHighScores", args)
	if err != nil {
		return nil, err
	}
	var data []GameHighScore
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetMe
// A simple method for testing your bot's auth token. Requires no parameters. Returns basic
// information about the bot in form of a User object.
func (api *API) GetMe(
	ctx context.Context,
) (*User, error) {
	resp, err := api.MakeRequest(ctx, "getMe", nil)
	if err != nil {
		return nil, err
	}
	var data User
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetMyCommands
// Use this method to get the current list of the bot's commands. Requires no parameters. Returns
// Array of BotCommand on success.
func (api *API) GetMyCommands(
	ctx context.Context,
) ([]BotCommand, error) {
	resp, err := api.MakeRequest(ctx, "getMyCommands", nil)
	if err != nil {
		return nil, err
	}
	var data []BotCommand
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetStickerSet
// Use this method to get a sticker set. On success, a StickerSet object is returned.
func (api *API) GetStickerSet(
	ctx context.Context,
	// required.
	// Name of the sticker set
	name string,
) (*StickerSet, error) {
	args := map[string]interface{}{
		"name": name,
	}
	resp, err := api.MakeRequest(ctx, "getStickerSet", args)
	if err != nil {
		return nil, err
	}
	var data StickerSet
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetUpdates
// Use this method to receive incoming updates using long polling (wiki). An Array of Update
// objects is returned.
type GetUpdatesConfig struct {
	// AllowedUpdates
	// A JSON-serialized list of the update types you want your bot to receive. For example,
	// specify ["message", "edited_channel_post", "callback_query"] to only receive updates of
	// these types. See Update for a complete list of available update types. Specify an empty list
	// to receive all updates regardless of type (default). If not specified, the previous setting
	// will be used.Please note that this parameter doesn't affect updates created before the call
	// to the getUpdates, so unwanted updates may be received for a short period of time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// Limit
	// Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to
	// 100.
	Limit int64 `json:"limit,omitempty"`
	// Offset
	// Identifier of the first update to be returned. Must be greater by one than the highest among
	// the identifiers of previously received updates. By default, updates starting with the
	// earliest unconfirmed update are returned. An update is considered confirmed as soon as
	// getUpdates is called with an offset higher than its update_id. The negative offset can be
	// specified to retrieve updates starting from -offset update from the end of the updates
	// queue. All previous updates will forgotten.
	Offset int64 `json:"offset,omitempty"`
	// Timeout
	// Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be
	// positive, short polling should be used for testing purposes only.
	Timeout int64 `json:"timeout,omitempty"`
}

// GetUpdates
// Use this method to receive incoming updates using long polling (wiki). An Array of Update
// objects is returned.
func (api *API) GetUpdates(
	ctx context.Context,
	args *GetUpdatesConfig,
) ([]Update, error) {
	resp, err := api.MakeRequest(ctx, "getUpdates", args)
	if err != nil {
		return nil, err
	}
	var data []Update
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// GetUserProfilePhotos
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos
// object.
type GetUserProfilePhotosConfig struct {
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// Limit
	// Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to
	// 100.
	Limit int64 `json:"limit,omitempty"`
	// Offset
	// Sequential number of the first photo to be returned. By default, all photos are returned.
	Offset int64 `json:"offset,omitempty"`
}

// GetUserProfilePhotos
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos
// object.
func (api *API) GetUserProfilePhotos(
	ctx context.Context,
	args *GetUserProfilePhotosConfig,
) (*UserProfilePhotos, error) {
	resp, err := api.MakeRequest(ctx, "getUserProfilePhotos", args)
	if err != nil {
		return nil, err
	}
	var data UserProfilePhotos
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// GetWebhookInfo
// Use this method to get current webhook status. Requires no parameters. On success, returns a
// WebhookInfo object. If the bot is using getUpdates, will return an object with the url field
// empty.
func (api *API) GetWebhookInfo(
	ctx context.Context,
) (*WebhookInfo, error) {
	resp, err := api.MakeRequest(ctx, "getWebhookInfo", nil)
	if err != nil {
		return nil, err
	}
	var data WebhookInfo
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// KickChatMember
// Use this method to kick a user from a group, a supergroup or a channel. In the case of
// supergroups and channels, the user will not be able to return to the group on their own using
// invite links, etc., unless unbanned first. The bot must be an administrator in the chat for this
// to work and must have the appropriate admin rights. Returns True on success.
type KickChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target group or username of the target supergroup or channel (in
	// the format @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// UntilDate
	// Date when the user will be unbanned, unix time. If user is banned for more than 366 days or
	// less than 30 seconds from the current time they are considered to be banned forever
	UntilDate int64 `json:"until_date,omitempty"`
}

// KickChatMember
// Use this method to kick a user from a group, a supergroup or a channel. In the case of
// supergroups and channels, the user will not be able to return to the group on their own using
// invite links, etc., unless unbanned first. The bot must be an administrator in the chat for this
// to work and must have the appropriate admin rights. Returns True on success.
func (api *API) KickChatMember(
	ctx context.Context,
	args *KickChatMemberConfig,
) error {
	_, err := api.MakeRequest(ctx, "kickChatMember", args)
	return err
}

// LeaveChat
// Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
func (api *API) LeaveChat(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup or channel
	// (in the format @channelusername)
	chatID IntStr,
) error {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	_, err := api.MakeRequest(ctx, "leaveChat", args)
	return err
}

// LogOut
// Use this method to log out from the cloud Bot API server before launching the bot locally. You
// must log out the bot before running it locally, otherwise there is no guarantee that the bot
// will receive updates. After a successful call, you can immediately log in on a local server, but
// will not be able to log in back to the cloud Bot API server for 10 minutes. Returns True on
// success. Requires no parameters.
func (api *API) LogOut(
	ctx context.Context,
) error {
	_, err := api.MakeRequest(ctx, "logOut", nil)
	return err
}

// PinChatMessage
// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
// private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' admin right in a supergroup or 'can_edit_messages' admin right in a channel.
// Returns True on success.
type PinChatMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageID
	// Identifier of a message to pin
	MessageID int64 `json:"message_id"`
	// DisableNotification
	// Pass True, if it is not necessary to send a notification to all chat members about the new
	// pinned message. Notifications are always disabled in channels and private chats.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// PinChatMessage
// Use this method to add a message to the list of pinned messages in a chat. If the chat is not a
// private chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' admin right in a supergroup or 'can_edit_messages' admin right in a channel.
// Returns True on success.
func (api *API) PinChatMessage(
	ctx context.Context,
	args *PinChatMessageConfig,
) error {
	_, err := api.MakeRequest(ctx, "pinChatMessage", args)
	return err
}

// PromoteChatMember
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Pass
// False for all boolean parameters to demote a user. Returns True on success.
type PromoteChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// CanChangeInfo
	// Pass True, if the administrator can change chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info,omitempty"`
	// CanDeleteMessages
	// Pass True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages,omitempty"`
	// CanEditMessages
	// Pass True, if the administrator can edit messages of other users and can pin messages,
	// channels only
	CanEditMessages bool `json:"can_edit_messages,omitempty"`
	// CanInviteUsers
	// Pass True, if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users,omitempty"`
	// CanPinMessages
	// Pass True, if the administrator can pin messages, supergroups only
	CanPinMessages bool `json:"can_pin_messages,omitempty"`
	// CanPostMessages
	// Pass True, if the administrator can create channel posts, channels only
	CanPostMessages bool `json:"can_post_messages,omitempty"`
	// CanPromoteMembers
	// Pass True, if the administrator can add new administrators with a subset of their own
	// privileges or demote administrators that he has promoted, directly or indirectly (promoted
	// by administrators that were appointed by him)
	CanPromoteMembers bool `json:"can_promote_members,omitempty"`
	// CanRestrictMembers
	// Pass True, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members,omitempty"`
	// IsAnonymous
	// Pass True, if the administrator's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous,omitempty"`
}

// PromoteChatMember
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Pass
// False for all boolean parameters to demote a user. Returns True on success.
func (api *API) PromoteChatMember(
	ctx context.Context,
	args *PromoteChatMemberConfig,
) error {
	_, err := api.MakeRequest(ctx, "promoteChatMember", args)
	return err
}

// RestrictChatMember
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate admin rights. Pass True for all
// permissions to lift restrictions from a user. Returns True on success.
type RestrictChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Permissions
	// A JSON-serialized object for new user permissions
	Permissions ChatPermissions `json:"permissions"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// UntilDate
	// Date when restrictions will be lifted for the user, unix time. If user is restricted for
	// more than 366 days or less than 30 seconds from the current time, they are considered to be
	// restricted forever
	UntilDate int64 `json:"until_date,omitempty"`
}

// RestrictChatMember
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate admin rights. Pass True for all
// permissions to lift restrictions from a user. Returns True on success.
func (api *API) RestrictChatMember(
	ctx context.Context,
	args *RestrictChatMemberConfig,
) error {
	_, err := api.MakeRequest(ctx, "restrictChatMember", args)
	return err
}

// SendAnimation
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On
// success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in
// size, this limit may be changed in the future.
type SendAnimationConfig struct {
	// Animation
	// Animation to send. Pass a file_id as String to send an animation that exists on the Telegram
	// servers (recommended), pass an HTTP URL as a String for Telegram to get an animation from
	// the Internet, or upload a new animation using multipart/form-data.
	Animation InputFile `json:"animation"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Animation caption (may also be used when resending animation by file_id), 0-1024 characters
	// after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent animation in seconds
	Duration int64 `json:"duration,omitempty"`
	// Height
	// Animation height
	Height int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the animation caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputFile `json:"thumb,omitempty"`
	// Width
	// Animation width
	Width int64 `json:"width,omitempty"`
}

func (t SendAnimationConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("height", strconv.FormatInt(t.Height, 10))
	res.Add("parse_mode", t.ParseMode)
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	res.Add("width", strconv.FormatInt(t.Width, 10))
	return res, nil
}

// SendAnimation
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On
// success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in
// size, this limit may be changed in the future.}}
func (api *API) SendAnimation(
	ctx context.Context,
	args *SendAnimationConfig,
) (*Message, error) {
	if args.Animation.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendAnimation", "animation", &args.Animation)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendAnimation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendAudio
// Use this method to send audio files, if you want Telegram clients to display them in the music
// player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the
// future.
type SendAudioConfig struct {
	// Audio
	// Audio file to send. Pass a file_id as String to send an audio file that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an audio
	// file from the Internet, or upload a new one using multipart/form-data.
	Audio InputFile `json:"audio"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Audio caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of the audio in seconds
	Duration int64 `json:"duration,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// Performer
	// Performer
	Performer string `json:"performer,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputFile `json:"thumb,omitempty"`
	// Title
	// Track name
	Title string `json:"title,omitempty"`
}

func (t SendAudioConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("parse_mode", t.ParseMode)
	res.Add("performer", t.Performer)
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	res.Add("title", t.Title)
	return res, nil
}

// SendAudio
// Use this method to send audio files, if you want Telegram clients to display them in the music
// player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the
// future.}}
func (api *API) SendAudio(
	ctx context.Context,
	args *SendAudioConfig,
) (*Message, error) {
	if args.Audio.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendAudio", "audio", &args.Audio)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendAudio", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendChatAction
// Use this method when you need to tell the user that something is happening on the bot's side.
// The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients
// clear its typing status). Returns True on success.
func (api *API) SendChatAction(
	ctx context.Context,
	// required.
	// Type of action to broadcast. Choose one, depending on what the user is about to receive:
	// typing for text messages, upload_photo for photos, record_video or upload_video for
	// videos, record_voice or upload_voice for voice notes, upload_document for general files,
	// find_location for location data, record_video_note or upload_video_note for video notes.
	action string,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) error {
	args := map[string]interface{}{
		"action":  action,
		"chat_id": chatID,
	}
	_, err := api.MakeRequest(ctx, "sendChatAction", args)
	return err
}

// SendContact
// Use this method to send phone contacts. On success, the sent Message is returned.
type SendContactConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// LastName
	// Contact's last name
	LastName string `json:"last_name,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard string `json:"vcard,omitempty"`
}

// SendContact
// Use this method to send phone contacts. On success, the sent Message is returned.
func (api *API) SendContact(
	ctx context.Context,
	args *SendContactConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendContact", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendDice
// Use this method to send an animated emoji that will display a random value. On success, the sent
// Message is returned.
type SendDiceConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Emoji
	// Emoji on which the dice throw animation is based. Currently, must be one of "", "", "", "",
	// or "". Dice can have values 1-6 for "" and "", values 1-5 for "" and "", and values 1-64 for
	// "". Defaults to ""
	Emoji string `json:"emoji,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendDice
// Use this method to send an animated emoji that will display a random value. On success, the sent
// Message is returned.
func (api *API) SendDice(
	ctx context.Context,
	args *SendDiceConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendDice", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendDocument
// Use this method to send general files. On success, the sent Message is returned. Bots can
// currently send files of any type of up to 50 MB in size, this limit may be changed in the
// future.
type SendDocumentConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Document
	// File to send. Pass a file_id as String to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or
	// upload a new one using multipart/form-data.
	Document InputFile `json:"document"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Document caption (may also be used when resending documents by file_id), 0-1024 characters
	// after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableContentTypeDetection
	// Disables automatic server-side content type detection for files uploaded using
	// multipart/form-data
	DisableContentTypeDetection bool `json:"disable_content_type_detection,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputFile `json:"thumb,omitempty"`
}

func (t SendDocumentConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_content_type_detection", strconv.FormatBool(t.DisableContentTypeDetection))
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("parse_mode", t.ParseMode)
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendDocument
// Use this method to send general files. On success, the sent Message is returned. Bots can
// currently send files of any type of up to 50 MB in size, this limit may be changed in the
// future.}}
func (api *API) SendDocument(
	ctx context.Context,
	args *SendDocumentConfig,
) (*Message, error) {
	if args.Document.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendDocument", "document", &args.Document)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendDocument", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendGame
// Use this method to send a game. On success, the sent Message is returned.
type SendGameConfig struct {
	// ChatID
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`
	// GameShortName
	// Short name of the game, serves as the unique identifier for the game. Set up your games via
	// Botfather.
	GameShortName string `json:"game_short_name"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will
	// be shown. If not empty, the first button must launch the game.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendGame
// Use this method to send a game. On success, the sent Message is returned.
func (api *API) SendGame(
	ctx context.Context,
	args *SendGameConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendGame", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendInvoice
// Use this method to send invoices. On success, the sent Message is returned.
type SendInvoiceConfig struct {
	// ChatID
	// Unique identifier for the target private chat
	ChatID int64 `json:"chat_id"`
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payments provider token, obtained via Botfather
	ProviderToken string `json:"provider_token"`
	// StartParameter
	// Unique deep-linking parameter that can be used to generate this invoice when used as a start
	// parameter
	StartParameter string `json:"start_parameter"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// IsFlexible
	// Pass True, if the final price depends on the shipping method
	IsFlexible bool `json:"is_flexible,omitempty"`
	// NeedEmail
	// Pass True, if you require the user's email address to complete the order
	NeedEmail bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True, if you require the user's full name to complete the order
	NeedName bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True, if you require the user's phone number to complete the order
	NeedPhoneNumber bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True, if you require the user's shipping address to complete the order
	NeedShippingAddress bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size
	PhotoSize int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service. People like it better when they see what they are paying for.
	PhotoURL string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth int64 `json:"photo_width,omitempty"`
	// ProviderData
	// A JSON-serialized data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData string `json:"provider_data,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will
	// be shown. If not empty, the first button must be a Pay button.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// SendEmailToProvider
	// Pass True, if user's email address should be sent to provider
	SendEmailToProvider bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True, if user's phone number should be sent to provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider,omitempty"`
}

// SendInvoice
// Use this method to send invoices. On success, the sent Message is returned.
func (api *API) SendInvoice(
	ctx context.Context,
	args *SendInvoiceConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendInvoice", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendLocation
// Use this method to send point on the map. On success, the sent Message is returned.
type SendLocationConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Latitude
	// Latitude of the location
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the location
	Longitude float64 `json:"longitude"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Heading
	// For live locations, a direction in which the user is moving, in degrees. Must be between 1
	// and 360 if specified.
	Heading int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// LivePeriod
	// Period in seconds for which the location will be updated (see Live Locations, should be
	// between 60 and 86400.
	LivePeriod int64 `json:"live_period,omitempty"`
	// ProximityAlertRadius
	// For live locations, a maximum distance for proximity alerts about approaching another chat
	// member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius int64 `json:"proximity_alert_radius,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendLocation
// Use this method to send point on the map. On success, the sent Message is returned.
func (api *API) SendLocation(
	ctx context.Context,
	args *SendLocationConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendLocation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendMediaGroup
// Use this method to send a group of photos, videos, documents or audios as an album. Documents
// and audio files can be only grouped in an album with messages of the same type. On success, an
// array of Messages that were sent is returned.
type SendMediaGroupConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Media
	// A JSON-serialized array describing messages to be sent, must include 2-10 items
	Media []InputMediaGraphics `json:"media"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends messages silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ReplyToMessageID
	// If the messages are a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendMediaGroup
// Use this method to send a group of photos, videos, documents or audios as an album. Documents
// and audio files can be only grouped in an album with messages of the same type. On success, an
// array of Messages that were sent is returned.
func (api *API) SendMediaGroup(
	ctx context.Context,
	args *SendMediaGroupConfig,
) ([]Message, error) {
	resp, err := api.MakeRequest(ctx, "sendMediaGroup", args)
	if err != nil {
		return nil, err
	}
	var data []Message
	err = json.Unmarshal(resp.Result, &data)
	return data, err
}

// SendMessage
// Use this method to send text messages. On success, the sent Message is returned.
type SendMessageConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Text
	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`
	// Entities
	// List of special entities that appear in message text, which can be specified instead of
	// parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendMessage
// Use this method to send text messages. On success, the sent Message is returned.
func (api *API) SendMessage(
	ctx context.Context,
	args *SendMessageConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendMessage", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendPhoto
// Use this method to send photos. On success, the sent Message is returned.
type SendPhotoConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Photo
	// Photo to send. Pass a file_id as String to send a photo that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet,
	// or upload a new photo using multipart/form-data. The photo must be at most 10 MB in size.
	// The photo's width and height must not exceed 10000 in total. Width and height ratio must be
	// at most 20.
	Photo InputFile `json:"photo"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Photo caption (may also be used when resending photos by file_id), 0-1024 characters after
	// entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

func (t SendPhotoConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("parse_mode", t.ParseMode)
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendPhoto
// Use this method to send photos. On success, the sent Message is returned.}}
func (api *API) SendPhoto(
	ctx context.Context,
	args *SendPhotoConfig,
) (*Message, error) {
	if args.Photo.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendPhoto", "photo", &args.Photo)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendPhoto", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendPoll
// Use this method to send a native poll. On success, the sent Message is returned.
type SendPollConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Options
	// A JSON-serialized list of answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`
	// Question
	// Poll question, 1-300 characters
	Question string `json:"question"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// AllowsMultipleAnswers
	// True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False
	AllowsMultipleAnswers bool `json:"allows_multiple_answers,omitempty"`
	// CloseDate
	// Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least
	// 5 and no more than 600 seconds in the future. Can't be used together with open_period.
	CloseDate int64 `json:"close_date,omitempty"`
	// CorrectOptionID
	// 0-based identifier of the correct answer option, required for polls in quiz mode
	CorrectOptionID int64 `json:"correct_option_id,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Explanation
	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a
	// quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
	Explanation string `json:"explanation,omitempty"`
	// ExplanationEntities
	// List of special entities that appear in the poll explanation, which can be specified instead
	// of parse_mode
	ExplanationEntities []MessageEntity `json:"explanation_entities,omitempty"`
	// ExplanationParseMode
	// Mode for parsing entities in the explanation. See formatting options for more details.
	ExplanationParseMode string `json:"explanation_parse_mode,omitempty"`
	// IsAnonymous
	// True, if the poll needs to be anonymous, defaults to True
	IsAnonymous bool `json:"is_anonymous,omitempty"`
	// IsClosed
	// Pass True, if the poll needs to be immediately closed. This can be useful for poll preview.
	IsClosed bool `json:"is_closed,omitempty"`
	// OpenPeriod
	// Amount of time in seconds the poll will be active after creation, 5-600. Can't be used
	// together with close_date.
	OpenPeriod int64 `json:"open_period,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Type
	// Poll type, "quiz" or "regular", defaults to "regular"
	Type *SendType `json:"type,omitempty"`
}

// SendPoll
// Use this method to send a native poll. On success, the sent Message is returned.
func (api *API) SendPoll(
	ctx context.Context,
	args *SendPollConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendPoll", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendSticker
// Use this method to send static .WEBP or animated .TGS stickers. On success, the sent Message is
// returned.
type SendStickerConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Sticker
	// Sticker to send. Pass a file_id as String to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a .WEBP file from the
	// Internet, or upload a new one using multipart/form-data.
	Sticker InputFile `json:"sticker"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

func (t SendStickerConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendSticker
// Use this method to send static .WEBP or animated .TGS stickers. On success, the sent Message is
// returned.}}
func (api *API) SendSticker(
	ctx context.Context,
	args *SendStickerConfig,
) (*Message, error) {
	if args.Sticker.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendSticker", "sticker", &args.Sticker)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendSticker", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVenue
// Use this method to send information about a venue. On success, the sent Message is returned.
type SendVenueConfig struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Latitude
	// Latitude of the venue
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue
	Longitude float64 `json:"longitude"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// FoursquareID
	// Foursquare identifier of the venue
	FoursquareID string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType string `json:"foursquare_type,omitempty"`
	// GooglePlaceID
	// Google Places identifier of the venue
	GooglePlaceID string `json:"google_place_id,omitempty"`
	// GooglePlaceType
	// Google Places type of the venue. (See supported types.)
	GooglePlaceType string `json:"google_place_type,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendVenue
// Use this method to send information about a venue. On success, the sent Message is returned.
func (api *API) SendVenue(
	ctx context.Context,
	args *SendVenueConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "sendVenue", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVideo
// Use this method to send video files, Telegram clients support mp4 videos (other formats may be
// sent as Document). On success, the sent Message is returned. Bots can currently send video files
// of up to 50 MB in size, this limit may be changed in the future.
type SendVideoConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Video
	// Video to send. Pass a file_id as String to send a video that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet,
	// or upload a new video using multipart/form-data.
	Video InputFile `json:"video"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Video caption (may also be used when resending videos by file_id), 0-1024 characters after
	// entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`
	// Height
	// Video height
	Height int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// SupportsStreaming
	// Pass True, if the uploaded video is suitable for streaming
	SupportsStreaming bool `json:"supports_streaming,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputFile `json:"thumb,omitempty"`
	// Width
	// Video width
	Width int64 `json:"width,omitempty"`
}

func (t SendVideoConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("height", strconv.FormatInt(t.Height, 10))
	res.Add("parse_mode", t.ParseMode)
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	res.Add("supports_streaming", strconv.FormatBool(t.SupportsStreaming))
	res.Add("width", strconv.FormatInt(t.Width, 10))
	return res, nil
}

// SendVideo
// Use this method to send video files, Telegram clients support mp4 videos (other formats may be
// sent as Document). On success, the sent Message is returned. Bots can currently send video files
// of up to 50 MB in size, this limit may be changed in the future.}}
func (api *API) SendVideo(
	ctx context.Context,
	args *SendVideoConfig,
) (*Message, error) {
	if args.Video.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendVideo", "video", &args.Video)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendVideo", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVideoNote
// As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1 minute long. Use this
// method to send video messages. On success, the sent Message is returned.
type SendVideoNoteConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// VideoNote
	// Video note to send. Pass a file_id as String to send a video note that exists on the
	// Telegram servers (recommended) or upload a new video using multipart/form-data. . Sending
	// video notes by a URL is currently unsupported
	VideoNote InputFile `json:"video_note"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`
	// Length
	// Video width and height, i.e. diameter of the video message
	Length int64 `json:"length,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb *InputFile `json:"thumb,omitempty"`
}

func (t SendVideoNoteConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("length", strconv.FormatInt(t.Length, 10))
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendVideoNote
// As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1 minute long. Use this
// method to send video messages. On success, the sent Message is returned.}}
func (api *API) SendVideoNote(
	ctx context.Context,
	args *SendVideoNoteConfig,
) (*Message, error) {
	if args.VideoNote.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendVideoNote", "videonote", &args.VideoNote)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendVideoNote", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SendVoice
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots
// can currently send voice messages of up to 50 MB in size, this limit may be changed in the
// future.
type SendVoiceConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Voice
	// Audio file to send. Pass a file_id as String to send a file that exists on the Telegram
	// servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the
	// Internet, or upload a new one using multipart/form-data.
	Voice InputFile `json:"voice"`
	// AllowSendingWithoutReply
	// Pass True, if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`
	// Caption
	// Voice message caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of the voice message in seconds
	Duration int64 `json:"duration,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

func (t SendVoiceConfig) EncodeURL() (url.Values, error) {
	res := make(url.Values)
	res.Add("allow_sending_without_reply", strconv.FormatBool(t.AllowSendingWithoutReply))
	res.Add("caption", t.Caption)
	if t.CaptionEntities != nil {
		raw, err := json.Marshal(t.CaptionEntities)
		if err != nil {
			return nil, err
		}
		res.Add("caption_entities", string(raw))
	}
	res.Add("chat_id", t.ChatID.String())
	res.Add("disable_notification", strconv.FormatBool(t.DisableNotification))
	res.Add("duration", strconv.FormatInt(t.Duration, 10))
	res.Add("parse_mode", t.ParseMode)
	if t.ReplyMarkup != nil {
		raw, err := json.Marshal(t.ReplyMarkup)
		if err != nil {
			return nil, err
		}
		res.Add("reply_markup", string(raw))
	}
	res.Add("reply_to_message_id", strconv.FormatInt(t.ReplyToMessageID, 10))
	return res, nil
}

// SendVoice
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots
// can currently send voice messages of up to 50 MB in size, this limit may be changed in the
// future.}}
func (api *API) SendVoice(
	ctx context.Context,
	args *SendVoiceConfig,
) (*Message, error) {
	if args.Voice.Reader != nil {
		values, err := args.EncodeURL()
		if err != nil {
			return nil, err
		}
		resp, err := api.UploadFile(ctx, values, "sendVoice", "voice", &args.Voice)
		if err != nil {
			return nil, err
		}

		var res Message
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	resp, err := api.MakeRequest(ctx, "sendVoice", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetChatAdministratorCustomTitle
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
type SetChatAdministratorCustomTitleConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// CustomTitle
	// New custom title for the administrator; 0-16 characters, emoji are not allowed
	CustomTitle string `json:"custom_title"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// SetChatAdministratorCustomTitle
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
func (api *API) SetChatAdministratorCustomTitle(
	ctx context.Context,
	args *SetChatAdministratorCustomTitleConfig,
) error {
	_, err := api.MakeRequest(ctx, "setChatAdministratorCustomTitle", args)
	return err
}

// SetChatDescription
// Use this method to change the description of a group, a supergroup or a channel. The bot must be
// an administrator in the chat for this to work and must have the appropriate admin rights.
// Returns True on success.
func (api *API) SetChatDescription(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// not required.
	// New chat description, 0-255 characters
	description *string,
) error {
	args := map[string]interface{}{
		"chat_id":     chatID,
		"description": description,
	}
	_, err := api.MakeRequest(ctx, "setChatDescription", args)
	return err
}

// SetChatPermissions
// Use this method to set default chat permissions for all members. The bot must be an
// administrator in the group or a supergroup for this to work and must have the
// can_restrict_members admin rights. Returns True on success.
func (api *API) SetChatPermissions(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// New default chat permissions
	permissions ChatPermissions,
) error {
	args := map[string]interface{}{
		"chat_id":     chatID,
		"permissions": permissions,
	}
	_, err := api.MakeRequest(ctx, "setChatPermissions", args)
	return err
}

// SetChatPhoto
// Use this method to set a new profile photo for the chat. Photos can't be changed for private
// chats. The bot must be an administrator in the chat for this to work and must have the
// appropriate admin rights. Returns True on success.}}
func (api *API) SetChatPhoto(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// New chat photo, uploaded using multipart/form-data
	photo InputFile,
) error {
	if photo.Reader != nil {
		values := url.Values{
			"chat_id": []string{chatID.String()},
		}
		_, err := api.UploadFile(ctx, values, "setChatPhoto", "setchatphoto", &photo)
		return err
	}
	args := map[string]interface{}{
		"chat_id": chatID,
		"photo":   photo,
	}
	_, err := api.MakeRequest(ctx, "setChatPhoto", args)
	return err
}

// SetChatStickerSet
// Use this method to set a new group sticker set for a supergroup. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Use the
// field can_set_sticker_set optionally returned in getChat requests to check if the bot can use
// this method. Returns True on success.
func (api *API) SetChatStickerSet(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target supergroup (in the
	// format @supergroupusername)
	chatID IntStr,
	// required.
	// Name of the sticker set to be set as the group sticker set
	stickerSetName string,
) error {
	args := map[string]interface{}{
		"chat_id":          chatID,
		"sticker_set_name": stickerSetName,
	}
	_, err := api.MakeRequest(ctx, "setChatStickerSet", args)
	return err
}

// SetChatTitle
// Use this method to change the title of a chat. Titles can't be changed for private chats. The
// bot must be an administrator in the chat for this to work and must have the appropriate admin
// rights. Returns True on success.
func (api *API) SetChatTitle(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// required.
	// New chat title, 1-255 characters
	title string,
) error {
	args := map[string]interface{}{
		"chat_id": chatID,
		"title":   title,
	}
	_, err := api.MakeRequest(ctx, "setChatTitle", args)
	return err
}

// SetGameScore
// Use this method to set the score of the specified user in a game. On success, if the message was
// sent by the bot, returns the edited Message, otherwise returns True. Returns an error, if the
// new score is not greater than the user's current score in the chat and force is False.
type SetGameScoreConfig struct {
	// Score
	// New score, must be non-negative
	Score int64 `json:"score"`
	// UserID
	// User identifier
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`
	// DisableEditMessage
	// Pass True, if the game message should not be automatically edited to include the current
	// scoreboard
	DisableEditMessage bool `json:"disable_edit_message,omitempty"`
	// Force
	// Pass True, if the high score is allowed to decrease. This can be useful when fixing mistakes
	// or banning cheaters
	Force bool `json:"force,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`
}

// SetGameScore
// Use this method to set the score of the specified user in a game. On success, if the message was
// sent by the bot, returns the edited Message, otherwise returns True. Returns an error, if the
// new score is not greater than the user's current score in the chat and force is False.
func (api *API) SetGameScore(
	ctx context.Context,
	args *SetGameScoreConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "setGameScore", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// SetMyCommands
// Use this method to change the list of the bot's commands. Returns True on success.
func (api *API) SetMyCommands(
	ctx context.Context,
	// required.
	// A JSON-serialized list of bot commands to be set as the list of the bot's commands. At
	// most 100 commands can be specified.
	commands []BotCommand,
) error {
	args := map[string]interface{}{
		"commands": commands,
	}
	_, err := api.MakeRequest(ctx, "setMyCommands", args)
	return err
}

// SetPassportDataErrors
// Informs a user that some of the Telegram Passport elements they provided contains errors. The
// user will not be able to re-submit their Passport to you until the errors are fixed (the
// contents of the field for which you returned the error must change). Returns True on success.
func (api *API) SetPassportDataErrors(
	ctx context.Context,
	// required.
	// A JSON-serialized array describing the errors
	errors []PassportElementError,
	// required.
	// User identifier
	userID int64,
) error {
	args := map[string]interface{}{
		"errors":  errors,
		"user_id": userID,
	}
	_, err := api.MakeRequest(ctx, "setPassportDataErrors", args)
	return err
}

// SetStickerPositionInSet
// Use this method to move a sticker in a set created by the bot to a specific position. Returns
// True on success.
func (api *API) SetStickerPositionInSet(
	ctx context.Context,
	// required.
	// New sticker position in the set, zero-based
	position int64,
	// required.
	// File identifier of the sticker
	sticker string,
) error {
	args := map[string]interface{}{
		"position": position,
		"sticker":  sticker,
	}
	_, err := api.MakeRequest(ctx, "setStickerPositionInSet", args)
	return err
}

// SetStickerSetThumb
// Use this method to set the thumbnail of a sticker set. Animated thumbnails can be set for
// animated sticker sets only. Returns True on success.
type SetStickerSetThumbConfig struct {
	// Name
	// Sticker set name
	Name string `json:"name"`
	// UserID
	// User identifier of the sticker set owner
	UserID int64 `json:"user_id"`
	// Thumb
	// A PNG image with the thumbnail, must be up to 128 kilobytes in size and have width and
	// height exactly 100px, or a TGS animation with the thumbnail up to 32 kilobytes in size; see
	// https://core.telegram.org/animated_stickers#technical-requirements for animated sticker
	// technical requirements. Pass a file_id as a String to send a file that already exists on the
	// Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet,
	// or upload a new one using multipart/form-data. . Animated sticker set thumbnail can't be
	// uploaded via HTTP URL.
	Thumb *InputFile `json:"thumb,omitempty"`
}

// SetStickerSetThumb
// Use this method to set the thumbnail of a sticker set. Animated thumbnails can be set for
// animated sticker sets only. Returns True on success.
func (api *API) SetStickerSetThumb(
	ctx context.Context,
	args *SetStickerSetThumbConfig,
) error {
	_, err := api.MakeRequest(ctx, "setStickerSetThumb", args)
	return err
}

// SetWebhook
// Use this method to specify a url and receive incoming updates via an outgoing webhook. Whenever
// there is an update for the bot, we will send an HTTPS POST request to the specified url,
// containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a
// reasonable amount of attempts. Returns True on success.
type SetWebhookConfig struct {
	// URL
	// HTTPS url to send updates to. Use an empty string to remove webhook integration
	URL string `json:"url"`
	// AllowedUpdates
	// A JSON-serialized list of the update types you want your bot to receive. For example,
	// specify ["message", "edited_channel_post", "callback_query"] to only receive updates of
	// these types. See Update for a complete list of available update types. Specify an empty list
	// to receive all updates regardless of type (default). If not specified, the previous setting
	// will be used.Please note that this parameter doesn't affect updates created before the call
	// to the setWebhook, so unwanted updates may be received for a short period of time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// Certificate
	// Upload your public key certificate so that the root certificate in use can be checked. See
	// our self-signed guide for details.
	Certificate *InputFile `json:"certificate,omitempty"`
	// DropPendingUpdates
	// Pass True to drop all pending updates
	DropPendingUpdates bool `json:"drop_pending_updates,omitempty"`
	// IPAddress
	// The fixed IP address which will be used to send webhook requests instead of the IP address
	// resolved through DNS
	IPAddress string `json:"ip_address,omitempty"`
	// MaxConnections
	// Maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery,
	// 1-100. Defaults to 40. Use lower values to limit the load on your bot's server, and higher
	// values to increase your bot's throughput.
	MaxConnections int64 `json:"max_connections,omitempty"`
}

// SetWebhook
// Use this method to specify a url and receive incoming updates via an outgoing webhook. Whenever
// there is an update for the bot, we will send an HTTPS POST request to the specified url,
// containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a
// reasonable amount of attempts. Returns True on success.
func (api *API) SetWebhook(
	ctx context.Context,
	args *SetWebhookConfig,
) error {
	_, err := api.MakeRequest(ctx, "setWebhook", args)
	return err
}

// StopMessageLiveLocation
// Use this method to stop updating a live location message before live_period expires. On success,
// if the message was sent by the bot, the sent Message is returned, otherwise True is returned.
type StopMessageLiveLocationConfig struct {
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message with live location
	// to stop
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopMessageLiveLocation
// Use this method to stop updating a live location message before live_period expires. On success,
// if the message was sent by the bot, the sent Message is returned, otherwise True is returned.
func (api *API) StopMessageLiveLocation(
	ctx context.Context,
	args *StopMessageLiveLocationConfig,
) (*Message, error) {
	resp, err := api.MakeRequest(ctx, "stopMessageLiveLocation", args)
	if err != nil {
		return nil, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// StopPoll
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll with the
// final results is returned.
type StopPollConfig struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageID
	// Identifier of the original message with the poll
	MessageID int64 `json:"message_id"`
	// ReplyMarkup
	// A JSON-serialized object for a new message inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopPoll
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll with the
// final results is returned.
func (api *API) StopPoll(
	ctx context.Context,
	args *StopPollConfig,
) (*Poll, error) {
	resp, err := api.MakeRequest(ctx, "stopPoll", args)
	if err != nil {
		return nil, err
	}
	var data Poll
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}

// UnbanChatMember
// Use this method to unban a previously kicked user in a supergroup or channel. The user will not
// return to the group or channel automatically, but will be able to join via link, etc. The bot
// must be an administrator for this to work. By default, this method guarantees that after the
// call the user is not a member of the chat, but will be able to join it. So if the user is a
// member of the chat they will also be removed from the chat. If you don't want this, use the
// parameter only_if_banned. Returns True on success.
type UnbanChatMemberConfig struct {
	// ChatID
	// Unique identifier for the target group or username of the target supergroup or channel (in
	// the format @username)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// OnlyIfBanned
	// Do nothing if the user is not banned
	OnlyIfBanned bool `json:"only_if_banned,omitempty"`
}

// UnbanChatMember
// Use this method to unban a previously kicked user in a supergroup or channel. The user will not
// return to the group or channel automatically, but will be able to join via link, etc. The bot
// must be an administrator for this to work. By default, this method guarantees that after the
// call the user is not a member of the chat, but will be able to join it. So if the user is a
// member of the chat they will also be removed from the chat. If you don't want this, use the
// parameter only_if_banned. Returns True on success.
func (api *API) UnbanChatMember(
	ctx context.Context,
	args *UnbanChatMemberConfig,
) error {
	_, err := api.MakeRequest(ctx, "unbanChatMember", args)
	return err
}

// UnpinAllChatMessages
// Use this method to clear the list of pinned messages in a chat. If the chat is not a private
// chat, the bot must be an administrator in the chat for this to work and must have the
// 'can_pin_messages' admin right in a supergroup or 'can_edit_messages' admin right in a channel.
// Returns True on success.
func (api *API) UnpinAllChatMessages(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
) error {
	args := map[string]interface{}{
		"chat_id": chatID,
	}
	_, err := api.MakeRequest(ctx, "unpinAllChatMessages", args)
	return err
}

// UnpinChatMessage
// Use this method to remove a message from the list of pinned messages in a chat. If the chat is
// not a private chat, the bot must be an administrator in the chat for this to work and must have
// the 'can_pin_messages' admin right in a supergroup or 'can_edit_messages' admin right in a
// channel. Returns True on success.
func (api *API) UnpinChatMessage(
	ctx context.Context,
	// required.
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	chatID IntStr,
	// not required.
	// Identifier of a message to unpin. If not specified, the most recent pinned message (by
	// sending date) will be unpinned.
	messageID *int64,
) error {
	args := map[string]interface{}{
		"chat_id":    chatID,
		"message_id": messageID,
	}
	_, err := api.MakeRequest(ctx, "unpinChatMessage", args)
	return err
}

// UploadStickerFile
// Use this method to upload a .PNG file with a sticker for later use in createNewStickerSet and
// addStickerToSet methods (can be used multiple times). Returns the uploaded File on success.}}
func (api *API) UploadStickerFile(
	ctx context.Context,
	// required.
	// PNG image with the sticker, must be up to 512 kilobytes in size, dimensions must not
	// exceed 512px, and either width or height must be exactly 512px.
	pngSticker InputFile,
	// required.
	// User identifier of sticker file owner
	userID int64,
) (*File, error) {
	if pngSticker.Reader != nil {
		values := url.Values{
			"user_id": []string{strconv.FormatInt(userID, 10)},
		}
		resp, err := api.UploadFile(ctx, values, "uploadStickerFile", "uploadstickerfile", &pngSticker)
		if err != nil {
			return nil, err
		}

		var res File
		err = json.Unmarshal(resp.Result, &res)
		return &res, err
	}
	args := map[string]interface{}{
		"png_sticker": pngSticker,
		"user_id":     userID,
	}
	resp, err := api.MakeRequest(ctx, "uploadStickerFile", args)
	if err != nil {
		return nil, err
	}
	var data File
	err = json.Unmarshal(resp.Result, &data)
	return &data, err
}
