// Generated by: github.com/Feresey/gen-tgbotapi

package tgapi

const Version = "6.7"

// TODO: category description

// Animation
// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
type Animation struct {
	// Duration
	// Duration of the video in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Video height as defined by sender
	Height int64 `json:"height"`
	// Width
	// Video width as defined by sender
	Width int64 `json:"width"`
	// FileName
	// Original animation filename as defined by sender
	FileName *string `json:"file_name,omitempty"`
	// FileSize
	// File size in bytes. It can be bigger than 2^31 and some programming languages may have
	// difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a
	// signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Thumbnail
	// Animation thumbnail as defined by sender
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *Animation) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

func (t *Animation) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Animation) GetFileName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FileName; field != nil {
		return *field
	}
	return res
}

func (t *Animation) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Animation) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Animation) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Height
}

func (t *Animation) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Animation) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *Animation) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Width
}

// Audio
// This object represents an audio file to be treated as music by the Telegram clients.
type Audio struct {
	// Duration
	// Duration of the audio in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FileName
	// Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`
	// FileSize
	// File size in bytes. It can be bigger than 2^31 and some programming languages may have
	// difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a
	// signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Performer
	// Performer of the audio as defined by sender or by audio tags
	Performer *string `json:"performer,omitempty"`
	// Thumbnail
	// Thumbnail of the album cover to which the music file belongs
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
	// Title
	// Title of the audio as defined by sender or by audio tags
	Title *string `json:"title,omitempty"`
}

func (t *Audio) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

func (t *Audio) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Audio) GetFileName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FileName; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Audio) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetPerformer() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Performer; field != nil {
		return *field
	}
	return res
}

func (t *Audio) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *Audio) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

// BotCommand
// This object represents a bot command.
type BotCommand struct {
	// Command
	// Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and
	// underscores.
	Command string `json:"command"`
	// Description
	// Description of the command; 1-256 characters.
	Description string `json:"description"`
}

func (t *BotCommand) GetCommand() string {
	var res string
	if t == nil {
		return res
	}
	return t.Command
}

func (t *BotCommand) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.Description
}

// BotCommandScope
// This object represents the scope to which bot commands are applied. Currently, the following 7
// scopes are supported:
type BotCommandScope struct {
	// Type
	// Scope type, must be default
	Type BotType `json:"type"`
}

func (t *BotCommandScope) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotCommandScopeAllChatAdministrators
// Represents the scope of bot commands, covering all group and supergroup chat administrators.
type BotCommandScopeAllChatAdministrators struct {
	// Type
	// Scope type, must be all_chat_administrators
	Type BotType `json:"type"`
}

func (t *BotCommandScopeAllChatAdministrators) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotCommandScopeAllGroupChats
// Represents the scope of bot commands, covering all group and supergroup chats.
type BotCommandScopeAllGroupChats struct {
	// Type
	// Scope type, must be all_group_chats
	Type BotType `json:"type"`
}

func (t *BotCommandScopeAllGroupChats) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotCommandScopeAllPrivateChats
// Represents the scope of bot commands, covering all private chats.
type BotCommandScopeAllPrivateChats struct {
	// Type
	// Scope type, must be all_private_chats
	Type BotType `json:"type"`
}

func (t *BotCommandScopeAllPrivateChats) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotCommandScopeChat
// Represents the scope of bot commands, covering a specific chat.
type BotCommandScopeChat struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Type
	// Scope type, must be chat
	Type BotType `json:"type"`
}

func (t *BotCommandScopeChat) GetChatID() IntStr {
	var res IntStr
	if t == nil {
		return res
	}
	return t.ChatID
}

func (t *BotCommandScopeChat) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotCommandScopeChatAdministrators
// Represents the scope of bot commands, covering all administrators of a specific group or
// supergroup chat.
type BotCommandScopeChatAdministrators struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Type
	// Scope type, must be chat_administrators
	Type BotType `json:"type"`
}

func (t *BotCommandScopeChatAdministrators) GetChatID() IntStr {
	var res IntStr
	if t == nil {
		return res
	}
	return t.ChatID
}

func (t *BotCommandScopeChatAdministrators) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotCommandScopeChatMember
// Represents the scope of bot commands, covering a specific member of a group or supergroup chat.
type BotCommandScopeChatMember struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Type
	// Scope type, must be chat_member
	Type BotType `json:"type"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

func (t *BotCommandScopeChatMember) GetChatID() IntStr {
	var res IntStr
	if t == nil {
		return res
	}
	return t.ChatID
}

func (t *BotCommandScopeChatMember) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *BotCommandScopeChatMember) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserID
}

// BotCommandScopeDefault
// Represents the default scope of bot commands. Default commands are used if no commands with a
// narrower scope are specified for the user.
type BotCommandScopeDefault struct {
	// Type
	// Scope type, must be default
	Type BotType `json:"type"`
}

func (t *BotCommandScopeDefault) GetType() *BotType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// BotDescription
// This object represents the bot's description.
type BotDescription struct {
	// Description
	// The bot's description
	Description string `json:"description"`
}

func (t *BotDescription) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.Description
}

// BotName
// This object represents the bot's name.
type BotName struct {
	// Name
	// The bot's name
	Name string `json:"name"`
}

func (t *BotName) GetName() string {
	var res string
	if t == nil {
		return res
	}
	return t.Name
}

// BotShortDescription
// This object represents the bot's short description.
type BotShortDescription struct {
	// ShortDescription
	// The bot's short description
	ShortDescription string `json:"short_description"`
}

func (t *BotShortDescription) GetShortDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.ShortDescription
}

// CallbackGame
// A placeholder, currently holds no information. Use BotFather to set up your game.
type CallbackGame struct {
	// Score
	// New score, must be non-negative
	Score int64 `json:"score"`
	// UserID
	// User identifier
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID *int64 `json:"chat_id,omitempty"`
	// DisableEditMessage
	// Pass True if the game message should not be automatically edited to include the current
	// scoreboard
	DisableEditMessage *bool `json:"disable_edit_message,omitempty"`
	// Force
	// Pass True if the high score is allowed to decrease. This can be useful when fixing mistakes
	// or banning cheaters
	Force *bool `json:"force,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID *string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID *int64 `json:"message_id,omitempty"`
}

func (t *CallbackGame) GetChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ChatID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetDisableEditMessage() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableEditMessage; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetForce() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Force; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MessageID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackGame) GetScore() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Score
}

func (t *CallbackGame) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserID
}

// CallbackQuery
// This object represents an incoming callback query from a callback button in an inline keyboard.
// If the button that originated the query was attached to a message sent by the bot, the field
// message will be present. If the button was attached to a message sent via the bot (in inline
// mode), the field inline_message_id will be present. Exactly one of the fields data or
// game_short_name will be present.
type CallbackQuery struct {
	// ChatInstance
	// Global identifier, uniquely corresponding to the chat to which the message with the callback
	// button was sent. Useful for high scores in games.
	ChatInstance string `json:"chat_instance"`
	// From
	// Sender
	From User `json:"from"`
	// ID
	// Unique identifier for this query
	ID string `json:"id"`
	// Data
	// Data associated with the callback button. Be aware that the message originated the query can
	// contain no callback buttons with this data.
	Data *string `json:"data,omitempty"`
	// GameShortName
	// Short name of a Game to be returned, serves as the unique identifier for the game
	GameShortName *string `json:"game_short_name,omitempty"`
	// InlineMessageID
	// Identifier of the message sent via the bot in inline mode, that originated the query.
	InlineMessageID *string `json:"inline_message_id,omitempty"`
	// Message
	// Message with the callback button that originated the query. Note that message content and
	// message date will not be available if the message is too old
	Message *Message `json:"message,omitempty"`
}

func (t *CallbackQuery) GetChatInstance() string {
	var res string
	if t == nil {
		return res
	}
	return t.ChatInstance
}

func (t *CallbackQuery) GetData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Data; field != nil {
		return *field
	}
	return res
}

func (t *CallbackQuery) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *CallbackQuery) GetGameShortName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GameShortName; field != nil {
		return *field
	}
	return res
}

func (t *CallbackQuery) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *CallbackQuery) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

func (t *CallbackQuery) GetMessage() *Message {
	if t == nil {
		return nil
	}
	return t.Message
}

// Chat
// This object represents a chat.
type Chat struct {
	// ID
	// Unique identifier for this chat. This number may have more than 32 significant bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it has at
	// most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe
	// for storing this identifier.
	ID int64 `json:"id"`
	// Type
	// Type of chat, can be either "private", "group", "supergroup" or "channel"
	Type ChatType `json:"type"`
	// ActiveUsernames
	// If non-empty, the list of all active chat usernames; for private chats, supergroups and
	// channels. Returned only in getChat.
	ActiveUsernames []string `json:"active_usernames,omitempty"`
	// Bio
	// Bio of the other party in a private chat. Returned only in getChat.
	Bio *string `json:"bio,omitempty"`
	// CanSetStickerSet
	// True, if the bot can change the group sticker set. Returned only in getChat.
	CanSetStickerSet *bool `json:"can_set_sticker_set,omitempty"`
	// Description
	// Description, for groups, supergroups and channel chats. Returned only in getChat.
	Description *string `json:"description,omitempty"`
	// EmojiStatusCustomEmojiID
	// Custom emoji identifier of emoji status of the other party in a private chat. Returned only
	// in getChat.
	EmojiStatusCustomEmojiID *string `json:"emoji_status_custom_emoji_id,omitempty"`
	// FirstName
	// First name of the other party in a private chat
	FirstName *string `json:"first_name,omitempty"`
	// HasAggressiveAntiSpamEnabled
	// True, if aggressive anti-spam checks are enabled in the supergroup. The field is only
	// available to chat administrators. Returned only in getChat.
	HasAggressiveAntiSpamEnabled *bool `json:"has_aggressive_anti_spam_enabled,omitempty"`
	// HasHiddenMembers
	// True, if non-administrators can only get the list of bots and administrators in the chat.
	// Returned only in getChat.
	HasHiddenMembers *bool `json:"has_hidden_members,omitempty"`
	// HasPrivateForwards
	// True, if privacy settings of the other party in the private chat allows to use
	// tg://user?id=<user_id> links only in chats with the user. Returned only in getChat.
	HasPrivateForwards *bool `json:"has_private_forwards,omitempty"`
	// HasProtectedContent
	// True, if messages from the chat can't be forwarded to other chats. Returned only in getChat.
	HasProtectedContent *bool `json:"has_protected_content,omitempty"`
	// HasRestrictedVoiceAndVideoMessages
	// True, if the privacy settings of the other party restrict sending voice and video note
	// messages in the private chat. Returned only in getChat.
	HasRestrictedVoiceAndVideoMessages *bool `json:"has_restricted_voice_and_video_messages,omitempty"`
	// InviteLink
	// Primary invite link, for groups, supergroups and channel chats. Returned only in getChat.
	InviteLink *string `json:"invite_link,omitempty"`
	// IsForum
	// True, if the supergroup chat is a forum (has topics enabled)
	IsForum *bool `json:"is_forum,omitempty"`
	// JoinByRequest
	// True, if all users directly joining the supergroup need to be approved by supergroup
	// administrators. Returned only in getChat.
	JoinByRequest *bool `json:"join_by_request,omitempty"`
	// JoinToSendMessages
	// True, if users need to join the supergroup before they can send messages. Returned only in
	// getChat.
	JoinToSendMessages *bool `json:"join_to_send_messages,omitempty"`
	// LastName
	// Last name of the other party in a private chat
	LastName *string `json:"last_name,omitempty"`
	// LinkedChatID
	// Unique identifier for the linked chat, i.e. the discussion group identifier for a channel
	// and vice versa; for supergroups and channel chats. This identifier may be greater than 32
	// bits and some programming languages may have difficulty/silent defects in interpreting it.
	// But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type
	// are safe for storing this identifier. Returned only in getChat.
	LinkedChatID *int64 `json:"linked_chat_id,omitempty"`
	// Location
	// For supergroups, the location to which the supergroup is connected. Returned only in
	// getChat.
	Location *ChatLocation `json:"location,omitempty"`
	// MessageAutoDeleteTime
	// The time after which all messages sent to the chat will be automatically deleted; in
	// seconds. Returned only in getChat.
	MessageAutoDeleteTime *int64 `json:"message_auto_delete_time,omitempty"`
	// Permissions
	// Default chat member permissions, for groups and supergroups. Returned only in getChat.
	Permissions *ChatPermissions `json:"permissions,omitempty"`
	// Photo
	// Chat photo. Returned only in getChat.
	Photo *ChatPhoto `json:"photo,omitempty"`
	// PinnedMessage
	// The most recent pinned message (by sending date). Returned only in getChat.
	PinnedMessage *Message `json:"pinned_message,omitempty"`
	// SlowModeDelay
	// For supergroups, the minimum allowed delay between consecutive messages sent by each
	// unpriviledged user; in seconds. Returned only in getChat.
	SlowModeDelay *int64 `json:"slow_mode_delay,omitempty"`
	// StickerSetName
	// For supergroups, name of group sticker set. Returned only in getChat.
	StickerSetName *string `json:"sticker_set_name,omitempty"`
	// Title
	// Title, for supergroups, channels and group chats
	Title *string `json:"title,omitempty"`
	// Username
	// Username, for private chats, supergroups and channels if available
	Username *string `json:"username,omitempty"`
}

func (t *Chat) GetBio() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Bio; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetCanSetStickerSet() *bool {
	if t == nil {
		return nil
	}
	return t.CanSetStickerSet
}

func (t *Chat) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetEmojiStatusCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.EmojiStatusCustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetFirstName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FirstName; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetHasAggressiveAntiSpamEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.HasAggressiveAntiSpamEnabled
}

func (t *Chat) GetHasHiddenMembers() *bool {
	if t == nil {
		return nil
	}
	return t.HasHiddenMembers
}

func (t *Chat) GetHasPrivateForwards() *bool {
	if t == nil {
		return nil
	}
	return t.HasPrivateForwards
}

func (t *Chat) GetHasProtectedContent() *bool {
	if t == nil {
		return nil
	}
	return t.HasProtectedContent
}

func (t *Chat) GetHasRestrictedVoiceAndVideoMessages() *bool {
	if t == nil {
		return nil
	}
	return t.HasRestrictedVoiceAndVideoMessages
}

func (t *Chat) GetID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.ID
}

func (t *Chat) GetInviteLink() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InviteLink; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetIsForum() *bool {
	if t == nil {
		return nil
	}
	return t.IsForum
}

func (t *Chat) GetJoinByRequest() *bool {
	if t == nil {
		return nil
	}
	return t.JoinByRequest
}

func (t *Chat) GetJoinToSendMessages() *bool {
	if t == nil {
		return nil
	}
	return t.JoinToSendMessages
}

func (t *Chat) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetLinkedChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LinkedChatID; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetLocation() *ChatLocation {
	if t == nil {
		return nil
	}
	return t.Location
}

func (t *Chat) GetMessageAutoDeleteTime() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MessageAutoDeleteTime; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetPermissions() *ChatPermissions {
	if t == nil {
		return nil
	}
	return t.Permissions
}

func (t *Chat) GetPhoto() *ChatPhoto {
	if t == nil {
		return nil
	}
	return t.Photo
}

func (t *Chat) GetPinnedMessage() *Message {
	if t == nil {
		return nil
	}
	return t.PinnedMessage
}

func (t *Chat) GetSlowModeDelay() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.SlowModeDelay; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetStickerSetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.StickerSetName; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *Chat) GetType() *ChatType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *Chat) GetUsername() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Username; field != nil {
		return *field
	}
	return res
}

// ChatAdministratorRights
// Represents the rights of an administrator in a chat.
type ChatAdministratorRights struct {
	// CanChangeInfo
	// True, if the user is allowed to change the chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// CanDeleteMessages
	// True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`
	// CanInviteUsers
	// True, if the user is allowed to invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// CanManageChat
	// True, if the administrator can access the chat event log, chat statistics, message
	// statistics in channels, see channel members, see anonymous administrators in supergroups and
	// ignore slow mode. Implied by any other administrator privilege
	CanManageChat bool `json:"can_manage_chat"`
	// CanManageVideoChats
	// True, if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats"`
	// CanPromoteMembers
	// True, if the administrator can add new administrators with a subset of their own privileges
	// or demote administrators that they have promoted, directly or indirectly (promoted by
	// administrators that were appointed by the user)
	CanPromoteMembers bool `json:"can_promote_members"`
	// CanRestrictMembers
	// True, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members"`
	// IsAnonymous
	// True, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`
	// CanEditMessages
	// True, if the administrator can edit messages of other users and can pin messages; channels
	// only
	CanEditMessages *bool `json:"can_edit_messages,omitempty"`
	// CanManageTopics
	// True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups
	// only
	CanManageTopics *bool `json:"can_manage_topics,omitempty"`
	// CanPinMessages
	// True, if the user is allowed to pin messages; groups and supergroups only
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`
	// CanPostMessages
	// True, if the administrator can post in the channel; channels only
	CanPostMessages *bool `json:"can_post_messages,omitempty"`
}

func (t *ChatAdministratorRights) GetCanChangeInfo() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanChangeInfo
}

func (t *ChatAdministratorRights) GetCanDeleteMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanDeleteMessages
}

func (t *ChatAdministratorRights) GetCanEditMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanEditMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatAdministratorRights) GetCanInviteUsers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanInviteUsers
}

func (t *ChatAdministratorRights) GetCanManageChat() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanManageChat
}

func (t *ChatAdministratorRights) GetCanManageTopics() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanManageTopics; field != nil {
		return *field
	}
	return res
}

func (t *ChatAdministratorRights) GetCanManageVideoChats() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanManageVideoChats
}

func (t *ChatAdministratorRights) GetCanPinMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPinMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatAdministratorRights) GetCanPostMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPostMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatAdministratorRights) GetCanPromoteMembers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanPromoteMembers
}

func (t *ChatAdministratorRights) GetCanRestrictMembers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanRestrictMembers
}

func (t *ChatAdministratorRights) GetIsAnonymous() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnonymous
}

// ChatInviteLink
// Represents an invite link for a chat.
type ChatInviteLink struct {
	// CreatesJoinRequest
	// True, if users joining the chat via the link need to be approved by chat administrators
	CreatesJoinRequest bool `json:"creates_join_request"`
	// Creator
	// Creator of the link
	Creator User `json:"creator"`
	// InviteLink
	// The invite link. If the link was created by another chat administrator, then the second part
	// of the link will be replaced with "…".
	InviteLink string `json:"invite_link"`
	// IsPrimary
	// True, if the link is primary
	IsPrimary bool `json:"is_primary"`
	// IsRevoked
	// True, if the link is revoked
	IsRevoked bool `json:"is_revoked"`
	// ExpireDate
	// Point in time (Unix timestamp) when the link will expire or has been expired
	ExpireDate *int64 `json:"expire_date,omitempty"`
	// MemberLimit
	// The maximum number of users that can be members of the chat simultaneously after joining the
	// chat via this invite link; 1-99999
	MemberLimit *int64 `json:"member_limit,omitempty"`
	// Name
	// Invite link name
	Name *string `json:"name,omitempty"`
	// PendingJoinRequestCount
	// Number of pending join requests created using this link
	PendingJoinRequestCount *int64 `json:"pending_join_request_count,omitempty"`
}

func (t *ChatInviteLink) GetCreatesJoinRequest() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CreatesJoinRequest
}

func (t *ChatInviteLink) GetCreator() *User {
	if t == nil {
		return nil
	}
	return &t.Creator
}

func (t *ChatInviteLink) GetExpireDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ExpireDate; field != nil {
		return *field
	}
	return res
}

func (t *ChatInviteLink) GetInviteLink() string {
	var res string
	if t == nil {
		return res
	}
	return t.InviteLink
}

func (t *ChatInviteLink) GetIsPrimary() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsPrimary
}

func (t *ChatInviteLink) GetIsRevoked() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsRevoked
}

func (t *ChatInviteLink) GetMemberLimit() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MemberLimit; field != nil {
		return *field
	}
	return res
}

func (t *ChatInviteLink) GetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Name; field != nil {
		return *field
	}
	return res
}

func (t *ChatInviteLink) GetPendingJoinRequestCount() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PendingJoinRequestCount; field != nil {
		return *field
	}
	return res
}

// ChatJoinRequest
// Represents a join request sent to a chat.
type ChatJoinRequest struct {
	// Chat
	// Chat to which the request was sent
	Chat Chat `json:"chat"`
	// Date
	// Date the request was sent in Unix time
	Date int64 `json:"date"`
	// From
	// User that sent the join request
	From User `json:"from"`
	// UserChatID
	// Identifier of a private chat with the user who sent the join request. This number may have
	// more than 32 significant bits and some programming languages may have difficulty/silent
	// defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or
	// double-precision float type are safe for storing this identifier. The bot can use this
	// identifier for 24 hours to send messages until the join request is processed, assuming no
	// other administrator contacted the user.
	UserChatID int64 `json:"user_chat_id"`
	// Bio
	// Bio of the user.
	Bio *string `json:"bio,omitempty"`
	// InviteLink
	// Chat invite link that was used by the user to send the join request
	InviteLink *ChatInviteLink `json:"invite_link,omitempty"`
}

func (t *ChatJoinRequest) GetBio() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Bio; field != nil {
		return *field
	}
	return res
}

func (t *ChatJoinRequest) GetChat() *Chat {
	if t == nil {
		return nil
	}
	return &t.Chat
}

func (t *ChatJoinRequest) GetDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Date
}

func (t *ChatJoinRequest) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *ChatJoinRequest) GetInviteLink() *ChatInviteLink {
	if t == nil {
		return nil
	}
	return t.InviteLink
}

func (t *ChatJoinRequest) GetUserChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserChatID
}

// ChatLocation
// Represents a location to which a chat is connected.
type ChatLocation struct {
	// Address
	// Location address; 1-64 characters, as defined by the chat owner
	Address string `json:"address"`
	// Location
	// The location to which the supergroup is connected. Can't be a live location.
	Location Location `json:"location"`
}

func (t *ChatLocation) GetAddress() string {
	var res string
	if t == nil {
		return res
	}
	return t.Address
}

func (t *ChatLocation) GetLocation() *Location {
	if t == nil {
		return nil
	}
	return &t.Location
}

// ChatMember
// This object contains information about one member of a chat. Currently, the following 6 types of
// chat members are supported:
type ChatMember struct {
	// IsAnonymous
	// True, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`
	// Status
	// The member's status in the chat, always "creator"
	Status string `json:"status"`
	// User
	// Information about the user
	User User `json:"user"`
	// CustomTitle
	// Custom title for this user
	CustomTitle *string `json:"custom_title,omitempty"`
}

func (t *ChatMember) GetCustomTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomTitle; field != nil {
		return *field
	}
	return res
}

func (t *ChatMember) GetIsAnonymous() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnonymous
}

func (t *ChatMember) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMember) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberAdministrator
// Represents a chat member that has some additional privileges.
type ChatMemberAdministrator struct {
	// CanBeEdited
	// True, if the bot is allowed to edit administrator privileges of that user
	CanBeEdited bool `json:"can_be_edited"`
	// CanChangeInfo
	// True, if the user is allowed to change the chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// CanDeleteMessages
	// True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages"`
	// CanInviteUsers
	// True, if the user is allowed to invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// CanManageChat
	// True, if the administrator can access the chat event log, chat statistics, message
	// statistics in channels, see channel members, see anonymous administrators in supergroups and
	// ignore slow mode. Implied by any other administrator privilege
	CanManageChat bool `json:"can_manage_chat"`
	// CanManageVideoChats
	// True, if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats"`
	// CanPromoteMembers
	// True, if the administrator can add new administrators with a subset of their own privileges
	// or demote administrators that they have promoted, directly or indirectly (promoted by
	// administrators that were appointed by the user)
	CanPromoteMembers bool `json:"can_promote_members"`
	// CanRestrictMembers
	// True, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members"`
	// IsAnonymous
	// True, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`
	// Status
	// The member's status in the chat, always "administrator"
	Status string `json:"status"`
	// User
	// Information about the user
	User User `json:"user"`
	// CanEditMessages
	// True, if the administrator can edit messages of other users and can pin messages; channels
	// only
	CanEditMessages *bool `json:"can_edit_messages,omitempty"`
	// CanManageTopics
	// True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups
	// only
	CanManageTopics *bool `json:"can_manage_topics,omitempty"`
	// CanPinMessages
	// True, if the user is allowed to pin messages; groups and supergroups only
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`
	// CanPostMessages
	// True, if the administrator can post in the channel; channels only
	CanPostMessages *bool `json:"can_post_messages,omitempty"`
	// CustomTitle
	// Custom title for this user
	CustomTitle *string `json:"custom_title,omitempty"`
}

func (t *ChatMemberAdministrator) GetCanBeEdited() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanBeEdited
}

func (t *ChatMemberAdministrator) GetCanChangeInfo() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanChangeInfo
}

func (t *ChatMemberAdministrator) GetCanDeleteMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanDeleteMessages
}

func (t *ChatMemberAdministrator) GetCanEditMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanEditMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMemberAdministrator) GetCanInviteUsers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanInviteUsers
}

func (t *ChatMemberAdministrator) GetCanManageChat() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanManageChat
}

func (t *ChatMemberAdministrator) GetCanManageTopics() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanManageTopics; field != nil {
		return *field
	}
	return res
}

func (t *ChatMemberAdministrator) GetCanManageVideoChats() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanManageVideoChats
}

func (t *ChatMemberAdministrator) GetCanPinMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPinMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMemberAdministrator) GetCanPostMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPostMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatMemberAdministrator) GetCanPromoteMembers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanPromoteMembers
}

func (t *ChatMemberAdministrator) GetCanRestrictMembers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanRestrictMembers
}

func (t *ChatMemberAdministrator) GetCustomTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomTitle; field != nil {
		return *field
	}
	return res
}

func (t *ChatMemberAdministrator) GetIsAnonymous() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnonymous
}

func (t *ChatMemberAdministrator) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMemberAdministrator) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberBanned
// Represents a chat member that was banned in the chat and can't return to the chat or view chat
// messages.
type ChatMemberBanned struct {
	// Status
	// The member's status in the chat, always "kicked"
	Status string `json:"status"`
	// UntilDate
	// Date when restrictions will be lifted for this user; unix time. If 0, then the user is
	// banned forever
	UntilDate int64 `json:"until_date"`
	// User
	// Information about the user
	User User `json:"user"`
}

func (t *ChatMemberBanned) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMemberBanned) GetUntilDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UntilDate
}

func (t *ChatMemberBanned) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberLeft
// Represents a chat member that isn't currently a member of the chat, but may join it themselves.
type ChatMemberLeft struct {
	// Status
	// The member's status in the chat, always "left"
	Status string `json:"status"`
	// User
	// Information about the user
	User User `json:"user"`
}

func (t *ChatMemberLeft) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMemberLeft) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberMember
// Represents a chat member that has no additional privileges or restrictions.
type ChatMemberMember struct {
	// Status
	// The member's status in the chat, always "member"
	Status string `json:"status"`
	// User
	// Information about the user
	User User `json:"user"`
}

func (t *ChatMemberMember) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMemberMember) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberOwner
// Represents a chat member that owns the chat and has all administrator privileges.
type ChatMemberOwner struct {
	// IsAnonymous
	// True, if the user's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous"`
	// Status
	// The member's status in the chat, always "creator"
	Status string `json:"status"`
	// User
	// Information about the user
	User User `json:"user"`
	// CustomTitle
	// Custom title for this user
	CustomTitle *string `json:"custom_title,omitempty"`
}

func (t *ChatMemberOwner) GetCustomTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomTitle; field != nil {
		return *field
	}
	return res
}

func (t *ChatMemberOwner) GetIsAnonymous() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnonymous
}

func (t *ChatMemberOwner) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMemberOwner) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberRestricted
// Represents a chat member that is under certain restrictions in the chat. Supergroups only.
type ChatMemberRestricted struct {
	// CanAddWebPagePreviews
	// True, if the user is allowed to add web page previews to their messages
	CanAddWebPagePreviews bool `json:"can_add_web_page_previews"`
	// CanChangeInfo
	// True, if the user is allowed to change the chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info"`
	// CanInviteUsers
	// True, if the user is allowed to invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users"`
	// CanManageTopics
	// True, if the user is allowed to create forum topics
	CanManageTopics bool `json:"can_manage_topics"`
	// CanPinMessages
	// True, if the user is allowed to pin messages
	CanPinMessages bool `json:"can_pin_messages"`
	// CanSendAudios
	// True, if the user is allowed to send audios
	CanSendAudios bool `json:"can_send_audios"`
	// CanSendDocuments
	// True, if the user is allowed to send documents
	CanSendDocuments bool `json:"can_send_documents"`
	// CanSendMessages
	// True, if the user is allowed to send text messages, contacts, invoices, locations and venues
	CanSendMessages bool `json:"can_send_messages"`
	// CanSendOtherMessages
	// True, if the user is allowed to send animations, games, stickers and use inline bots
	CanSendOtherMessages bool `json:"can_send_other_messages"`
	// CanSendPhotos
	// True, if the user is allowed to send photos
	CanSendPhotos bool `json:"can_send_photos"`
	// CanSendPolls
	// True, if the user is allowed to send polls
	CanSendPolls bool `json:"can_send_polls"`
	// CanSendVideoNotes
	// True, if the user is allowed to send video notes
	CanSendVideoNotes bool `json:"can_send_video_notes"`
	// CanSendVideos
	// True, if the user is allowed to send videos
	CanSendVideos bool `json:"can_send_videos"`
	// CanSendVoiceNotes
	// True, if the user is allowed to send voice notes
	CanSendVoiceNotes bool `json:"can_send_voice_notes"`
	// IsMember
	// True, if the user is a member of the chat at the moment of the request
	IsMember bool `json:"is_member"`
	// Status
	// The member's status in the chat, always "restricted"
	Status string `json:"status"`
	// UntilDate
	// Date when restrictions will be lifted for this user; unix time. If 0, then the user is
	// restricted forever
	UntilDate int64 `json:"until_date"`
	// User
	// Information about the user
	User User `json:"user"`
}

func (t *ChatMemberRestricted) GetCanAddWebPagePreviews() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanAddWebPagePreviews
}

func (t *ChatMemberRestricted) GetCanChangeInfo() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanChangeInfo
}

func (t *ChatMemberRestricted) GetCanInviteUsers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanInviteUsers
}

func (t *ChatMemberRestricted) GetCanManageTopics() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanManageTopics
}

func (t *ChatMemberRestricted) GetCanPinMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanPinMessages
}

func (t *ChatMemberRestricted) GetCanSendAudios() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendAudios
}

func (t *ChatMemberRestricted) GetCanSendDocuments() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendDocuments
}

func (t *ChatMemberRestricted) GetCanSendMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendMessages
}

func (t *ChatMemberRestricted) GetCanSendOtherMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendOtherMessages
}

func (t *ChatMemberRestricted) GetCanSendPhotos() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendPhotos
}

func (t *ChatMemberRestricted) GetCanSendPolls() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendPolls
}

func (t *ChatMemberRestricted) GetCanSendVideoNotes() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendVideoNotes
}

func (t *ChatMemberRestricted) GetCanSendVideos() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendVideos
}

func (t *ChatMemberRestricted) GetCanSendVoiceNotes() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.CanSendVoiceNotes
}

func (t *ChatMemberRestricted) GetIsMember() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsMember
}

func (t *ChatMemberRestricted) GetStatus() string {
	var res string
	if t == nil {
		return res
	}
	return t.Status
}

func (t *ChatMemberRestricted) GetUntilDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UntilDate
}

func (t *ChatMemberRestricted) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// ChatMemberUpdated
// This object represents changes in the status of a chat member.
type ChatMemberUpdated struct {
	// Chat
	// Chat the user belongs to
	Chat Chat `json:"chat"`
	// Date
	// Date the change was done in Unix time
	Date int64 `json:"date"`
	// From
	// Performer of the action, which resulted in the change
	From User `json:"from"`
	// NewChatMember
	// New information about the chat member
	NewChatMember ChatMember `json:"new_chat_member"`
	// OldChatMember
	// Previous information about the chat member
	OldChatMember ChatMember `json:"old_chat_member"`
	// InviteLink
	// Chat invite link, which was used by the user to join the chat; for joining by invite link
	// events only.
	InviteLink *ChatInviteLink `json:"invite_link,omitempty"`
	// ViaChatFolderInviteLink
	// True, if the user joined the chat via a chat folder invite link
	ViaChatFolderInviteLink *bool `json:"via_chat_folder_invite_link,omitempty"`
}

func (t *ChatMemberUpdated) GetChat() *Chat {
	if t == nil {
		return nil
	}
	return &t.Chat
}

func (t *ChatMemberUpdated) GetDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Date
}

func (t *ChatMemberUpdated) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *ChatMemberUpdated) GetInviteLink() *ChatInviteLink {
	if t == nil {
		return nil
	}
	return t.InviteLink
}

func (t *ChatMemberUpdated) GetNewChatMember() *ChatMember {
	if t == nil {
		return nil
	}
	return &t.NewChatMember
}

func (t *ChatMemberUpdated) GetOldChatMember() *ChatMember {
	if t == nil {
		return nil
	}
	return &t.OldChatMember
}

func (t *ChatMemberUpdated) GetViaChatFolderInviteLink() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ViaChatFolderInviteLink; field != nil {
		return *field
	}
	return res
}

// ChatPermissions
// Describes actions that a non-administrator user is allowed to take in a chat.
type ChatPermissions struct {
	// CanAddWebPagePreviews
	// True, if the user is allowed to add web page previews to their messages
	CanAddWebPagePreviews *bool `json:"can_add_web_page_previews,omitempty"`
	// CanChangeInfo
	// True, if the user is allowed to change the chat title, photo and other settings. Ignored in
	// public supergroups
	CanChangeInfo *bool `json:"can_change_info,omitempty"`
	// CanInviteUsers
	// True, if the user is allowed to invite new users to the chat
	CanInviteUsers *bool `json:"can_invite_users,omitempty"`
	// CanManageTopics
	// True, if the user is allowed to create forum topics. If omitted defaults to the value of
	// can_pin_messages
	CanManageTopics *bool `json:"can_manage_topics,omitempty"`
	// CanPinMessages
	// True, if the user is allowed to pin messages. Ignored in public supergroups
	CanPinMessages *bool `json:"can_pin_messages,omitempty"`
	// CanSendAudios
	// True, if the user is allowed to send audios
	CanSendAudios *bool `json:"can_send_audios,omitempty"`
	// CanSendDocuments
	// True, if the user is allowed to send documents
	CanSendDocuments *bool `json:"can_send_documents,omitempty"`
	// CanSendMessages
	// True, if the user is allowed to send text messages, contacts, invoices, locations and venues
	CanSendMessages *bool `json:"can_send_messages,omitempty"`
	// CanSendOtherMessages
	// True, if the user is allowed to send animations, games, stickers and use inline bots
	CanSendOtherMessages *bool `json:"can_send_other_messages,omitempty"`
	// CanSendPhotos
	// True, if the user is allowed to send photos
	CanSendPhotos *bool `json:"can_send_photos,omitempty"`
	// CanSendPolls
	// True, if the user is allowed to send polls
	CanSendPolls *bool `json:"can_send_polls,omitempty"`
	// CanSendVideoNotes
	// True, if the user is allowed to send video notes
	CanSendVideoNotes *bool `json:"can_send_video_notes,omitempty"`
	// CanSendVideos
	// True, if the user is allowed to send videos
	CanSendVideos *bool `json:"can_send_videos,omitempty"`
	// CanSendVoiceNotes
	// True, if the user is allowed to send voice notes
	CanSendVoiceNotes *bool `json:"can_send_voice_notes,omitempty"`
}

func (t *ChatPermissions) GetCanAddWebPagePreviews() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanAddWebPagePreviews; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanChangeInfo() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanChangeInfo; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanInviteUsers() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanInviteUsers; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanManageTopics() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanManageTopics; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanPinMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanPinMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendAudios() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendAudios; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendDocuments() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendDocuments; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendOtherMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendOtherMessages; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendPhotos() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendPhotos; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendPolls() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendPolls; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendVideoNotes() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendVideoNotes; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendVideos() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendVideos; field != nil {
		return *field
	}
	return res
}

func (t *ChatPermissions) GetCanSendVoiceNotes() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanSendVoiceNotes; field != nil {
		return *field
	}
	return res
}

// ChatPhoto
// This object represents a chat photo.
type ChatPhoto struct {
	// BigFileID
	// File identifier of big (640x640) chat photo. This file_id can be used only for photo
	// download and only for as long as the photo is not changed.
	BigFileID string `json:"big_file_id"`
	// BigFileUniqueID
	// Unique file identifier of big (640x640) chat photo, which is supposed to be the same over
	// time and for different bots. Can't be used to download or reuse the file.
	BigFileUniqueID string `json:"big_file_unique_id"`
	// SmallFileID
	// File identifier of small (160x160) chat photo. This file_id can be used only for photo
	// download and only for as long as the photo is not changed.
	SmallFileID string `json:"small_file_id"`
	// SmallFileUniqueID
	// Unique file identifier of small (160x160) chat photo, which is supposed to be the same over
	// time and for different bots. Can't be used to download or reuse the file.
	SmallFileUniqueID string `json:"small_file_unique_id"`
}

func (t *ChatPhoto) GetBigFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.BigFileID
}

func (t *ChatPhoto) GetBigFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.BigFileUniqueID
}

func (t *ChatPhoto) GetSmallFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.SmallFileID
}

func (t *ChatPhoto) GetSmallFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.SmallFileUniqueID
}

// ChatShared
// This object contains information about the chat whose identifier was shared with the bot using a
// KeyboardButtonRequestChat button.
type ChatShared struct {
	// ChatID
	// Identifier of the shared chat. This number may have more than 32 significant bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it has at
	// most 52 significant bits, so a 64-bit integer or double-precision float type are safe for
	// storing this identifier. The bot may not have access to the chat and could be unable to use
	// this identifier, unless the chat is already known to the bot by some other means.
	ChatID int64 `json:"chat_id"`
	// RequestID
	// Identifier of the request
	RequestID int64 `json:"request_id"`
}

func (t *ChatShared) GetChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.ChatID
}

func (t *ChatShared) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

// ChosenInlineResult
// Represents a result of an inline query that was chosen by the user and sent to their chat
// partner.
type ChosenInlineResult struct {
	// From
	// The user that chose the result
	From User `json:"from"`
	// Query
	// The query that was used to obtain the result
	Query string `json:"query"`
	// ResultID
	// The unique identifier for the result that was chosen
	ResultID string `json:"result_id"`
	// InlineMessageID
	// Identifier of the sent inline message. Available only if there is an inline keyboard
	// attached to the message. Will be also received in callback queries and can be used to edit
	// the message.
	InlineMessageID *string `json:"inline_message_id,omitempty"`
	// Location
	// Sender location, only for bots that require user location
	Location *Location `json:"location,omitempty"`
}

func (t *ChosenInlineResult) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *ChosenInlineResult) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

func (t *ChosenInlineResult) GetLocation() *Location {
	if t == nil {
		return nil
	}
	return t.Location
}

func (t *ChosenInlineResult) GetQuery() string {
	var res string
	if t == nil {
		return res
	}
	return t.Query
}

func (t *ChosenInlineResult) GetResultID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ResultID
}

// Contact
// This object represents a phone contact.
type Contact struct {
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// LastName
	// Contact's last name
	LastName *string `json:"last_name,omitempty"`
	// UserID
	// Contact's user identifier in Telegram. This number may have more than 32 significant bits
	// and some programming languages may have difficulty/silent defects in interpreting it. But it
	// has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe
	// for storing this identifier.
	UserID *int64 `json:"user_id,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard
	Vcard *string `json:"vcard,omitempty"`
}

func (t *Contact) GetFirstName() string {
	var res string
	if t == nil {
		return res
	}
	return t.FirstName
}

func (t *Contact) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *Contact) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	return t.PhoneNumber
}

func (t *Contact) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.UserID; field != nil {
		return *field
	}
	return res
}

func (t *Contact) GetVcard() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Vcard; field != nil {
		return *field
	}
	return res
}

// Dice
// This object represents an animated emoji that displays a random value.
type Dice struct {
	// Emoji
	// Emoji on which the dice throw animation is based
	Emoji string `json:"emoji"`
	// Value
	// Value of the dice, 1-6 for "", "" and "" base emoji, 1-5 for "" and "" base emoji, 1-64 for
	// "" base emoji
	Value int64 `json:"value"`
}

func (t *Dice) GetEmoji() string {
	var res string
	if t == nil {
		return res
	}
	return t.Emoji
}

func (t *Dice) GetValue() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Value
}

// Document
// This object represents a general file (as opposed to photos, voice messages and audio files).
type Document struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FileName
	// Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`
	// FileSize
	// File size in bytes. It can be bigger than 2^31 and some programming languages may have
	// difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a
	// signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Thumbnail
	// Document thumbnail as defined by sender
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *Document) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Document) GetFileName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FileName; field != nil {
		return *field
	}
	return res
}

func (t *Document) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Document) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Document) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Document) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

// EncryptedCredentials
// Describes data required for decrypting and authenticating EncryptedPassportElement. See the
// Telegram Passport Documentation for a complete description of the data decryption and
// authentication processes.
type EncryptedCredentials struct {
	// Data
	// Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and
	// secrets required for EncryptedPassportElement decryption and authentication
	Data string `json:"data"`
	// Hash
	// Base64-encoded data hash for data authentication
	Hash string `json:"hash"`
	// Secret
	// Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption
	Secret string `json:"secret"`
}

func (t *EncryptedCredentials) GetData() string {
	var res string
	if t == nil {
		return res
	}
	return t.Data
}

func (t *EncryptedCredentials) GetHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.Hash
}

func (t *EncryptedCredentials) GetSecret() string {
	var res string
	if t == nil {
		return res
	}
	return t.Secret
}

// EncryptedPassportElement
// Describes documents or other Telegram Passport elements shared with the bot by the user.
type EncryptedPassportElement struct {
	// Hash
	// Base64-encoded element hash for using in PassportElementErrorUnspecified
	Hash string `json:"hash"`
	// Type
	// Element type. One of "personal_details", "passport", "driver_license", "identity_card",
	// "internal_passport", "address", "utility_bill", "bank_statement", "rental_agreement",
	// "passport_registration", "temporary_registration", "phone_number", "email".
	Type EncryptedType `json:"type"`
	// Data
	// Base64-encoded encrypted Telegram Passport element data provided by the user, available for
	// "personal_details", "passport", "driver_license", "identity_card", "internal_passport" and
	// "address" types. Can be decrypted and verified using the accompanying EncryptedCredentials.
	Data *string `json:"data,omitempty"`
	// Email
	// User's verified email address, available only for "email" type
	Email *string `json:"email,omitempty"`
	// Files
	// Array of encrypted files with documents provided by the user, available for "utility_bill",
	// "bank_statement", "rental_agreement", "passport_registration" and "temporary_registration"
	// types. Files can be decrypted and verified using the accompanying EncryptedCredentials.
	Files []PassportFile `json:"files,omitempty"`
	// FrontSide
	// Encrypted file with the front side of the document, provided by the user. Available for
	// "passport", "driver_license", "identity_card" and "internal_passport". The file can be
	// decrypted and verified using the accompanying EncryptedCredentials.
	FrontSide *PassportFile `json:"front_side,omitempty"`
	// PhoneNumber
	// User's verified phone number, available only for "phone_number" type
	PhoneNumber *string `json:"phone_number,omitempty"`
	// ReverseSide
	// Encrypted file with the reverse side of the document, provided by the user. Available for
	// "driver_license" and "identity_card". The file can be decrypted and verified using the
	// accompanying EncryptedCredentials.
	ReverseSide *PassportFile `json:"reverse_side,omitempty"`
	// Selfie
	// Encrypted file with the selfie of the user holding a document, provided by the user;
	// available for "passport", "driver_license", "identity_card" and "internal_passport". The
	// file can be decrypted and verified using the accompanying EncryptedCredentials.
	Selfie *PassportFile `json:"selfie,omitempty"`
	// Translation
	// Array of encrypted files with translated versions of documents provided by the user.
	// Available if requested for "passport", "driver_license", "identity_card",
	// "internal_passport", "utility_bill", "bank_statement", "rental_agreement",
	// "passport_registration" and "temporary_registration" types. Files can be decrypted and
	// verified using the accompanying EncryptedCredentials.
	Translation []PassportFile `json:"translation,omitempty"`
}

func (t *EncryptedPassportElement) GetData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Data; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetEmail() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Email; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetFrontSide() *PassportFile {
	if t == nil {
		return nil
	}
	return t.FrontSide
}

func (t *EncryptedPassportElement) GetHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.Hash
}

func (t *EncryptedPassportElement) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *EncryptedPassportElement) GetReverseSide() *PassportFile {
	if t == nil {
		return nil
	}
	return t.ReverseSide
}

func (t *EncryptedPassportElement) GetSelfie() *PassportFile {
	if t == nil {
		return nil
	}
	return t.Selfie
}

func (t *EncryptedPassportElement) GetType() *EncryptedType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// File
// This object represents a file ready to be downloaded. The file can be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be
// valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile.
type File struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FilePath
	// File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file.
	FilePath *string `json:"file_path,omitempty"`
	// FileSize
	// File size in bytes. It can be bigger than 2^31 and some programming languages may have
	// difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a
	// signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int64 `json:"file_size,omitempty"`
}

func (t *File) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *File) GetFilePath() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FilePath; field != nil {
		return *field
	}
	return res
}

func (t *File) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *File) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

// ForceReply
// Upon receiving a message with this object, Telegram clients will display a reply interface to
// the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be
// extremely useful if you want to create user-friendly step-by-step interfaces without having to
// sacrifice privacy mode.
type ForceReply struct {
	// ForceReply
	// Shows reply interface to the user, as if they manually selected the bot's message and tapped
	// 'Reply'
	ForceReply bool `json:"force_reply"`
	// InputFieldPlaceholder
	// The placeholder to be shown in the input field when the reply is active; 1-64 characters
	InputFieldPlaceholder *string `json:"input_field_placeholder,omitempty"`
	// Selective
	// Use this parameter if you want to force reply from specific users only. Targets: 1) users
	// that are @mentioned in the text of the Message object; 2) if the bot's message is a reply
	// (has reply_to_message_id), sender of the original message.
	Selective *bool `json:"selective,omitempty"`
}

func (t *ForceReply) GetForceReply() *bool {
	if t == nil {
		return nil
	}
	return &t.ForceReply
}

func (t *ForceReply) GetInputFieldPlaceholder() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InputFieldPlaceholder; field != nil {
		return *field
	}
	return res
}

func (t *ForceReply) GetSelective() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Selective; field != nil {
		return *field
	}
	return res
}

// ForumTopic
// This object represents a forum topic.
type ForumTopic struct {
	// IconColor
	// Color of the topic icon in RGB format
	IconColor int64 `json:"icon_color"`
	// MessageThreadID
	// Unique identifier of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`
	// Name
	// Name of the topic
	Name string `json:"name"`
	// IconCustomEmojiID
	// Unique identifier of the custom emoji shown as the topic icon
	IconCustomEmojiID *string `json:"icon_custom_emoji_id,omitempty"`
}

func (t *ForumTopic) GetIconColor() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.IconColor
}

func (t *ForumTopic) GetIconCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.IconCustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *ForumTopic) GetMessageThreadID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.MessageThreadID
}

func (t *ForumTopic) GetName() string {
	var res string
	if t == nil {
		return res
	}
	return t.Name
}

// ForumTopicClosed
// This object represents a service message about a forum topic closed in the chat. Currently holds
// no information.
type ForumTopicClosed struct {
	// IconCustomEmojiID
	// New identifier of the custom emoji shown as the topic icon, if it was edited; an empty
	// string if the icon was removed
	IconCustomEmojiID *string `json:"icon_custom_emoji_id,omitempty"`
	// Name
	// New name of the topic, if it was edited
	Name *string `json:"name,omitempty"`
}

func (t *ForumTopicClosed) GetIconCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.IconCustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *ForumTopicClosed) GetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Name; field != nil {
		return *field
	}
	return res
}

// ForumTopicCreated
// This object represents a service message about a new forum topic created in the chat.
type ForumTopicCreated struct {
	// IconColor
	// Color of the topic icon in RGB format
	IconColor int64 `json:"icon_color"`
	// Name
	// Name of the topic
	Name string `json:"name"`
	// IconCustomEmojiID
	// Unique identifier of the custom emoji shown as the topic icon
	IconCustomEmojiID *string `json:"icon_custom_emoji_id,omitempty"`
}

func (t *ForumTopicCreated) GetIconColor() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.IconColor
}

func (t *ForumTopicCreated) GetIconCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.IconCustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *ForumTopicCreated) GetName() string {
	var res string
	if t == nil {
		return res
	}
	return t.Name
}

// ForumTopicEdited
// This object represents a service message about an edited forum topic.
type ForumTopicEdited struct {
	// IconCustomEmojiID
	// New identifier of the custom emoji shown as the topic icon, if it was edited; an empty
	// string if the icon was removed
	IconCustomEmojiID *string `json:"icon_custom_emoji_id,omitempty"`
	// Name
	// New name of the topic, if it was edited
	Name *string `json:"name,omitempty"`
}

func (t *ForumTopicEdited) GetIconCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.IconCustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *ForumTopicEdited) GetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Name; field != nil {
		return *field
	}
	return res
}

// ForumTopicReopened
// This object represents a service message about a forum topic reopened in the chat. Currently
// holds no information.
type ForumTopicReopened struct {
	// RequestID
	// Identifier of the request
	RequestID int64 `json:"request_id"`
	// UserID
	// Identifier of the shared user. This number may have more than 32 significant bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it has at
	// most 52 significant bits, so a 64-bit integer or double-precision float type are safe for
	// storing this identifier. The bot may not have access to the user and could be unable to use
	// this identifier, unless the user is already known to the bot by some other means.
	UserID int64 `json:"user_id"`
}

func (t *ForumTopicReopened) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

func (t *ForumTopicReopened) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserID
}

// Game
// This object represents a game. Use BotFather to create and edit games, their short names will
// act as unique identifiers.
type Game struct {
	// Description
	// Description of the game
	Description string `json:"description"`
	// Photo
	// Photo that will be displayed in the game message in chats.
	Photo []PhotoSize `json:"photo"`
	// Title
	// Title of the game
	Title string `json:"title"`
	// Animation
	// Animation that will be displayed in the game message in chats. Upload via BotFather
	Animation *Animation `json:"animation,omitempty"`
	// Text
	// Brief description of the game or high scores included in the game message. Can be
	// automatically edited to include current high scores for the game when the bot calls
	// setGameScore, or manually edited using editMessageText. 0-4096 characters.
	Text *string `json:"text,omitempty"`
	// TextEntities
	// Special entities that appear in text, such as usernames, URLs, bot commands, etc.
	TextEntities []MessageEntity `json:"text_entities,omitempty"`
}

func (t *Game) GetAnimation() *Animation {
	if t == nil {
		return nil
	}
	return t.Animation
}

func (t *Game) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.Description
}

func (t *Game) GetText() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Text; field != nil {
		return *field
	}
	return res
}

func (t *Game) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// GameHighScore
// This object represents one row of the high scores table for a game.
type GameHighScore struct {
	// Position
	// Position in high score table for the game
	Position int64 `json:"position"`
	// Score
	// Score
	Score int64 `json:"score"`
	// User
	// User
	User User `json:"user"`
}

func (t *GameHighScore) GetPosition() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Position
}

func (t *GameHighScore) GetScore() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Score
}

func (t *GameHighScore) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// Games
// Your bot can offer users HTML5 games to play solo or to compete against each other in groups and
// one-on-one chats. Create games via @BotFather using the /newgame command. Please note that this
// kind of power requires responsibility: you will need to accept the terms for each game that your
// bots will be offering.
type Games struct {
	// ChatID
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`
	// GameShortName
	// Short name of the game, serves as the unique identifier for the game. Set up your games via
	// @BotFather.
	GameShortName string `json:"game_short_name"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID *int64 `json:"message_thread_id,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will
	// be shown. If not empty, the first button must launch the game.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID *int64 `json:"reply_to_message_id,omitempty"`
}

func (t *Games) GetAllowSendingWithoutReply() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.AllowSendingWithoutReply; field != nil {
		return *field
	}
	return res
}

func (t *Games) GetChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.ChatID
}

func (t *Games) GetDisableNotification() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableNotification; field != nil {
		return *field
	}
	return res
}

func (t *Games) GetGameShortName() string {
	var res string
	if t == nil {
		return res
	}
	return t.GameShortName
}

func (t *Games) GetMessageThreadID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MessageThreadID; field != nil {
		return *field
	}
	return res
}

func (t *Games) GetProtectContent() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ProtectContent; field != nil {
		return *field
	}
	return res
}

func (t *Games) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *Games) GetReplyToMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ReplyToMessageID; field != nil {
		return *field
	}
	return res
}

// GeneralForumTopicHidden
// This object represents a service message about General forum topic hidden in the chat. Currently
// holds no information.
type GeneralForumTopicHidden struct {
	// RequestID
	// Identifier of the request
	RequestID int64 `json:"request_id"`
	// UserID
	// Identifier of the shared user. This number may have more than 32 significant bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it has at
	// most 52 significant bits, so a 64-bit integer or double-precision float type are safe for
	// storing this identifier. The bot may not have access to the user and could be unable to use
	// this identifier, unless the user is already known to the bot by some other means.
	UserID int64 `json:"user_id"`
}

func (t *GeneralForumTopicHidden) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

func (t *GeneralForumTopicHidden) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserID
}

// GeneralForumTopicUnhidden
// This object represents a service message about General forum topic unhidden in the chat.
// Currently holds no information.
type GeneralForumTopicUnhidden struct {
	// RequestID
	// Identifier of the request
	RequestID int64 `json:"request_id"`
	// UserID
	// Identifier of the shared user. This number may have more than 32 significant bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it has at
	// most 52 significant bits, so a 64-bit integer or double-precision float type are safe for
	// storing this identifier. The bot may not have access to the user and could be unable to use
	// this identifier, unless the user is already known to the bot by some other means.
	UserID int64 `json:"user_id"`
}

func (t *GeneralForumTopicUnhidden) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

func (t *GeneralForumTopicUnhidden) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserID
}

// InlineKeyboardButton
// This object represents one button of an inline keyboard. You must use exactly one of the
// optional fields.
type InlineKeyboardButton struct {
	// Text
	// Label text on the button
	Text string `json:"text"`
	// CallbackData
	// Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes
	CallbackData *string `json:"callback_data,omitempty"`
	// CallbackGame
	// Description of the game that will be launched when the user presses the button.NOTE: This
	// type of button must always be the first button in the first row.
	CallbackGame *CallbackGame `json:"callback_game,omitempty"`
	// LoginURL
	// An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the
	// Telegram Login Widget.
	LoginURL *LoginURL `json:"login_url,omitempty"`
	// Pay
	// Specify True, to send a Pay button.NOTE: This type of button must always be the first button
	// in the first row and can only be used in invoice messages.
	Pay *bool `json:"pay,omitempty"`
	// SwitchInlineQuery
	// If set, pressing the button will prompt the user to select one of their chats, open that
	// chat and insert the bot's username and the specified inline query in the input field. May be
	// empty, in which case just the bot's username will be inserted.Note: This offers an easy way
	// for users to start using your bot in inline mode when they are currently in a private chat
	// with it. Especially useful when combined with switch_pm… actions - in this case the user
	// will be automatically returned to the chat they switched from, skipping the chat selection
	// screen.
	SwitchInlineQuery *string `json:"switch_inline_query,omitempty"`
	// SwitchInlineQueryChosenChat
	// If set, pressing the button will prompt the user to select one of their chats of the
	// specified type, open that chat and insert the bot's username and the specified inline query
	// in the input field
	SwitchInlineQueryChosenChat *SwitchInlineQueryChosenChat `json:"switch_inline_query_chosen_chat,omitempty"`
	// SwitchInlineQueryCurrentChat
	// If set, pressing the button will insert the bot's username and the specified inline query in
	// the current chat's input field. May be empty, in which case only the bot's username will be
	// inserted.This offers a quick way for the user to open your bot in inline mode in the same
	// chat - good for selecting something from multiple options.
	SwitchInlineQueryCurrentChat *string `json:"switch_inline_query_current_chat,omitempty"`
	// URL
	// HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can
	// be used to mention a user by their ID without using a username, if this is allowed by their
	// privacy settings.
	URL *string `json:"url,omitempty"`
	// WebApp
	// Description of the Web App that will be launched when the user presses the button. The Web
	// App will be able to send an arbitrary message on behalf of the user using the method
	// answerWebAppQuery. Available only in private chats between a user and the bot.
	WebApp *WebAppInfo `json:"web_app,omitempty"`
}

func (t *InlineKeyboardButton) GetCallbackData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CallbackData; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetCallbackGame() *CallbackGame {
	if t == nil {
		return nil
	}
	return t.CallbackGame
}

func (t *InlineKeyboardButton) GetLoginURL() *LoginURL {
	if t == nil {
		return nil
	}
	return t.LoginURL
}

func (t *InlineKeyboardButton) GetPay() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Pay; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetSwitchInlineQuery() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SwitchInlineQuery; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetSwitchInlineQueryChosenChat() *SwitchInlineQueryChosenChat {
	if t == nil {
		return nil
	}
	return t.SwitchInlineQueryChosenChat
}

func (t *InlineKeyboardButton) GetSwitchInlineQueryCurrentChat() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SwitchInlineQueryCurrentChat; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetText() string {
	var res string
	if t == nil {
		return res
	}
	return t.Text
}

func (t *InlineKeyboardButton) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

func (t *InlineKeyboardButton) GetWebApp() *WebAppInfo {
	if t == nil {
		return nil
	}
	return t.WebApp
}

// InlineKeyboardMarkup
// This object represents an inline keyboard that appears right next to the message it belongs to.
type InlineKeyboardMarkup struct {
	// InlineKeyboard
	// Array of button rows, each represented by an Array of InlineKeyboardButton objects
	InlineKeyboard [][]InlineKeyboardButton `json:"inline_keyboard"`
}

// InlineQuery
// This object represents an incoming inline query. When the user sends an empty query, your bot
// could return some default or trending results.
type InlineQuery struct {
	// From
	// Sender
	From User `json:"from"`
	// ID
	// Unique identifier for this query
	ID string `json:"id"`
	// Offset
	// Offset of the results to be returned, can be controlled by the bot
	Offset string `json:"offset"`
	// Query
	// Text of the query (up to 256 characters)
	Query string `json:"query"`
	// ChatType
	// Type of the chat from which the inline query was sent. Can be either "sender" for a private
	// chat with the inline query sender, "private", "group", "supergroup", or "channel". The chat
	// type should be always known for requests sent from official clients and most third-party
	// clients, unless the request was sent from a secret chat
	ChatType *string `json:"chat_type,omitempty"`
	// Location
	// Sender location, only for bots that request user location
	Location *Location `json:"location,omitempty"`
}

func (t *InlineQuery) GetChatType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ChatType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQuery) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *InlineQuery) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQuery) GetLocation() *Location {
	if t == nil {
		return nil
	}
	return t.Location
}

func (t *InlineQuery) GetOffset() string {
	var res string
	if t == nil {
		return res
	}
	return t.Offset
}

func (t *InlineQuery) GetQuery() string {
	var res string
	if t == nil {
		return res
	}
	return t.Query
}

// InlineQueryResult
// This object represents one result of an inline query. Telegram clients currently support results
// of the following 20 types:
type InlineQueryResult struct {
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// InputMessageContent
	// Content of the message to be sent
	InputMessageContent InputMessageContent `json:"input_message_content"`
	// Title
	// Title of the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be article
	Type InlineType `json:"type"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// HideURL
	// Pass True if you don't want the URL to be shown in the message
	HideURL *bool `json:"hide_url,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailHeight
	// Thumbnail height
	ThumbnailHeight *int64 `json:"thumbnail_height,omitempty"`
	// ThumbnailURL
	// Url of the thumbnail for the result
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// ThumbnailWidth
	// Thumbnail width
	ThumbnailWidth *int64 `json:"thumbnail_width,omitempty"`
	// URL
	// URL of the result
	URL *string `json:"url,omitempty"`
}

func (t *InlineQueryResult) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetHideURL() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HideURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResult) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return &t.InputMessageContent
}

func (t *InlineQueryResult) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResult) GetThumbnailHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetThumbnailWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResult) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResult) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResult) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultArticle
// Represents a link to an article or web page.
type InlineQueryResultArticle struct {
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// InputMessageContent
	// Content of the message to be sent
	InputMessageContent InputMessageContent `json:"input_message_content"`
	// Title
	// Title of the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be article
	Type InlineType `json:"type"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// HideURL
	// Pass True if you don't want the URL to be shown in the message
	HideURL *bool `json:"hide_url,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailHeight
	// Thumbnail height
	ThumbnailHeight *int64 `json:"thumbnail_height,omitempty"`
	// ThumbnailURL
	// Url of the thumbnail for the result
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// ThumbnailWidth
	// Thumbnail width
	ThumbnailWidth *int64 `json:"thumbnail_width,omitempty"`
	// URL
	// URL of the result
	URL *string `json:"url,omitempty"`
}

func (t *InlineQueryResultArticle) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetHideURL() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HideURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultArticle) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return &t.InputMessageContent
}

func (t *InlineQueryResultArticle) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultArticle) GetThumbnailHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetThumbnailWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultArticle) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultArticle) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResultArticle) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultAudio
// Represents a link to an MP3 audio file. By default, this audio file will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content
// instead of the audio.
type InlineQueryResultAudio struct {
	// AudioURL
	// A valid URL for the audio file
	AudioURL string `json:"audio_url"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Title
	Title string `json:"title"`
	// Type
	// Type of the result, must be audio
	Type InlineType `json:"type"`
	// AudioDuration
	// Audio duration in seconds
	AudioDuration *int64 `json:"audio_duration,omitempty"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the audio
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Performer
	// Performer
	Performer *string `json:"performer,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultAudio) GetAudioDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.AudioDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetAudioURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.AudioURL
}

func (t *InlineQueryResultAudio) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultAudio) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultAudio) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetPerformer() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Performer; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultAudio) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultAudio) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultAudio) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedAudio
// Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio
// file will be sent by the user. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the audio.
type InlineQueryResultCachedAudio struct {
	// AudioFileID
	// A valid file identifier for the audio file
	AudioFileID string `json:"audio_file_id"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Type
	// Type of the result, must be audio
	Type InlineType `json:"type"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the audio
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedAudio) GetAudioFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.AudioFileID
}

func (t *InlineQueryResultCachedAudio) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedAudio) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedAudio) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedAudio) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedAudio) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedAudio) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedDocument
// Represents a link to a file stored on the Telegram servers. By default, this file will be sent
// by the user with an optional caption. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the file.
type InlineQueryResultCachedDocument struct {
	// DocumentFileID
	// A valid file identifier for the file
	DocumentFileID string `json:"document_file_id"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be document
	Type InlineType `json:"type"`
	// Caption
	// Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the file
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedDocument) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetDocumentFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.DocumentFileID
}

func (t *InlineQueryResultCachedDocument) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedDocument) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedDocument) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedDocument) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedDocument) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultCachedDocument) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedGif
// Represents a link to an animated GIF file stored on the Telegram servers. By default, this
// animated GIF file will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with specified content instead of the animation.
type InlineQueryResultCachedGif struct {
	// GifFileID
	// A valid file identifier for the GIF file
	GifFileID string `json:"gif_file_id"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Type
	// Type of the result, must be gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the GIF file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the GIF animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultCachedGif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetGifFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.GifFileID
}

func (t *InlineQueryResultCachedGif) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedGif) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedGif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedGif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedGif) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedMpeg4Gif
// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the
// Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an
// optional caption. Alternatively, you can use input_message_content to send a message with the
// specified content instead of the animation.
type InlineQueryResultCachedMpeg4Gif struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Mpeg4FileID
	// A valid file identifier for the MPEG4 file
	Mpeg4FileID string `json:"mpeg4_file_id"`
	// Type
	// Type of the result, must be mpeg4_gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultCachedMpeg4Gif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedMpeg4Gif) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedMpeg4Gif) GetMpeg4FileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.Mpeg4FileID
}

func (t *InlineQueryResultCachedMpeg4Gif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedMpeg4Gif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedMpeg4Gif) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedPhoto
// Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent
// by the user with an optional caption. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the photo.
type InlineQueryResultCachedPhoto struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// PhotoFileID
	// A valid file identifier of the photo
	PhotoFileID string `json:"photo_file_id"`
	// Type
	// Type of the result, must be photo
	Type InlineType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the photo
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultCachedPhoto) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedPhoto) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedPhoto) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetPhotoFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.PhotoFileID
}

func (t *InlineQueryResultCachedPhoto) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedPhoto) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedPhoto) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedSticker
// Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be
// sent by the user. Alternatively, you can use input_message_content to send a message with the
// specified content instead of the sticker.
type InlineQueryResultCachedSticker struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// StickerFileID
	// A valid file identifier of the sticker
	StickerFileID string `json:"sticker_file_id"`
	// Type
	// Type of the result, must be sticker
	Type InlineType `json:"type"`
	// InputMessageContent
	// Content of the message to be sent instead of the sticker
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedSticker) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedSticker) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedSticker) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedSticker) GetStickerFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.StickerFileID
}

func (t *InlineQueryResultCachedSticker) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultCachedVideo
// Represents a link to a video file stored on the Telegram servers. By default, this video file
// will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the video.
type InlineQueryResultCachedVideo struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be video
	Type InlineType `json:"type"`
	// VideoFileID
	// A valid file identifier for the video file
	VideoFileID string `json:"video_file_id"`
	// Caption
	// Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedVideo) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedVideo) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedVideo) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVideo) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedVideo) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultCachedVideo) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResultCachedVideo) GetVideoFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.VideoFileID
}

// InlineQueryResultCachedVoice
// Represents a link to a voice message stored on the Telegram servers. By default, this voice
// message will be sent by the user. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the voice message.
type InlineQueryResultCachedVoice struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Voice message title
	Title string `json:"title"`
	// Type
	// Type of the result, must be voice
	Type InlineType `json:"type"`
	// VoiceFileID
	// A valid file identifier for the voice message
	VoiceFileID string `json:"voice_file_id"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the voice message
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultCachedVoice) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVoice) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultCachedVoice) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultCachedVoice) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultCachedVoice) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultCachedVoice) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultCachedVoice) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResultCachedVoice) GetVoiceFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.VoiceFileID
}

// InlineQueryResultContact
// Represents a contact with a phone number. By default, this contact will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content
// instead of the contact.
type InlineQueryResultContact struct {
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// Type
	// Type of the result, must be contact
	Type InlineType `json:"type"`
	// InputMessageContent
	// Content of the message to be sent instead of the contact
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// LastName
	// Contact's last name
	LastName *string `json:"last_name,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailHeight
	// Thumbnail height
	ThumbnailHeight *int64 `json:"thumbnail_height,omitempty"`
	// ThumbnailURL
	// Url of the thumbnail for the result
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// ThumbnailWidth
	// Thumbnail width
	ThumbnailWidth *int64 `json:"thumbnail_width,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

func (t *InlineQueryResultContact) GetFirstName() string {
	var res string
	if t == nil {
		return res
	}
	return t.FirstName
}

func (t *InlineQueryResultContact) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultContact) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultContact) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	return t.PhoneNumber
}

func (t *InlineQueryResultContact) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultContact) GetThumbnailHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetThumbnailWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultContact) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResultContact) GetVcard() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Vcard; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultDocument
// Represents a link to a file. By default, this file will be sent by the user with an optional
// caption. Alternatively, you can use input_message_content to send a message with the specified
// content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.
type InlineQueryResultDocument struct {
	// DocumentURL
	// A valid URL for the file
	DocumentURL string `json:"document_url"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// MimeType
	// MIME type of the content of the file, either "application/pdf" or "application/zip"
	MimeType string `json:"mime_type"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be document
	Type InlineType `json:"type"`
	// Caption
	// Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the file
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailHeight
	// Thumbnail height
	ThumbnailHeight *int64 `json:"thumbnail_height,omitempty"`
	// ThumbnailURL
	// URL of the thumbnail (JPEG only) for the file
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// ThumbnailWidth
	// Thumbnail width
	ThumbnailWidth *int64 `json:"thumbnail_width,omitempty"`
}

func (t *InlineQueryResultDocument) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetDocumentURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.DocumentURL
}

func (t *InlineQueryResultDocument) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultDocument) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultDocument) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	return t.MimeType
}

func (t *InlineQueryResultDocument) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultDocument) GetThumbnailHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetThumbnailWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultDocument) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultDocument) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultGame
// Represents a Game.
type InlineQueryResultGame struct {
	// GameShortName
	// Short name of the game
	GameShortName string `json:"game_short_name"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Type
	// Type of the result, must be game
	Type InlineType `json:"type"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

func (t *InlineQueryResultGame) GetGameShortName() string {
	var res string
	if t == nil {
		return res
	}
	return t.GameShortName
}

func (t *InlineQueryResultGame) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultGame) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultGame) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultGif
// Represents a link to an animated GIF file. By default, this animated GIF file will be sent by
// the user with optional caption. Alternatively, you can use input_message_content to send a
// message with the specified content instead of the animation.
type InlineQueryResultGif struct {
	// GifURL
	// A valid URL for the GIF file. File size must not exceed 1MB
	GifURL string `json:"gif_url"`
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// ThumbnailURL
	// URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result
	ThumbnailURL string `json:"thumbnail_url"`
	// Type
	// Type of the result, must be gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the GIF file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// GifDuration
	// Duration of the GIF in seconds
	GifDuration *int64 `json:"gif_duration,omitempty"`
	// GifHeight
	// Height of the GIF
	GifHeight *int64 `json:"gif_height,omitempty"`
	// GifWidth
	// Width of the GIF
	GifWidth *int64 `json:"gif_width,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the GIF animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailMimeType
	// MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4".
	// Defaults to "image/jpeg"
	ThumbnailMimeType *string `json:"thumbnail_mime_type,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultGif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetGifDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.GifDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetGifHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.GifHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetGifURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.GifURL
}

func (t *InlineQueryResultGif) GetGifWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.GifWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultGif) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultGif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultGif) GetThumbnailMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailMimeType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.ThumbnailURL
}

func (t *InlineQueryResultGif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultGif) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultLocation
// Represents a location on a map. By default, the location will be sent by the user.
// Alternatively, you can use input_message_content to send a message with the specified content
// instead of the location.
type InlineQueryResultLocation struct {
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// Latitude
	// Location latitude in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Location longitude in degrees
	Longitude float64 `json:"longitude"`
	// Title
	// Location title
	Title string `json:"title"`
	// Type
	// Type of the result, must be location
	Type InlineType `json:"type"`
	// Heading
	// For live locations, a direction in which the user is moving, in degrees. Must be between 1
	// and 360 if specified.
	Heading *int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the location
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// LivePeriod
	// Period in seconds for which the location can be updated, should be between 60 and 86400.
	LivePeriod *int64 `json:"live_period,omitempty"`
	// ProximityAlertRadius
	// For live locations, a maximum distance for proximity alerts about approaching another chat
	// member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius *int64 `json:"proximity_alert_radius,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailHeight
	// Thumbnail height
	ThumbnailHeight *int64 `json:"thumbnail_height,omitempty"`
	// ThumbnailURL
	// Url of the thumbnail for the result
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// ThumbnailWidth
	// Thumbnail width
	ThumbnailWidth *int64 `json:"thumbnail_width,omitempty"`
}

func (t *InlineQueryResultLocation) GetHeading() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Heading; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetHorizontalAccuracy() *float64 {
	if t == nil {
		return nil
	}
	return t.HorizontalAccuracy
}

func (t *InlineQueryResultLocation) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultLocation) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultLocation) GetLatitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Latitude
}

func (t *InlineQueryResultLocation) GetLivePeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LivePeriod; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetLongitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Longitude
}

func (t *InlineQueryResultLocation) GetProximityAlertRadius() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ProximityAlertRadius; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultLocation) GetThumbnailHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetThumbnailWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultLocation) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultLocation) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultMpeg4Gif
// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this
// animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the animation.
type InlineQueryResultMpeg4Gif struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Mpeg4URL
	// A valid URL for the MPEG4 file. File size must not exceed 1MB
	Mpeg4URL string `json:"mpeg4_url"`
	// ThumbnailURL
	// URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result
	ThumbnailURL string `json:"thumbnail_url"`
	// Type
	// Type of the result, must be mpeg4_gif
	Type InlineType `json:"type"`
	// Caption
	// Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video animation
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// Mpeg4Duration
	// Video duration in seconds
	Mpeg4Duration *int64 `json:"mpeg4_duration,omitempty"`
	// Mpeg4Height
	// Video height
	Mpeg4Height *int64 `json:"mpeg4_height,omitempty"`
	// Mpeg4Width
	// Video width
	Mpeg4Width *int64 `json:"mpeg4_width,omitempty"`
	// ParseMode
	// Mode for parsing entities in the caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailMimeType
	// MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4".
	// Defaults to "image/jpeg"
	ThumbnailMimeType *string `json:"thumbnail_mime_type,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultMpeg4Gif) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultMpeg4Gif) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4Duration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Mpeg4Duration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4Height() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Mpeg4Height; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4URL() string {
	var res string
	if t == nil {
		return res
	}
	return t.Mpeg4URL
}

func (t *InlineQueryResultMpeg4Gif) GetMpeg4Width() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Mpeg4Width; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultMpeg4Gif) GetThumbnailMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailMimeType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.ThumbnailURL
}

func (t *InlineQueryResultMpeg4Gif) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultMpeg4Gif) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultPhoto
// Represents a link to a photo. By default, this photo will be sent by the user with optional
// caption. Alternatively, you can use input_message_content to send a message with the specified
// content instead of the photo.
type InlineQueryResultPhoto struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// PhotoURL
	// A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB
	PhotoURL string `json:"photo_url"`
	// ThumbnailURL
	// URL of the thumbnail for the photo
	ThumbnailURL string `json:"thumbnail_url"`
	// Type
	// Type of the result, must be photo
	Type InlineType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the photo
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// PhotoHeight
	// Height of the photo
	PhotoHeight *int64 `json:"photo_height,omitempty"`
	// PhotoWidth
	// Width of the photo
	PhotoWidth *int64 `json:"photo_width,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// Title
	// Title for the result
	Title *string `json:"title,omitempty"`
}

func (t *InlineQueryResultPhoto) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultPhoto) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultPhoto) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetPhotoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetPhotoURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.PhotoURL
}

func (t *InlineQueryResultPhoto) GetPhotoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultPhoto) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.ThumbnailURL
}

func (t *InlineQueryResultPhoto) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultPhoto) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultVenue
// Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the venue.
type InlineQueryResultVenue struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// ID
	// Unique identifier for this result, 1-64 Bytes
	ID string `json:"id"`
	// Latitude
	// Latitude of the venue location in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue location in degrees
	Longitude float64 `json:"longitude"`
	// Title
	// Title of the venue
	Title string `json:"title"`
	// Type
	// Type of the result, must be venue
	Type InlineType `json:"type"`
	// FoursquareID
	// Foursquare identifier of the venue if known
	FoursquareID *string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType *string `json:"foursquare_type,omitempty"`
	// GooglePlaceID
	// Google Places identifier of the venue
	GooglePlaceID *string `json:"google_place_id,omitempty"`
	// GooglePlaceType
	// Google Places type of the venue. (See supported types.)
	GooglePlaceType *string `json:"google_place_type,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the venue
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ThumbnailHeight
	// Thumbnail height
	ThumbnailHeight *int64 `json:"thumbnail_height,omitempty"`
	// ThumbnailURL
	// Url of the thumbnail for the result
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// ThumbnailWidth
	// Thumbnail width
	ThumbnailWidth *int64 `json:"thumbnail_width,omitempty"`
}

func (t *InlineQueryResultVenue) GetAddress() string {
	var res string
	if t == nil {
		return res
	}
	return t.Address
}

func (t *InlineQueryResultVenue) GetFoursquareID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareID; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetFoursquareType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetGooglePlaceID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GooglePlaceID; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetGooglePlaceType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GooglePlaceType; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultVenue) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultVenue) GetLatitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Latitude
}

func (t *InlineQueryResultVenue) GetLongitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Longitude
}

func (t *InlineQueryResultVenue) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultVenue) GetThumbnailHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ThumbnailURL; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetThumbnailWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ThumbnailWidth; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVenue) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultVenue) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InlineQueryResultVideo
// Represents a link to a page containing an embedded video player or a video file. By default,
// this video file will be sent by the user with an optional caption. Alternatively, you can use
// input_message_content to send a message with the specified content instead of the video.
type InlineQueryResultVideo struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// MimeType
	// MIME type of the content of the video URL, "text/html" or "video/mp4"
	MimeType string `json:"mime_type"`
	// ThumbnailURL
	// URL of the thumbnail (JPEG only) for the video
	ThumbnailURL string `json:"thumbnail_url"`
	// Title
	// Title for the result
	Title string `json:"title"`
	// Type
	// Type of the result, must be video
	Type InlineType `json:"type"`
	// VideoURL
	// A valid URL for the embedded video player or video file
	VideoURL string `json:"video_url"`
	// Caption
	// Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Description
	// Short description of the result
	Description *string `json:"description,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the video. This field is required if
	// InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video).
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// VideoDuration
	// Video duration in seconds
	VideoDuration *int64 `json:"video_duration,omitempty"`
	// VideoHeight
	// Video height
	VideoHeight *int64 `json:"video_height,omitempty"`
	// VideoWidth
	// Video width
	VideoWidth *int64 `json:"video_width,omitempty"`
}

func (t *InlineQueryResultVideo) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Description; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultVideo) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultVideo) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	return t.MimeType
}

func (t *InlineQueryResultVideo) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultVideo) GetThumbnailURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.ThumbnailURL
}

func (t *InlineQueryResultVideo) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultVideo) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResultVideo) GetVideoDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VideoDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetVideoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VideoHeight; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVideo) GetVideoURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.VideoURL
}

func (t *InlineQueryResultVideo) GetVideoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VideoWidth; field != nil {
		return *field
	}
	return res
}

// InlineQueryResultVoice
// Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this
// voice recording will be sent by the user. Alternatively, you can use input_message_content to
// send a message with the specified content instead of the the voice message.
type InlineQueryResultVoice struct {
	// ID
	// Unique identifier for this result, 1-64 bytes
	ID string `json:"id"`
	// Title
	// Recording title
	Title string `json:"title"`
	// Type
	// Type of the result, must be voice
	Type InlineType `json:"type"`
	// VoiceURL
	// A valid URL for the voice recording
	VoiceURL string `json:"voice_url"`
	// Caption
	// Caption, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// InputMessageContent
	// Content of the message to be sent instead of the voice recording
	InputMessageContent *InputMessageContent `json:"input_message_content,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// VoiceDuration
	// Recording duration in seconds
	VoiceDuration *int64 `json:"voice_duration,omitempty"`
}

func (t *InlineQueryResultVoice) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *InlineQueryResultVoice) GetInputMessageContent() *InputMessageContent {
	if t == nil {
		return nil
	}
	return t.InputMessageContent
}

func (t *InlineQueryResultVoice) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *InlineQueryResultVoice) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *InlineQueryResultVoice) GetType() *InlineType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InlineQueryResultVoice) GetVoiceDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.VoiceDuration; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultVoice) GetVoiceURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.VoiceURL
}

// InlineQueryResultsButton
// This object represents a button to be shown above inline query results. You must use exactly one
// of the optional fields.
type InlineQueryResultsButton struct {
	// Text
	// Label text on the button
	Text string `json:"text"`
	// StartParameter
	// Deep-linking parameter for the /start message sent to the bot when a user presses the
	// button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot
	// that sends YouTube videos can ask the user to connect the bot to their YouTube account to
	// adapt search results accordingly. To do this, it displays a 'Connect your YouTube account'
	// button above the results, or even before showing any. The user presses the button, switches
	// to a private chat with the bot and, in doing so, passes a start parameter that instructs the
	// bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the
	// user can easily return to the chat where they wanted to use the bot's inline capabilities.
	StartParameter *string `json:"start_parameter,omitempty"`
	// WebApp
	// Description of the Web App that will be launched when the user presses the button. The Web
	// App will be able to switch back to the inline mode using the method switchInlineQuery inside
	// the Web App.
	WebApp *WebAppInfo `json:"web_app,omitempty"`
}

func (t *InlineQueryResultsButton) GetStartParameter() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.StartParameter; field != nil {
		return *field
	}
	return res
}

func (t *InlineQueryResultsButton) GetText() string {
	var res string
	if t == nil {
		return res
	}
	return t.Text
}

func (t *InlineQueryResultsButton) GetWebApp() *WebAppInfo {
	if t == nil {
		return nil
	}
	return t.WebApp
}

// InputContactMessageContent
// Represents the content of a contact message to be sent as the result of an inline query.
type InputContactMessageContent struct {
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// LastName
	// Contact's last name
	LastName *string `json:"last_name,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard *string `json:"vcard,omitempty"`
}

func (t *InputContactMessageContent) GetFirstName() string {
	var res string
	if t == nil {
		return res
	}
	return t.FirstName
}

func (t *InputContactMessageContent) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *InputContactMessageContent) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	return t.PhoneNumber
}

func (t *InputContactMessageContent) GetVcard() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Vcard; field != nil {
		return *field
	}
	return res
}

// InputInvoiceMessageContent
// Represents the content of an invoice message to be sent as the result of an inline query.
type InputInvoiceMessageContent struct {
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payment provider token, obtained via @BotFather
	ProviderToken string `json:"provider_token"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// IsFlexible
	// Pass True if the final price depends on the shipping method
	IsFlexible *bool `json:"is_flexible,omitempty"`
	// MaxTipAmount
	// The maximum accepted amount for tips in the smallest units of the currency (integer, not
	// float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the
	// exp parameter in currencies.json, it shows the number of digits past the decimal point for
	// each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount *int64 `json:"max_tip_amount,omitempty"`
	// NeedEmail
	// Pass True if you require the user's email address to complete the order
	NeedEmail *bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True if you require the user's full name to complete the order
	NeedName *bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True if you require the user's phone number to complete the order
	NeedPhoneNumber *bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True if you require the user's shipping address to complete the order
	NeedShippingAddress *bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight *int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size in bytes
	PhotoSize *int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service.
	PhotoURL *string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth *int64 `json:"photo_width,omitempty"`
	// ProviderData
	// A JSON-serialized object for data about the invoice, which will be shared with the payment
	// provider. A detailed description of the required fields should be provided by the payment
	// provider.
	ProviderData *string `json:"provider_data,omitempty"`
	// SendEmailToProvider
	// Pass True if the user's email address should be sent to provider
	SendEmailToProvider *bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True if the user's phone number should be sent to provider
	SendPhoneNumberToProvider *bool `json:"send_phone_number_to_provider,omitempty"`
	// SuggestedTipAmounts
	// A JSON-serialized array of suggested amounts of tip in the smallest units of the currency
	// (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested
	// tip amounts must be positive, passed in a strictly increased order and must not exceed
	// max_tip_amount.
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts,omitempty"`
}

func (t *InputInvoiceMessageContent) GetCurrency() string {
	var res string
	if t == nil {
		return res
	}
	return t.Currency
}

func (t *InputInvoiceMessageContent) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.Description
}

func (t *InputInvoiceMessageContent) GetIsFlexible() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.IsFlexible; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetMaxTipAmount() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MaxTipAmount; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetNeedEmail() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedEmail; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetNeedName() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedName; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetNeedPhoneNumber() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedPhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetNeedShippingAddress() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedShippingAddress; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetPayload() string {
	var res string
	if t == nil {
		return res
	}
	return t.Payload
}

func (t *InputInvoiceMessageContent) GetPhotoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoHeight; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetPhotoSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoSize; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetPhotoURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhotoURL; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetPhotoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoWidth; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetProviderData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ProviderData; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetProviderToken() string {
	var res string
	if t == nil {
		return res
	}
	return t.ProviderToken
}

func (t *InputInvoiceMessageContent) GetSendEmailToProvider() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SendEmailToProvider; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetSendPhoneNumberToProvider() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SendPhoneNumberToProvider; field != nil {
		return *field
	}
	return res
}

func (t *InputInvoiceMessageContent) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// InputLocationMessageContent
// Represents the content of a location message to be sent as the result of an inline query.
type InputLocationMessageContent struct {
	// Latitude
	// Latitude of the location in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the location in degrees
	Longitude float64 `json:"longitude"`
	// Heading
	// For live locations, a direction in which the user is moving, in degrees. Must be between 1
	// and 360 if specified.
	Heading *int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// LivePeriod
	// Period in seconds for which the location can be updated, should be between 60 and 86400.
	LivePeriod *int64 `json:"live_period,omitempty"`
	// ProximityAlertRadius
	// For live locations, a maximum distance for proximity alerts about approaching another chat
	// member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius *int64 `json:"proximity_alert_radius,omitempty"`
}

func (t *InputLocationMessageContent) GetHeading() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Heading; field != nil {
		return *field
	}
	return res
}

func (t *InputLocationMessageContent) GetHorizontalAccuracy() *float64 {
	if t == nil {
		return nil
	}
	return t.HorizontalAccuracy
}

func (t *InputLocationMessageContent) GetLatitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Latitude
}

func (t *InputLocationMessageContent) GetLivePeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LivePeriod; field != nil {
		return *field
	}
	return res
}

func (t *InputLocationMessageContent) GetLongitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Longitude
}

func (t *InputLocationMessageContent) GetProximityAlertRadius() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ProximityAlertRadius; field != nil {
		return *field
	}
	return res
}

// InputMedia
// This object represents the content of a media message to be sent. It should be one of
type InputMedia struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name. More information on Sending Files »
	Media string `json:"media"`
	// Type
	// Type of the result, must be photo
	Type InputType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// HasSpoiler
	// Pass True if the photo needs to be covered with a spoiler animation
	HasSpoiler *bool `json:"has_spoiler,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputMedia) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMedia) GetHasSpoiler() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HasSpoiler; field != nil {
		return *field
	}
	return res
}

func (t *InputMedia) GetMedia() string {
	var res string
	if t == nil {
		return res
	}
	return t.Media
}

func (t *InputMedia) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMedia) GetType() *InputType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InputMediaAnimation
// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
type InputMediaAnimation struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name. More information on Sending Files »
	Media string `json:"media"`
	// Type
	// Type of the result, must be animation
	Type InputType `json:"type"`
	// Caption
	// Caption of the animation to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Duration
	// Animation duration in seconds
	Duration *int64 `json:"duration,omitempty"`
	// HasSpoiler
	// Pass True if the animation needs to be covered with a spoiler animation
	HasSpoiler *bool `json:"has_spoiler,omitempty"`
	// Height
	// Animation height
	Height *int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the animation caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *FileID `json:"thumbnail,omitempty"`
	// Width
	// Animation width
	Width *int64 `json:"width,omitempty"`
}

func (t *InputMediaAnimation) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Duration; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetHasSpoiler() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HasSpoiler; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Height; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetMedia() string {
	var res string
	if t == nil {
		return res
	}
	return t.Media
}

func (t *InputMediaAnimation) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAnimation) GetThumbnail() *FileID {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *InputMediaAnimation) GetType() *InputType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InputMediaAnimation) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Width; field != nil {
		return *field
	}
	return res
}

// InputMediaAudio
// Represents an audio file to be treated as music to be sent.
type InputMediaAudio struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name. More information on Sending Files »
	Media string `json:"media"`
	// Type
	// Type of the result, must be audio
	Type InputType `json:"type"`
	// Caption
	// Caption of the audio to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Duration
	// Duration of the audio in seconds
	Duration *int64 `json:"duration,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Performer
	// Performer of the audio
	Performer *string `json:"performer,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *FileID `json:"thumbnail,omitempty"`
	// Title
	// Title of the audio
	Title *string `json:"title,omitempty"`
}

func (t *InputMediaAudio) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Duration; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetMedia() string {
	var res string
	if t == nil {
		return res
	}
	return t.Media
}

func (t *InputMediaAudio) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetPerformer() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Performer; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetThumbnail() *FileID {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *InputMediaAudio) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Title; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaAudio) GetType() *InputType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InputMediaDocument
// Represents a general file to be sent.
type InputMediaDocument struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name. More information on Sending Files »
	Media string `json:"media"`
	// Type
	// Type of the result, must be document
	Type InputType `json:"type"`
	// Caption
	// Caption of the document to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// DisableContentTypeDetection
	// Disables automatic server-side content type detection for files uploaded using
	// multipart/form-data. Always True, if the document is sent as part of an album.
	DisableContentTypeDetection *bool `json:"disable_content_type_detection,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *FileID `json:"thumbnail,omitempty"`
}

func (t *InputMediaDocument) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaDocument) GetDisableContentTypeDetection() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableContentTypeDetection; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaDocument) GetMedia() string {
	var res string
	if t == nil {
		return res
	}
	return t.Media
}

func (t *InputMediaDocument) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaDocument) GetThumbnail() *FileID {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *InputMediaDocument) GetType() *InputType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InputMediaPhoto
// Represents a photo to be sent.
type InputMediaPhoto struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name. More information on Sending Files »
	Media string `json:"media"`
	// Type
	// Type of the result, must be photo
	Type InputType `json:"type"`
	// Caption
	// Caption of the photo to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// HasSpoiler
	// Pass True if the photo needs to be covered with a spoiler animation
	HasSpoiler *bool `json:"has_spoiler,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputMediaPhoto) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaPhoto) GetHasSpoiler() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HasSpoiler; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaPhoto) GetMedia() string {
	var res string
	if t == nil {
		return res
	}
	return t.Media
}

func (t *InputMediaPhoto) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaPhoto) GetType() *InputType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// InputMediaVideo
// Represents a video to be sent.
type InputMediaVideo struct {
	// Media
	// File to send. Pass a file_id to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass
	// "attach://<file_attach_name>" to upload a new one using multipart/form-data under
	// <file_attach_name> name. More information on Sending Files »
	Media string `json:"media"`
	// Type
	// Type of the result, must be video
	Type InputType `json:"type"`
	// Caption
	// Caption of the video to be sent, 0-1024 characters after entities parsing
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// List of special entities that appear in the caption, which can be specified instead of
	// parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// Duration
	// Video duration in seconds
	Duration *int64 `json:"duration,omitempty"`
	// HasSpoiler
	// Pass True if the video needs to be covered with a spoiler animation
	HasSpoiler *bool `json:"has_spoiler,omitempty"`
	// Height
	// Video height
	Height *int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
	// SupportsStreaming
	// Pass True if the uploaded video is suitable for streaming
	SupportsStreaming *bool `json:"supports_streaming,omitempty"`
	// Thumbnail
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More information on Sending Files »
	Thumbnail *FileID `json:"thumbnail,omitempty"`
	// Width
	// Video width
	Width *int64 `json:"width,omitempty"`
}

func (t *InputMediaVideo) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Duration; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetHasSpoiler() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.HasSpoiler; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Height; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetMedia() string {
	var res string
	if t == nil {
		return res
	}
	return t.Media
}

func (t *InputMediaVideo) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetSupportsStreaming() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SupportsStreaming; field != nil {
		return *field
	}
	return res
}

func (t *InputMediaVideo) GetThumbnail() *FileID {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *InputMediaVideo) GetType() *InputType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *InputMediaVideo) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Width; field != nil {
		return *field
	}
	return res
}

// InputMessageContent
// This object represents the content of a message to be sent as a result of an inline query.
// Telegram clients currently support the following 5 types:
type InputMessageContent struct {
	// MessageText
	// Text of the message to be sent, 1-4096 characters
	MessageText string `json:"message_text"`
	// DisableWebPagePreview
	// Disables link previews for links in the sent message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`
	// Entities
	// List of special entities that appear in message text, which can be specified instead of
	// parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputMessageContent) GetDisableWebPagePreview() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableWebPagePreview; field != nil {
		return *field
	}
	return res
}

func (t *InputMessageContent) GetMessageText() string {
	var res string
	if t == nil {
		return res
	}
	return t.MessageText
}

func (t *InputMessageContent) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

// InputSticker
// This object describes a sticker to be added to a sticker set.
type InputSticker struct {
	// EmojiList
	// List of 1-20 emoji associated with the sticker
	EmojiList []string `json:"emoji_list"`
	// Sticker
	// The added sticker. Pass a file_id as a String to send a file that already exists on the
	// Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet,
	// upload a new one using multipart/form-data, or pass "attach://<file_attach_name>" to upload
	// a new one using multipart/form-data under <file_attach_name> name. Animated and video
	// stickers can't be uploaded via HTTP URL. More information on Sending Files »
	Sticker FileID `json:"sticker"`
	// Keywords
	// List of 0-20 search keywords for the sticker with total length of up to 64 characters. For
	// "regular" and "custom_emoji" stickers only.
	Keywords []string `json:"keywords,omitempty"`
	// MaskPosition
	// Position where the mask should be placed on faces. For "mask" stickers only.
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
}

func (t *InputSticker) GetMaskPosition() *MaskPosition {
	if t == nil {
		return nil
	}
	return t.MaskPosition
}

func (t *InputSticker) GetSticker() *FileID {
	if t == nil {
		return nil
	}
	return &t.Sticker
}

// InputTextMessageContent
// Represents the content of a text message to be sent as the result of an inline query.
type InputTextMessageContent struct {
	// MessageText
	// Text of the message to be sent, 1-4096 characters
	MessageText string `json:"message_text"`
	// DisableWebPagePreview
	// Disables link previews for links in the sent message
	DisableWebPagePreview *bool `json:"disable_web_page_preview,omitempty"`
	// Entities
	// List of special entities that appear in message text, which can be specified instead of
	// parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode *string `json:"parse_mode,omitempty"`
}

func (t *InputTextMessageContent) GetDisableWebPagePreview() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableWebPagePreview; field != nil {
		return *field
	}
	return res
}

func (t *InputTextMessageContent) GetMessageText() string {
	var res string
	if t == nil {
		return res
	}
	return t.MessageText
}

func (t *InputTextMessageContent) GetParseMode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ParseMode; field != nil {
		return *field
	}
	return res
}

// InputVenueMessageContent
// Represents the content of a venue message to be sent as the result of an inline query.
type InputVenueMessageContent struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// Latitude
	// Latitude of the venue in degrees
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue in degrees
	Longitude float64 `json:"longitude"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// FoursquareID
	// Foursquare identifier of the venue, if known
	FoursquareID *string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType *string `json:"foursquare_type,omitempty"`
	// GooglePlaceID
	// Google Places identifier of the venue
	GooglePlaceID *string `json:"google_place_id,omitempty"`
	// GooglePlaceType
	// Google Places type of the venue. (See supported types.)
	GooglePlaceType *string `json:"google_place_type,omitempty"`
}

func (t *InputVenueMessageContent) GetAddress() string {
	var res string
	if t == nil {
		return res
	}
	return t.Address
}

func (t *InputVenueMessageContent) GetFoursquareID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareID; field != nil {
		return *field
	}
	return res
}

func (t *InputVenueMessageContent) GetFoursquareType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareType; field != nil {
		return *field
	}
	return res
}

func (t *InputVenueMessageContent) GetGooglePlaceID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GooglePlaceID; field != nil {
		return *field
	}
	return res
}

func (t *InputVenueMessageContent) GetGooglePlaceType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GooglePlaceType; field != nil {
		return *field
	}
	return res
}

func (t *InputVenueMessageContent) GetLatitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Latitude
}

func (t *InputVenueMessageContent) GetLongitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Longitude
}

func (t *InputVenueMessageContent) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// Invoice
// This object contains basic information about an invoice.
type Invoice struct {
	// Currency
	// Three-letter ISO 4217 currency code
	Currency string `json:"currency"`
	// Description
	// Product description
	Description string `json:"description"`
	// StartParameter
	// Unique bot deep-linking parameter that can be used to generate this invoice
	StartParameter string `json:"start_parameter"`
	// Title
	// Product name
	Title string `json:"title"`
	// TotalAmount
	// Total price in the smallest units of the currency (integer, not float/double). For example,
	// for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it
	// shows the number of digits past the decimal point for each currency (2 for the majority of
	// currencies).
	TotalAmount int64 `json:"total_amount"`
}

func (t *Invoice) GetCurrency() string {
	var res string
	if t == nil {
		return res
	}
	return t.Currency
}

func (t *Invoice) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.Description
}

func (t *Invoice) GetStartParameter() string {
	var res string
	if t == nil {
		return res
	}
	return t.StartParameter
}

func (t *Invoice) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

func (t *Invoice) GetTotalAmount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.TotalAmount
}

// KeyboardButton
// This object represents one button of the reply keyboard. For simple text buttons, String can be
// used instead of this object to specify the button text. The optional fields web_app,
// request_user, request_chat, request_contact, request_location, and request_poll are mutually
// exclusive.
type KeyboardButton struct {
	// Text
	// Text of the button. If none of the optional fields are used, it will be sent as a message
	// when the button is pressed
	Text string `json:"text"`
	// RequestChat
	// If specified, pressing the button will open a list of suitable chats. Tapping on a chat will
	// send its identifier to the bot in a "chat_shared" service message. Available in private
	// chats only.
	RequestChat *KeyboardButtonRequestChat `json:"request_chat,omitempty"`
	// RequestContact
	// If True, the user's phone number will be sent as a contact when the button is pressed.
	// Available in private chats only.
	RequestContact *bool `json:"request_contact,omitempty"`
	// RequestLocation
	// If True, the user's current location will be sent when the button is pressed. Available in
	// private chats only.
	RequestLocation *bool `json:"request_location,omitempty"`
	// RequestPoll
	// If specified, the user will be asked to create a poll and send it to the bot when the button
	// is pressed. Available in private chats only.
	RequestPoll *KeyboardButtonPollType `json:"request_poll,omitempty"`
	// RequestUser
	// If specified, pressing the button will open a list of suitable users. Tapping on any user
	// will send their identifier to the bot in a "user_shared" service message. Available in
	// private chats only.
	RequestUser *KeyboardButtonRequestUser `json:"request_user,omitempty"`
	// WebApp
	// If specified, the described Web App will be launched when the button is pressed. The Web App
	// will be able to send a "web_app_data" service message. Available in private chats only.
	WebApp *WebAppInfo `json:"web_app,omitempty"`
}

func (t *KeyboardButton) GetRequestChat() *KeyboardButtonRequestChat {
	if t == nil {
		return nil
	}
	return t.RequestChat
}

func (t *KeyboardButton) GetRequestContact() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.RequestContact; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButton) GetRequestLocation() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.RequestLocation; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButton) GetRequestPoll() *KeyboardButtonPollType {
	if t == nil {
		return nil
	}
	return t.RequestPoll
}

func (t *KeyboardButton) GetRequestUser() *KeyboardButtonRequestUser {
	if t == nil {
		return nil
	}
	return t.RequestUser
}

func (t *KeyboardButton) GetText() string {
	var res string
	if t == nil {
		return res
	}
	return t.Text
}

func (t *KeyboardButton) GetWebApp() *WebAppInfo {
	if t == nil {
		return nil
	}
	return t.WebApp
}

// KeyboardButtonPollType
// This object represents type of a poll, which is allowed to be created and sent when the
// corresponding button is pressed.
type KeyboardButtonPollType struct {
	// Type
	// If quiz is passed, the user will be allowed to create only polls in the quiz mode. If
	// regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed
	// to create a poll of any type.
	Type *KeyboardButtonType `json:"type,omitempty"`
}

func (t *KeyboardButtonPollType) GetType() *KeyboardButtonType {
	if t == nil {
		return nil
	}
	return t.Type
}

// KeyboardButtonRequestChat
// This object defines the criteria used to request a suitable chat. The identifier of the selected
// chat will be shared with the bot when the corresponding button is pressed. More about requesting
// chats »
type KeyboardButtonRequestChat struct {
	// ChatIsChannel
	// Pass True to request a channel chat, pass False to request a group or a supergroup chat.
	ChatIsChannel bool `json:"chat_is_channel"`
	// RequestID
	// Signed 32-bit identifier of the request, which will be received back in the ChatShared
	// object. Must be unique within the message
	RequestID int64 `json:"request_id"`
	// BotAdministratorRights
	// A JSON-serialized object listing the required administrator rights of the bot in the chat.
	// The rights must be a subset of user_administrator_rights. If not specified, no additional
	// restrictions are applied.
	BotAdministratorRights *ChatAdministratorRights `json:"bot_administrator_rights,omitempty"`
	// BotIsMember
	// Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions
	// are applied.
	BotIsMember *bool `json:"bot_is_member,omitempty"`
	// ChatHasUsername
	// Pass True to request a supergroup or a channel with a username, pass False to request a chat
	// without a username. If not specified, no additional restrictions are applied.
	ChatHasUsername *bool `json:"chat_has_username,omitempty"`
	// ChatIsCreated
	// Pass True to request a chat owned by the user. Otherwise, no additional restrictions are
	// applied.
	ChatIsCreated *bool `json:"chat_is_created,omitempty"`
	// ChatIsForum
	// Pass True to request a forum supergroup, pass False to request a non-forum chat. If not
	// specified, no additional restrictions are applied.
	ChatIsForum *bool `json:"chat_is_forum,omitempty"`
	// UserAdministratorRights
	// A JSON-serialized object listing the required administrator rights of the user in the chat.
	// The rights must be a superset of bot_administrator_rights. If not specified, no additional
	// restrictions are applied.
	UserAdministratorRights *ChatAdministratorRights `json:"user_administrator_rights,omitempty"`
}

func (t *KeyboardButtonRequestChat) GetBotAdministratorRights() *ChatAdministratorRights {
	if t == nil {
		return nil
	}
	return t.BotAdministratorRights
}

func (t *KeyboardButtonRequestChat) GetBotIsMember() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.BotIsMember; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButtonRequestChat) GetChatHasUsername() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ChatHasUsername; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButtonRequestChat) GetChatIsChannel() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.ChatIsChannel
}

func (t *KeyboardButtonRequestChat) GetChatIsCreated() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ChatIsCreated; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButtonRequestChat) GetChatIsForum() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ChatIsForum; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButtonRequestChat) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

func (t *KeyboardButtonRequestChat) GetUserAdministratorRights() *ChatAdministratorRights {
	if t == nil {
		return nil
	}
	return t.UserAdministratorRights
}

// KeyboardButtonRequestUser
// This object defines the criteria used to request a suitable user. The identifier of the selected
// user will be shared with the bot when the corresponding button is pressed. More about requesting
// users »
type KeyboardButtonRequestUser struct {
	// RequestID
	// Signed 32-bit identifier of the request, which will be received back in the UserShared
	// object. Must be unique within the message
	RequestID int64 `json:"request_id"`
	// UserIsBot
	// Pass True to request a bot, pass False to request a regular user. If not specified, no
	// additional restrictions are applied.
	UserIsBot *bool `json:"user_is_bot,omitempty"`
	// UserIsPremium
	// Pass True to request a premium user, pass False to request a non-premium user. If not
	// specified, no additional restrictions are applied.
	UserIsPremium *bool `json:"user_is_premium,omitempty"`
}

func (t *KeyboardButtonRequestUser) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

func (t *KeyboardButtonRequestUser) GetUserIsBot() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.UserIsBot; field != nil {
		return *field
	}
	return res
}

func (t *KeyboardButtonRequestUser) GetUserIsPremium() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.UserIsPremium; field != nil {
		return *field
	}
	return res
}

// LabeledPrice
// This object represents a portion of the price for goods or services.
type LabeledPrice struct {
	// Amount
	// Price of the product in the smallest units of the currency (integer, not float/double). For
	// example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in
	// currencies.json, it shows the number of digits past the decimal point for each currency (2
	// for the majority of currencies).
	Amount int64 `json:"amount"`
	// Label
	// Portion label
	Label string `json:"label"`
}

func (t *LabeledPrice) GetAmount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Amount
}

func (t *LabeledPrice) GetLabel() string {
	var res string
	if t == nil {
		return res
	}
	return t.Label
}

// Location
// This object represents a point on the map.
type Location struct {
	// Latitude
	// Latitude as defined by sender
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude as defined by sender
	Longitude float64 `json:"longitude"`
	// Heading
	// The direction in which user is moving, in degrees; 1-360. For active live locations only.
	Heading *int64 `json:"heading,omitempty"`
	// HorizontalAccuracy
	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy *float64 `json:"horizontal_accuracy,omitempty"`
	// LivePeriod
	// Time relative to the message sending date, during which the location can be updated; in
	// seconds. For active live locations only.
	LivePeriod *int64 `json:"live_period,omitempty"`
	// ProximityAlertRadius
	// The maximum distance for proximity alerts about approaching another chat member, in meters.
	// For sent live locations only.
	ProximityAlertRadius *int64 `json:"proximity_alert_radius,omitempty"`
}

func (t *Location) GetHeading() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.Heading; field != nil {
		return *field
	}
	return res
}

func (t *Location) GetHorizontalAccuracy() *float64 {
	if t == nil {
		return nil
	}
	return t.HorizontalAccuracy
}

func (t *Location) GetLatitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Latitude
}

func (t *Location) GetLivePeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LivePeriod; field != nil {
		return *field
	}
	return res
}

func (t *Location) GetLongitude() *float64 {
	if t == nil {
		return nil
	}
	return &t.Longitude
}

func (t *Location) GetProximityAlertRadius() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ProximityAlertRadius; field != nil {
		return *field
	}
	return res
}

// LoginURL
// This object represents a parameter of the inline keyboard button used to automatically authorize
// a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from
// Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
type LoginURL struct {
	// URL
	// An HTTPS URL to be opened with user authorization data added to the query string when the
	// button is pressed. If the user refuses to provide authorization data, the original URL
	// without information about the user will be opened. The data added is the same as described
	// in Receiving authorization data.NOTE: You must always check the hash of the received data to
	// verify the authentication and the integrity of the data as described in Checking
	// authorization.
	URL string `json:"url"`
	// BotUsername
	// Username of a bot, which will be used for user authorization. See Setting up a bot for more
	// details. If not specified, the current bot's username will be assumed. The url's domain must
	// be the same as the domain linked with the bot. See Linking your domain to the bot for more
	// details.
	BotUsername *string `json:"bot_username,omitempty"`
	// ForwardText
	// New text of the button in forwarded messages.
	ForwardText *string `json:"forward_text,omitempty"`
	// RequestWriteAccess
	// Pass True to request the permission for your bot to send messages to the user.
	RequestWriteAccess *bool `json:"request_write_access,omitempty"`
}

func (t *LoginURL) GetBotUsername() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.BotUsername; field != nil {
		return *field
	}
	return res
}

func (t *LoginURL) GetForwardText() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ForwardText; field != nil {
		return *field
	}
	return res
}

func (t *LoginURL) GetRequestWriteAccess() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.RequestWriteAccess; field != nil {
		return *field
	}
	return res
}

func (t *LoginURL) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.URL
}

// MaskPosition
// This object describes the position on faces where a mask should be placed by default.
type MaskPosition struct {
	// Point
	// The part of the face relative to which the mask should be placed. One of "forehead", "eyes",
	// "mouth", or "chin".
	Point string `json:"point"`
	// Scale
	// Mask scaling coefficient. For example, 2.0 means double size.
	Scale float64 `json:"scale"`
	// XShift
	// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right.
	// For example, choosing -1.0 will place mask just to the left of the default mask position.
	XShift float64 `json:"x_shift"`
	// YShift
	// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom.
	// For example, 1.0 will place the mask just below the default mask position.
	YShift float64 `json:"y_shift"`
}

func (t *MaskPosition) GetPoint() string {
	var res string
	if t == nil {
		return res
	}
	return t.Point
}

func (t *MaskPosition) GetScale() *float64 {
	if t == nil {
		return nil
	}
	return &t.Scale
}

func (t *MaskPosition) GetXShift() *float64 {
	if t == nil {
		return nil
	}
	return &t.XShift
}

func (t *MaskPosition) GetYShift() *float64 {
	if t == nil {
		return nil
	}
	return &t.YShift
}

// MenuButton
// This object describes the bot's menu button in a private chat. It should be one of
type MenuButton struct {
	// Type
	// Type of the button, must be commands
	Type MenuType `json:"type"`
}

func (t *MenuButton) GetType() *MenuType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// MenuButtonCommands
// Represents a menu button, which opens the bot's list of commands.
type MenuButtonCommands struct {
	// Type
	// Type of the button, must be commands
	Type MenuType `json:"type"`
}

func (t *MenuButtonCommands) GetType() *MenuType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// MenuButtonDefault
// Describes that no specific value for the menu button was set.
type MenuButtonDefault struct {
	// Type
	// Type of the button, must be default
	Type MenuType `json:"type"`
}

func (t *MenuButtonDefault) GetType() *MenuType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// MenuButtonWebApp
// Represents a menu button, which launches a Web App.
type MenuButtonWebApp struct {
	// Text
	// Text on the button
	Text string `json:"text"`
	// Type
	// Type of the button, must be web_app
	Type MenuType `json:"type"`
	// WebApp
	// Description of the Web App that will be launched when the user presses the button. The Web
	// App will be able to send an arbitrary message on behalf of the user using the method
	// answerWebAppQuery.
	WebApp WebAppInfo `json:"web_app"`
}

func (t *MenuButtonWebApp) GetText() string {
	var res string
	if t == nil {
		return res
	}
	return t.Text
}

func (t *MenuButtonWebApp) GetType() *MenuType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *MenuButtonWebApp) GetWebApp() *WebAppInfo {
	if t == nil {
		return nil
	}
	return &t.WebApp
}

// Message
// This object represents a message.
type Message struct {
	// Chat
	// Conversation the message belongs to
	Chat Chat `json:"chat"`
	// Date
	// Date the message was sent in Unix time
	Date int64 `json:"date"`
	// MessageID
	// Unique message identifier inside this chat
	MessageID int64 `json:"message_id"`
	// Animation
	// Message is an animation, information about the animation. For backward compatibility, when
	// this field is set, the document field will also be set
	Animation *Animation `json:"animation,omitempty"`
	// Audio
	// Message is an audio file, information about the file
	Audio *Audio `json:"audio,omitempty"`
	// AuthorSignature
	// Signature of the post author for messages in channels, or the custom title of an anonymous
	// group administrator
	AuthorSignature *string `json:"author_signature,omitempty"`
	// Caption
	// Caption for the animation, audio, document, photo, video or voice
	Caption *string `json:"caption,omitempty"`
	// CaptionEntities
	// For messages with a caption, special entities like usernames, URLs, bot commands, etc. that
	// appear in the caption
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`
	// ChannelChatCreated
	// Service message: the channel has been created. This field can't be received in a message
	// coming through updates, because bot can't be a member of a channel when it is created. It
	// can only be found in reply_to_message if someone replies to a very first message in a
	// channel.
	ChannelChatCreated *bool `json:"channel_chat_created,omitempty"`
	// ChatShared
	// Service message: a chat was shared with the bot
	ChatShared *ChatShared `json:"chat_shared,omitempty"`
	// ConnectedWebsite
	// The domain name of the website on which the user has logged in. More about Telegram Login »
	ConnectedWebsite *string `json:"connected_website,omitempty"`
	// Contact
	// Message is a shared contact, information about the contact
	Contact *Contact `json:"contact,omitempty"`
	// DeleteChatPhoto
	// Service message: the chat photo was deleted
	DeleteChatPhoto *bool `json:"delete_chat_photo,omitempty"`
	// Dice
	// Message is a dice with random value
	Dice *Dice `json:"dice,omitempty"`
	// Document
	// Message is a general file, information about the file
	Document *Document `json:"document,omitempty"`
	// EditDate
	// Date the message was last edited in Unix time
	EditDate *int64 `json:"edit_date,omitempty"`
	// Entities
	// For text messages, special entities like usernames, URLs, bot commands, etc. that appear in
	// the text
	Entities []MessageEntity `json:"entities,omitempty"`
	// ForumTopicClosed
	// Service message: forum topic closed
	ForumTopicClosed *ForumTopicClosed `json:"forum_topic_closed,omitempty"`
	// ForumTopicCreated
	// Service message: forum topic created
	ForumTopicCreated *ForumTopicCreated `json:"forum_topic_created,omitempty"`
	// ForumTopicEdited
	// Service message: forum topic edited
	ForumTopicEdited *ForumTopicEdited `json:"forum_topic_edited,omitempty"`
	// ForumTopicReopened
	// Service message: forum topic reopened
	ForumTopicReopened *ForumTopicReopened `json:"forum_topic_reopened,omitempty"`
	// ForwardDate
	// For forwarded messages, date the original message was sent in Unix time
	ForwardDate *int64 `json:"forward_date,omitempty"`
	// ForwardFrom
	// For forwarded messages, sender of the original message
	ForwardFrom *User `json:"forward_from,omitempty"`
	// ForwardFromChat
	// For messages forwarded from channels or from anonymous administrators, information about the
	// original sender chat
	ForwardFromChat *Chat `json:"forward_from_chat,omitempty"`
	// ForwardFromMessageID
	// For messages forwarded from channels, identifier of the original message in the channel
	ForwardFromMessageID *int64 `json:"forward_from_message_id,omitempty"`
	// ForwardSenderName
	// Sender's name for messages forwarded from users who disallow adding a link to their account
	// in forwarded messages
	ForwardSenderName *string `json:"forward_sender_name,omitempty"`
	// ForwardSignature
	// For forwarded messages that were originally sent in channels or by an anonymous chat
	// administrator, signature of the message sender if present
	ForwardSignature *string `json:"forward_signature,omitempty"`
	// From
	// Sender of the message; empty for messages sent to channels. For backward compatibility, the
	// field contains a fake sender user in non-channel chats, if the message was sent on behalf of
	// a chat.
	From *User `json:"from,omitempty"`
	// Game
	// Message is a game, information about the game. More about games »
	Game *Game `json:"game,omitempty"`
	// GeneralForumTopicHidden
	// Service message: the 'General' forum topic hidden
	GeneralForumTopicHidden *GeneralForumTopicHidden `json:"general_forum_topic_hidden,omitempty"`
	// GeneralForumTopicUnhidden
	// Service message: the 'General' forum topic unhidden
	GeneralForumTopicUnhidden *GeneralForumTopicUnhidden `json:"general_forum_topic_unhidden,omitempty"`
	// GroupChatCreated
	// Service message: the group has been created
	GroupChatCreated *bool `json:"group_chat_created,omitempty"`
	// HasMediaSpoiler
	// True, if the message media is covered by a spoiler animation
	HasMediaSpoiler *bool `json:"has_media_spoiler,omitempty"`
	// HasProtectedContent
	// True, if the message can't be forwarded
	HasProtectedContent *bool `json:"has_protected_content,omitempty"`
	// Invoice
	// Message is an invoice for a payment, information about the invoice. More about payments »
	Invoice *Invoice `json:"invoice,omitempty"`
	// IsAutomaticForward
	// True, if the message is a channel post that was automatically forwarded to the connected
	// discussion group
	IsAutomaticForward *bool `json:"is_automatic_forward,omitempty"`
	// IsTopicMessage
	// True, if the message is sent to a forum topic
	IsTopicMessage *bool `json:"is_topic_message,omitempty"`
	// LeftChatMember
	// A member was removed from the group, information about them (this member may be the bot
	// itself)
	LeftChatMember *User `json:"left_chat_member,omitempty"`
	// Location
	// Message is a shared location, information about the location
	Location *Location `json:"location,omitempty"`
	// MediaGroupID
	// The unique identifier of a media message group this message belongs to
	MediaGroupID *string `json:"media_group_id,omitempty"`
	// MessageAutoDeleteTimerChanged
	// Service message: auto-delete timer settings changed in the chat
	MessageAutoDeleteTimerChanged *MessageAutoDeleteTimerChanged `json:"message_auto_delete_timer_changed,omitempty"`
	// MessageThreadID
	// Unique identifier of a message thread to which the message belongs; for supergroups only
	MessageThreadID *int64 `json:"message_thread_id,omitempty"`
	// MigrateFromChatID
	// The supergroup has been migrated from a group with the specified identifier. This number may
	// have more than 32 significant bits and some programming languages may have difficulty/silent
	// defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit
	// integer or double-precision float type are safe for storing this identifier.
	MigrateFromChatID *int64 `json:"migrate_from_chat_id,omitempty"`
	// MigrateToChatID
	// The group has been migrated to a supergroup with the specified identifier. This number may
	// have more than 32 significant bits and some programming languages may have difficulty/silent
	// defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit
	// integer or double-precision float type are safe for storing this identifier.
	MigrateToChatID *int64 `json:"migrate_to_chat_id,omitempty"`
	// NewChatMembers
	// New members that were added to the group or supergroup and information about them (the bot
	// itself may be one of these members)
	NewChatMembers []User `json:"new_chat_members,omitempty"`
	// NewChatPhoto
	// A chat photo was change to this value
	NewChatPhoto []PhotoSize `json:"new_chat_photo,omitempty"`
	// NewChatTitle
	// A chat title was changed to this value
	NewChatTitle *string `json:"new_chat_title,omitempty"`
	// PassportData
	// Telegram Passport data
	PassportData *PassportData `json:"passport_data,omitempty"`
	// Photo
	// Message is a photo, available sizes of the photo
	Photo []PhotoSize `json:"photo,omitempty"`
	// PinnedMessage
	// Specified message was pinned. Note that the Message object in this field will not contain
	// further reply_to_message fields even if it is itself a reply.
	PinnedMessage *Message `json:"pinned_message,omitempty"`
	// Poll
	// Message is a native poll, information about the poll
	Poll *Poll `json:"poll,omitempty"`
	// ProximityAlertTriggered
	// Service message. A user in the chat triggered another user's proximity alert while sharing
	// Live Location.
	ProximityAlertTriggered *ProximityAlertTriggered `json:"proximity_alert_triggered,omitempty"`
	// ReplyMarkup
	// Inline keyboard attached to the message. login_url buttons are represented as ordinary url
	// buttons.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessage
	// For replies, the original message. Note that the Message object in this field will not
	// contain further reply_to_message fields even if it itself is a reply.
	ReplyToMessage *Message `json:"reply_to_message,omitempty"`
	// SenderChat
	// Sender of the message, sent on behalf of a chat. For example, the channel itself for channel
	// posts, the supergroup itself for messages from anonymous group administrators, the linked
	// channel for messages automatically forwarded to the discussion group. For backward
	// compatibility, the field from contains a fake sender user in non-channel chats, if the
	// message was sent on behalf of a chat.
	SenderChat *Chat `json:"sender_chat,omitempty"`
	// Sticker
	// Message is a sticker, information about the sticker
	Sticker *Sticker `json:"sticker,omitempty"`
	// SuccessfulPayment
	// Message is a service message about a successful payment, information about the payment. More
	// about payments »
	SuccessfulPayment *SuccessfulPayment `json:"successful_payment,omitempty"`
	// SupergroupChatCreated
	// Service message: the supergroup has been created. This field can't be received in a message
	// coming through updates, because bot can't be a member of a supergroup when it is created. It
	// can only be found in reply_to_message if someone replies to a very first message in a
	// directly created supergroup.
	SupergroupChatCreated *bool `json:"supergroup_chat_created,omitempty"`
	// Text
	// For text messages, the actual UTF-8 text of the message
	Text *string `json:"text,omitempty"`
	// UserShared
	// Service message: a user was shared with the bot
	UserShared *UserShared `json:"user_shared,omitempty"`
	// Venue
	// Message is a venue, information about the venue. For backward compatibility, when this field
	// is set, the location field will also be set
	Venue *Venue `json:"venue,omitempty"`
	// ViaBot
	// Bot through which the message was sent
	ViaBot *User `json:"via_bot,omitempty"`
	// Video
	// Message is a video, information about the video
	Video *Video `json:"video,omitempty"`
	// VideoChatEnded
	// Service message: video chat ended
	VideoChatEnded *VideoChatEnded `json:"video_chat_ended,omitempty"`
	// VideoChatParticipantsInvited
	// Service message: new participants invited to a video chat
	VideoChatParticipantsInvited *VideoChatParticipantsInvited `json:"video_chat_participants_invited,omitempty"`
	// VideoChatScheduled
	// Service message: video chat scheduled
	VideoChatScheduled *VideoChatScheduled `json:"video_chat_scheduled,omitempty"`
	// VideoChatStarted
	// Service message: video chat started
	VideoChatStarted *VideoChatStarted `json:"video_chat_started,omitempty"`
	// VideoNote
	// Message is a video note, information about the video message
	VideoNote *VideoNote `json:"video_note,omitempty"`
	// Voice
	// Message is a voice message, information about the file
	Voice *Voice `json:"voice,omitempty"`
	// WebAppData
	// Service message: data sent by a Web App
	WebAppData *WebAppData `json:"web_app_data,omitempty"`
	// WriteAccessAllowed
	// Service message: the user allowed the bot added to the attachment menu to write messages
	WriteAccessAllowed *WriteAccessAllowed `json:"write_access_allowed,omitempty"`
}

func (t *Message) GetAnimation() *Animation {
	if t == nil {
		return nil
	}
	return t.Animation
}

func (t *Message) GetAudio() *Audio {
	if t == nil {
		return nil
	}
	return t.Audio
}

func (t *Message) GetAuthorSignature() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.AuthorSignature; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetCaption() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Caption; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetChannelChatCreated() *bool {
	if t == nil {
		return nil
	}
	return t.ChannelChatCreated
}

func (t *Message) GetChat() *Chat {
	if t == nil {
		return nil
	}
	return &t.Chat
}

func (t *Message) GetChatShared() *ChatShared {
	if t == nil {
		return nil
	}
	return t.ChatShared
}

func (t *Message) GetConnectedWebsite() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ConnectedWebsite; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetContact() *Contact {
	if t == nil {
		return nil
	}
	return t.Contact
}

func (t *Message) GetDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Date
}

func (t *Message) GetDeleteChatPhoto() *bool {
	if t == nil {
		return nil
	}
	return t.DeleteChatPhoto
}

func (t *Message) GetDice() *Dice {
	if t == nil {
		return nil
	}
	return t.Dice
}

func (t *Message) GetDocument() *Document {
	if t == nil {
		return nil
	}
	return t.Document
}

func (t *Message) GetEditDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.EditDate; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForumTopicClosed() *ForumTopicClosed {
	if t == nil {
		return nil
	}
	return t.ForumTopicClosed
}

func (t *Message) GetForumTopicCreated() *ForumTopicCreated {
	if t == nil {
		return nil
	}
	return t.ForumTopicCreated
}

func (t *Message) GetForumTopicEdited() *ForumTopicEdited {
	if t == nil {
		return nil
	}
	return t.ForumTopicEdited
}

func (t *Message) GetForumTopicReopened() *ForumTopicReopened {
	if t == nil {
		return nil
	}
	return t.ForumTopicReopened
}

func (t *Message) GetForwardDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ForwardDate; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardFrom() *User {
	if t == nil {
		return nil
	}
	return t.ForwardFrom
}

func (t *Message) GetForwardFromChat() *Chat {
	if t == nil {
		return nil
	}
	return t.ForwardFromChat
}

func (t *Message) GetForwardFromMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ForwardFromMessageID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardSenderName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ForwardSenderName; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetForwardSignature() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ForwardSignature; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetFrom() *User {
	if t == nil {
		return nil
	}
	return t.From
}

func (t *Message) GetGame() *Game {
	if t == nil {
		return nil
	}
	return t.Game
}

func (t *Message) GetGeneralForumTopicHidden() *GeneralForumTopicHidden {
	if t == nil {
		return nil
	}
	return t.GeneralForumTopicHidden
}

func (t *Message) GetGeneralForumTopicUnhidden() *GeneralForumTopicUnhidden {
	if t == nil {
		return nil
	}
	return t.GeneralForumTopicUnhidden
}

func (t *Message) GetGroupChatCreated() *bool {
	if t == nil {
		return nil
	}
	return t.GroupChatCreated
}

func (t *Message) GetHasMediaSpoiler() *bool {
	if t == nil {
		return nil
	}
	return t.HasMediaSpoiler
}

func (t *Message) GetHasProtectedContent() *bool {
	if t == nil {
		return nil
	}
	return t.HasProtectedContent
}

func (t *Message) GetInvoice() *Invoice {
	if t == nil {
		return nil
	}
	return t.Invoice
}

func (t *Message) GetIsAutomaticForward() *bool {
	if t == nil {
		return nil
	}
	return t.IsAutomaticForward
}

func (t *Message) GetIsTopicMessage() *bool {
	if t == nil {
		return nil
	}
	return t.IsTopicMessage
}

func (t *Message) GetLeftChatMember() *User {
	if t == nil {
		return nil
	}
	return t.LeftChatMember
}

func (t *Message) GetLocation() *Location {
	if t == nil {
		return nil
	}
	return t.Location
}

func (t *Message) GetMediaGroupID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MediaGroupID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetMessageAutoDeleteTimerChanged() *MessageAutoDeleteTimerChanged {
	if t == nil {
		return nil
	}
	return t.MessageAutoDeleteTimerChanged
}

func (t *Message) GetMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.MessageID
}

func (t *Message) GetMessageThreadID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MessageThreadID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetMigrateFromChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MigrateFromChatID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetMigrateToChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MigrateToChatID; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetNewChatTitle() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.NewChatTitle; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetPassportData() *PassportData {
	if t == nil {
		return nil
	}
	return t.PassportData
}

func (t *Message) GetPinnedMessage() *Message {
	if t == nil {
		return nil
	}
	return t.PinnedMessage
}

func (t *Message) GetPoll() *Poll {
	if t == nil {
		return nil
	}
	return t.Poll
}

func (t *Message) GetProximityAlertTriggered() *ProximityAlertTriggered {
	if t == nil {
		return nil
	}
	return t.ProximityAlertTriggered
}

func (t *Message) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *Message) GetReplyToMessage() *Message {
	if t == nil {
		return nil
	}
	return t.ReplyToMessage
}

func (t *Message) GetSenderChat() *Chat {
	if t == nil {
		return nil
	}
	return t.SenderChat
}

func (t *Message) GetSticker() *Sticker {
	if t == nil {
		return nil
	}
	return t.Sticker
}

func (t *Message) GetSuccessfulPayment() *SuccessfulPayment {
	if t == nil {
		return nil
	}
	return t.SuccessfulPayment
}

func (t *Message) GetSupergroupChatCreated() *bool {
	if t == nil {
		return nil
	}
	return t.SupergroupChatCreated
}

func (t *Message) GetText() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Text; field != nil {
		return *field
	}
	return res
}

func (t *Message) GetUserShared() *UserShared {
	if t == nil {
		return nil
	}
	return t.UserShared
}

func (t *Message) GetVenue() *Venue {
	if t == nil {
		return nil
	}
	return t.Venue
}

func (t *Message) GetViaBot() *User {
	if t == nil {
		return nil
	}
	return t.ViaBot
}

func (t *Message) GetVideo() *Video {
	if t == nil {
		return nil
	}
	return t.Video
}

func (t *Message) GetVideoChatEnded() *VideoChatEnded {
	if t == nil {
		return nil
	}
	return t.VideoChatEnded
}

func (t *Message) GetVideoChatParticipantsInvited() *VideoChatParticipantsInvited {
	if t == nil {
		return nil
	}
	return t.VideoChatParticipantsInvited
}

func (t *Message) GetVideoChatScheduled() *VideoChatScheduled {
	if t == nil {
		return nil
	}
	return t.VideoChatScheduled
}

func (t *Message) GetVideoChatStarted() *VideoChatStarted {
	if t == nil {
		return nil
	}
	return t.VideoChatStarted
}

func (t *Message) GetVideoNote() *VideoNote {
	if t == nil {
		return nil
	}
	return t.VideoNote
}

func (t *Message) GetVoice() *Voice {
	if t == nil {
		return nil
	}
	return t.Voice
}

func (t *Message) GetWebAppData() *WebAppData {
	if t == nil {
		return nil
	}
	return t.WebAppData
}

func (t *Message) GetWriteAccessAllowed() *WriteAccessAllowed {
	if t == nil {
		return nil
	}
	return t.WriteAccessAllowed
}

// MessageAutoDeleteTimerChanged
// This object represents a service message about a change in auto-delete timer settings.
type MessageAutoDeleteTimerChanged struct {
	// MessageAutoDeleteTime
	// New auto-delete time for messages in the chat; in seconds
	MessageAutoDeleteTime int64 `json:"message_auto_delete_time"`
}

func (t *MessageAutoDeleteTimerChanged) GetMessageAutoDeleteTime() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.MessageAutoDeleteTime
}

// MessageEntity
// This object represents one special entity in a text message. For example, hashtags, usernames,
// URLs, etc.
type MessageEntity struct {
	// Length
	// Length of the entity in UTF-16 code units
	Length int64 `json:"length"`
	// Offset
	// Offset in UTF-16 code units to the start of the entity
	Offset int64 `json:"offset"`
	// Type
	// Type of the entity. Currently, can be "mention" (@username), "hashtag" (#hashtag), "cashtag"
	// ($USD), "bot_command" (/start@jobs_bot), "url" (https://telegram.org), "email"
	// (do-not-reply@telegram.org), "phone_number" (+1-212-555-0123), "bold" (bold text), "italic"
	// (italic text), "underline" (underlined text), "strikethrough" (strikethrough text),
	// "spoiler" (spoiler message), "code" (monowidth string), "pre" (monowidth block), "text_link"
	// (for clickable text URLs), "text_mention" (for users without usernames), "custom_emoji" (for
	// inline custom emoji stickers)
	Type EntityType `json:"type"`
	// CustomEmojiID
	// For "custom_emoji" only, unique identifier of the custom emoji. Use getCustomEmojiStickers
	// to get full information about the sticker
	CustomEmojiID *string `json:"custom_emoji_id,omitempty"`
	// Language
	// For "pre" only, the programming language of the entity text
	Language *string `json:"language,omitempty"`
	// URL
	// For "text_link" only, URL that will be opened after user taps on the text
	URL *string `json:"url,omitempty"`
	// User
	// For "text_mention" only, the mentioned user
	User *User `json:"user,omitempty"`
}

func (t *MessageEntity) GetCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *MessageEntity) GetLanguage() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Language; field != nil {
		return *field
	}
	return res
}

func (t *MessageEntity) GetLength() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Length
}

func (t *MessageEntity) GetOffset() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Offset
}

func (t *MessageEntity) GetType() *EntityType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *MessageEntity) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.URL; field != nil {
		return *field
	}
	return res
}

func (t *MessageEntity) GetUser() *User {
	if t == nil {
		return nil
	}
	return t.User
}

// MessageID
// This object represents a unique message identifier.
type MessageID struct {
	// MessageID
	// Unique message identifier
	MessageID int64 `json:"message_id"`
}

func (t *MessageID) GetMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.MessageID
}

// OrderInfo
// This object represents information about an order.
type OrderInfo struct {
	// Email
	// User email
	Email *string `json:"email,omitempty"`
	// Name
	// User name
	Name *string `json:"name,omitempty"`
	// PhoneNumber
	// User's phone number
	PhoneNumber *string `json:"phone_number,omitempty"`
	// ShippingAddress
	// User shipping address
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

func (t *OrderInfo) GetEmail() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Email; field != nil {
		return *field
	}
	return res
}

func (t *OrderInfo) GetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Name; field != nil {
		return *field
	}
	return res
}

func (t *OrderInfo) GetPhoneNumber() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *OrderInfo) GetShippingAddress() *ShippingAddress {
	if t == nil {
		return nil
	}
	return t.ShippingAddress
}

// PassportData
// Describes Telegram Passport data shared with the bot by the user.
type PassportData struct {
	// Credentials
	// Encrypted credentials required to decrypt the data
	Credentials EncryptedCredentials `json:"credentials"`
	// Data
	// Array with information about documents and other Telegram Passport elements that was shared
	// with the bot
	Data []EncryptedPassportElement `json:"data"`
}

func (t *PassportData) GetCredentials() *EncryptedCredentials {
	if t == nil {
		return nil
	}
	return &t.Credentials
}

// PassportElementError
// This object represents an error in the Telegram Passport element which was submitted that should
// be resolved by the user. It should be one of:
type PassportElementError struct {
	// DataHash
	// Base64-encoded data hash
	DataHash string `json:"data_hash"`
	// FieldName
	// Name of the data field which has the error
	FieldName string `json:"field_name"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be data
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the error, one of "personal_details",
	// "passport", "driver_license", "identity_card", "internal_passport", "address"
	Type PassportType `json:"type"`
}

func (t *PassportElementError) GetDataHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.DataHash
}

func (t *PassportElementError) GetFieldName() string {
	var res string
	if t == nil {
		return res
	}
	return t.FieldName
}

func (t *PassportElementError) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementError) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementError) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorDataField
// Represents an issue in one of the data fields that was provided by the user. The error is
// considered resolved when the field's value changes.
type PassportElementErrorDataField struct {
	// DataHash
	// Base64-encoded data hash
	DataHash string `json:"data_hash"`
	// FieldName
	// Name of the data field which has the error
	FieldName string `json:"field_name"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be data
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the error, one of "personal_details",
	// "passport", "driver_license", "identity_card", "internal_passport", "address"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorDataField) GetDataHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.DataHash
}

func (t *PassportElementErrorDataField) GetFieldName() string {
	var res string
	if t == nil {
		return res
	}
	return t.FieldName
}

func (t *PassportElementErrorDataField) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorDataField) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorDataField) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorFile
// Represents an issue with a document scan. The error is considered resolved when the file with
// the document scan changes.
type PassportElementErrorFile struct {
	// FileHash
	// Base64-encoded file hash
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be file
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "utility_bill",
	// "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorFile) GetFileHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileHash
}

func (t *PassportElementErrorFile) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorFile) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorFile) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorFiles
// Represents an issue with a list of scans. The error is considered resolved when the list of
// files containing the scans changes.
type PassportElementErrorFiles struct {
	// FileHashes
	// List of base64-encoded file hashes
	FileHashes []string `json:"file_hashes"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be files
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "utility_bill",
	// "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorFiles) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorFiles) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorFiles) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorFrontSide
// Represents an issue with the front side of a document. The error is considered resolved when the
// file with the front side of the document changes.
type PassportElementErrorFrontSide struct {
	// FileHash
	// Base64-encoded hash of the file with the front side of the document
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be front_side
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorFrontSide) GetFileHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileHash
}

func (t *PassportElementErrorFrontSide) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorFrontSide) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorFrontSide) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorReverseSide
// Represents an issue with the reverse side of a document. The error is considered resolved when
// the file with reverse side of the document changes.
type PassportElementErrorReverseSide struct {
	// FileHash
	// Base64-encoded hash of the file with the reverse side of the document
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be reverse_side
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "driver_license",
	// "identity_card"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorReverseSide) GetFileHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileHash
}

func (t *PassportElementErrorReverseSide) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorReverseSide) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorReverseSide) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorSelfie
// Represents an issue with the selfie with a document. The error is considered resolved when the
// file with the selfie changes.
type PassportElementErrorSelfie struct {
	// FileHash
	// Base64-encoded hash of the file with the selfie
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be selfie
	Source string `json:"source"`
	// Type
	// The section of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorSelfie) GetFileHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileHash
}

func (t *PassportElementErrorSelfie) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorSelfie) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorSelfie) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorTranslationFile
// Represents an issue with one of the files that constitute the translation of a document. The
// error is considered resolved when the file changes.
type PassportElementErrorTranslationFile struct {
	// FileHash
	// Base64-encoded file hash
	FileHash string `json:"file_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be translation_file
	Source string `json:"source"`
	// Type
	// Type of element of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement",
	// "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorTranslationFile) GetFileHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileHash
}

func (t *PassportElementErrorTranslationFile) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorTranslationFile) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorTranslationFile) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorTranslationFiles
// Represents an issue with the translated version of a document. The error is considered resolved
// when a file with the document translation change.
type PassportElementErrorTranslationFiles struct {
	// FileHashes
	// List of base64-encoded file hashes
	FileHashes []string `json:"file_hashes"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be translation_files
	Source string `json:"source"`
	// Type
	// Type of element of the user's Telegram Passport which has the issue, one of "passport",
	// "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement",
	// "rental_agreement", "passport_registration", "temporary_registration"
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorTranslationFiles) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorTranslationFiles) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorTranslationFiles) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportElementErrorUnspecified
// Represents an issue in an unspecified place. The error is considered resolved when new data is
// added.
type PassportElementErrorUnspecified struct {
	// ElementHash
	// Base64-encoded element hash
	ElementHash string `json:"element_hash"`
	// Message
	// Error message
	Message string `json:"message"`
	// Source
	// Error source, must be unspecified
	Source string `json:"source"`
	// Type
	// Type of element of the user's Telegram Passport which has the issue
	Type PassportType `json:"type"`
}

func (t *PassportElementErrorUnspecified) GetElementHash() string {
	var res string
	if t == nil {
		return res
	}
	return t.ElementHash
}

func (t *PassportElementErrorUnspecified) GetMessage() string {
	var res string
	if t == nil {
		return res
	}
	return t.Message
}

func (t *PassportElementErrorUnspecified) GetSource() string {
	var res string
	if t == nil {
		return res
	}
	return t.Source
}

func (t *PassportElementErrorUnspecified) GetType() *PassportType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PassportFile
// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport
// files are in JPEG format when decrypted and don't exceed 10MB.
type PassportFile struct {
	// FileDate
	// Unix time when the file was uploaded
	FileDate int64 `json:"file_date"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileSize
	// File size in bytes
	FileSize int64 `json:"file_size"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
}

func (t *PassportFile) GetFileDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.FileDate
}

func (t *PassportFile) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *PassportFile) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.FileSize
}

func (t *PassportFile) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

// Payments
// Your bot can accept payments from Telegram users. Please see the introduction to payments for
// more details on the process and how to set up payments for your bot. Please note that users will
// need Telegram v.4.0 or higher to use payments (released on May 18, 2017).
type Payments struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payment provider token, obtained via @BotFather
	ProviderToken string `json:"provider_token"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// AllowSendingWithoutReply
	// Pass True if the message should be sent even if the specified replied-to message is not
	// found
	AllowSendingWithoutReply *bool `json:"allow_sending_without_reply,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification *bool `json:"disable_notification,omitempty"`
	// IsFlexible
	// Pass True if the final price depends on the shipping method
	IsFlexible *bool `json:"is_flexible,omitempty"`
	// MaxTipAmount
	// The maximum accepted amount for tips in the smallest units of the currency (integer, not
	// float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the
	// exp parameter in currencies.json, it shows the number of digits past the decimal point for
	// each currency (2 for the majority of currencies). Defaults to 0
	MaxTipAmount *int64 `json:"max_tip_amount,omitempty"`
	// MessageThreadID
	// Unique identifier for the target message thread (topic) of the forum; for forum supergroups
	// only
	MessageThreadID *int64 `json:"message_thread_id,omitempty"`
	// NeedEmail
	// Pass True if you require the user's email address to complete the order
	NeedEmail *bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True if you require the user's full name to complete the order
	NeedName *bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True if you require the user's phone number to complete the order
	NeedPhoneNumber *bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True if you require the user's shipping address to complete the order
	NeedShippingAddress *bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight *int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size in bytes
	PhotoSize *int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service. People like it better when they see what they are paying for.
	PhotoURL *string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth *int64 `json:"photo_width,omitempty"`
	// ProtectContent
	// Protects the contents of the sent message from forwarding and saving
	ProtectContent *bool `json:"protect_content,omitempty"`
	// ProviderData
	// JSON-serialized data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData *string `json:"provider_data,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will
	// be shown. If not empty, the first button must be a Pay button.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID *int64 `json:"reply_to_message_id,omitempty"`
	// SendEmailToProvider
	// Pass True if the user's email address should be sent to provider
	SendEmailToProvider *bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True if the user's phone number should be sent to provider
	SendPhoneNumberToProvider *bool `json:"send_phone_number_to_provider,omitempty"`
	// StartParameter
	// Unique deep-linking parameter. If left empty, forwarded copies of the sent message will have
	// a Pay button, allowing multiple users to pay directly from the forwarded message, using the
	// same invoice. If non-empty, forwarded copies of the sent message will have a URL button with
	// a deep link to the bot (instead of a Pay button), with the value used as the start parameter
	StartParameter *string `json:"start_parameter,omitempty"`
	// SuggestedTipAmounts
	// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency
	// (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested
	// tip amounts must be positive, passed in a strictly increased order and must not exceed
	// max_tip_amount.
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts,omitempty"`
}

func (t *Payments) GetAllowSendingWithoutReply() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.AllowSendingWithoutReply; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetChatID() IntStr {
	var res IntStr
	if t == nil {
		return res
	}
	return t.ChatID
}

func (t *Payments) GetCurrency() string {
	var res string
	if t == nil {
		return res
	}
	return t.Currency
}

func (t *Payments) GetDescription() string {
	var res string
	if t == nil {
		return res
	}
	return t.Description
}

func (t *Payments) GetDisableNotification() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.DisableNotification; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetIsFlexible() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.IsFlexible; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetMaxTipAmount() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MaxTipAmount; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetMessageThreadID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MessageThreadID; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedEmail() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedEmail; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedName() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedName; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedPhoneNumber() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedPhoneNumber; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetNeedShippingAddress() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.NeedShippingAddress; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPayload() string {
	var res string
	if t == nil {
		return res
	}
	return t.Payload
}

func (t *Payments) GetPhotoHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoHeight; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoSize; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoURL() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.PhotoURL; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetPhotoWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.PhotoWidth; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetProtectContent() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ProtectContent; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetProviderData() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ProviderData; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetProviderToken() string {
	var res string
	if t == nil {
		return res
	}
	return t.ProviderToken
}

func (t *Payments) GetReplyMarkup() *InlineKeyboardMarkup {
	if t == nil {
		return nil
	}
	return t.ReplyMarkup
}

func (t *Payments) GetReplyToMessageID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.ReplyToMessageID; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetSendEmailToProvider() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SendEmailToProvider; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetSendPhoneNumberToProvider() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SendPhoneNumberToProvider; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetStartParameter() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.StartParameter; field != nil {
		return *field
	}
	return res
}

func (t *Payments) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// PhotoSize
// This object represents one size of a photo or a file / sticker thumbnail.
type PhotoSize struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Photo height
	Height int64 `json:"height"`
	// Width
	// Photo width
	Width int64 `json:"width"`
	// FileSize
	// File size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
}

func (t *PhotoSize) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *PhotoSize) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *PhotoSize) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *PhotoSize) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Height
}

func (t *PhotoSize) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Width
}

// Poll
// This object contains information about a poll.
type Poll struct {
	// AllowsMultipleAnswers
	// True, if the poll allows multiple answers
	AllowsMultipleAnswers bool `json:"allows_multiple_answers"`
	// ID
	// Unique poll identifier
	ID string `json:"id"`
	// IsAnonymous
	// True, if the poll is anonymous
	IsAnonymous bool `json:"is_anonymous"`
	// IsClosed
	// True, if the poll is closed
	IsClosed bool `json:"is_closed"`
	// Options
	// List of poll options
	Options []PollOption `json:"options"`
	// Question
	// Poll question, 1-300 characters
	Question string `json:"question"`
	// TotalVoterCount
	// Total number of users that voted in the poll
	TotalVoterCount int64 `json:"total_voter_count"`
	// Type
	// Poll type, currently can be "regular" or "quiz"
	Type PollType `json:"type"`
	// CloseDate
	// Point in time (Unix timestamp) when the poll will be automatically closed
	CloseDate *int64 `json:"close_date,omitempty"`
	// CorrectOptionID
	// 0-based identifier of the correct answer option. Available only for polls in the quiz mode,
	// which are closed, or was sent (not forwarded) by the bot or to the private chat with the
	// bot.
	CorrectOptionID *int64 `json:"correct_option_id,omitempty"`
	// Explanation
	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a
	// quiz-style poll, 0-200 characters
	Explanation *string `json:"explanation,omitempty"`
	// ExplanationEntities
	// Special entities like usernames, URLs, bot commands, etc. that appear in the explanation
	ExplanationEntities []MessageEntity `json:"explanation_entities,omitempty"`
	// OpenPeriod
	// Amount of time in seconds the poll will be active after creation
	OpenPeriod *int64 `json:"open_period,omitempty"`
}

func (t *Poll) GetAllowsMultipleAnswers() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.AllowsMultipleAnswers
}

func (t *Poll) GetCloseDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.CloseDate; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetCorrectOptionID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.CorrectOptionID; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetExplanation() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Explanation; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *Poll) GetIsAnonymous() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnonymous
}

func (t *Poll) GetIsClosed() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsClosed
}

func (t *Poll) GetOpenPeriod() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.OpenPeriod; field != nil {
		return *field
	}
	return res
}

func (t *Poll) GetQuestion() string {
	var res string
	if t == nil {
		return res
	}
	return t.Question
}

func (t *Poll) GetTotalVoterCount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.TotalVoterCount
}

func (t *Poll) GetType() *PollType {
	if t == nil {
		return nil
	}
	return &t.Type
}

// PollAnswer
// This object represents an answer of a user in a non-anonymous poll.
type PollAnswer struct {
	// OptionIDs
	// 0-based identifiers of answer options, chosen by the user. May be empty if the user
	// retracted their vote.
	OptionIDs []int64 `json:"option_ids"`
	// PollID
	// Unique poll identifier
	PollID string `json:"poll_id"`
	// User
	// The user, who changed the answer to the poll
	User User `json:"user"`
}

func (t *PollAnswer) GetPollID() string {
	var res string
	if t == nil {
		return res
	}
	return t.PollID
}

func (t *PollAnswer) GetUser() *User {
	if t == nil {
		return nil
	}
	return &t.User
}

// PollOption
// This object contains information about one answer option in a poll.
type PollOption struct {
	// Text
	// Option text, 1-100 characters
	Text string `json:"text"`
	// VoterCount
	// Number of users that voted for this option
	VoterCount int64 `json:"voter_count"`
}

func (t *PollOption) GetText() string {
	var res string
	if t == nil {
		return res
	}
	return t.Text
}

func (t *PollOption) GetVoterCount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.VoterCount
}

// PreCheckoutQuery
// This object contains information about an incoming pre-checkout query.
type PreCheckoutQuery struct {
	// Currency
	// Three-letter ISO 4217 currency code
	Currency string `json:"currency"`
	// From
	// User who sent the query
	From User `json:"from"`
	// ID
	// Unique query identifier
	ID string `json:"id"`
	// InvoicePayload
	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// TotalAmount
	// Total price in the smallest units of the currency (integer, not float/double). For example,
	// for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it
	// shows the number of digits past the decimal point for each currency (2 for the majority of
	// currencies).
	TotalAmount int64 `json:"total_amount"`
	// OrderInfo
	// Order information provided by the user
	OrderInfo *OrderInfo `json:"order_info,omitempty"`
	// ShippingOptionID
	// Identifier of the shipping option chosen by the user
	ShippingOptionID *string `json:"shipping_option_id,omitempty"`
}

func (t *PreCheckoutQuery) GetCurrency() string {
	var res string
	if t == nil {
		return res
	}
	return t.Currency
}

func (t *PreCheckoutQuery) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *PreCheckoutQuery) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *PreCheckoutQuery) GetInvoicePayload() string {
	var res string
	if t == nil {
		return res
	}
	return t.InvoicePayload
}

func (t *PreCheckoutQuery) GetOrderInfo() *OrderInfo {
	if t == nil {
		return nil
	}
	return t.OrderInfo
}

func (t *PreCheckoutQuery) GetShippingOptionID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ShippingOptionID; field != nil {
		return *field
	}
	return res
}

func (t *PreCheckoutQuery) GetTotalAmount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.TotalAmount
}

// ProximityAlertTriggered
// This object represents the content of a service message, sent whenever a user in the chat
// triggers a proximity alert set by another user.
type ProximityAlertTriggered struct {
	// Distance
	// The distance between the users
	Distance int64 `json:"distance"`
	// Traveler
	// User that triggered the alert
	Traveler User `json:"traveler"`
	// Watcher
	// User that set the alert
	Watcher User `json:"watcher"`
}

func (t *ProximityAlertTriggered) GetDistance() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Distance
}

func (t *ProximityAlertTriggered) GetTraveler() *User {
	if t == nil {
		return nil
	}
	return &t.Traveler
}

func (t *ProximityAlertTriggered) GetWatcher() *User {
	if t == nil {
		return nil
	}
	return &t.Watcher
}

// ReplyKeyboardMarkup
// This object represents a custom keyboard with reply options (see Introduction to bots for
// details and examples).
type ReplyKeyboardMarkup struct {
	// Keyboard
	// Array of button rows, each represented by an Array of KeyboardButton objects
	Keyboard [][]KeyboardButton `json:"keyboard"`
	// InputFieldPlaceholder
	// The placeholder to be shown in the input field when the keyboard is active; 1-64 characters
	InputFieldPlaceholder *string `json:"input_field_placeholder,omitempty"`
	// IsPersistent
	// Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults
	// to false, in which case the custom keyboard can be hidden and opened with a keyboard icon.
	IsPersistent *bool `json:"is_persistent,omitempty"`
	// OneTimeKeyboard
	// Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be
	// available, but clients will automatically display the usual letter-keyboard in the chat -
	// the user can press a special button in the input field to see the custom keyboard again.
	// Defaults to false.
	OneTimeKeyboard *bool `json:"one_time_keyboard,omitempty"`
	// ResizeKeyboard
	// Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard
	// smaller if there are just two rows of buttons). Defaults to false, in which case the custom
	// keyboard is always of the same height as the app's standard keyboard.
	ResizeKeyboard *bool `json:"resize_keyboard,omitempty"`
	// Selective
	// Use this parameter if you want to show the keyboard to specific users only. Targets: 1)
	// users that are @mentioned in the text of the Message object; 2) if the bot's message is a
	// reply (has reply_to_message_id), sender of the original message. Example: A user requests to
	// change the bot's language, bot replies to the request with a keyboard to select the new
	// language. Other users in the group don't see the keyboard.
	Selective *bool `json:"selective,omitempty"`
}

func (t *ReplyKeyboardMarkup) GetInputFieldPlaceholder() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InputFieldPlaceholder; field != nil {
		return *field
	}
	return res
}

func (t *ReplyKeyboardMarkup) GetIsPersistent() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.IsPersistent; field != nil {
		return *field
	}
	return res
}

func (t *ReplyKeyboardMarkup) GetOneTimeKeyboard() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.OneTimeKeyboard; field != nil {
		return *field
	}
	return res
}

func (t *ReplyKeyboardMarkup) GetResizeKeyboard() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.ResizeKeyboard; field != nil {
		return *field
	}
	return res
}

func (t *ReplyKeyboardMarkup) GetSelective() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Selective; field != nil {
		return *field
	}
	return res
}

// ReplyKeyboardRemove
// Upon receiving a message with this object, Telegram clients will remove the current custom
// keyboard and display the default letter-keyboard. By default, custom keyboards are displayed
// until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are
// hidden immediately after the user presses a button (see ReplyKeyboardMarkup).
type ReplyKeyboardRemove struct {
	// RemoveKeyboard
	// Requests clients to remove the custom keyboard (user will not be able to summon this
	// keyboard; if you want to hide the keyboard from sight but keep it accessible, use
	// one_time_keyboard in ReplyKeyboardMarkup)
	RemoveKeyboard bool `json:"remove_keyboard"`
	// Selective
	// Use this parameter if you want to remove the keyboard for specific users only. Targets: 1)
	// users that are @mentioned in the text of the Message object; 2) if the bot's message is a
	// reply (has reply_to_message_id), sender of the original message. Example: A user votes in a
	// poll, bot returns confirmation message in reply to the vote and removes the keyboard for
	// that user, while still showing the keyboard with poll options to users who haven't voted
	// yet.
	Selective *bool `json:"selective,omitempty"`
}

func (t *ReplyKeyboardRemove) GetRemoveKeyboard() *bool {
	if t == nil {
		return nil
	}
	return &t.RemoveKeyboard
}

func (t *ReplyKeyboardRemove) GetSelective() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.Selective; field != nil {
		return *field
	}
	return res
}

// ResponseParameters
// Describes why a request was unsuccessful.
type ResponseParameters struct {
	// MigrateToChatID
	// The group has been migrated to a supergroup with the specified identifier. This number may
	// have more than 32 significant bits and some programming languages may have difficulty/silent
	// defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit
	// integer or double-precision float type are safe for storing this identifier.
	MigrateToChatID *int64 `json:"migrate_to_chat_id,omitempty"`
	// RetryAfter
	// In case of exceeding flood control, the number of seconds left to wait before the request
	// can be repeated
	RetryAfter *int64 `json:"retry_after,omitempty"`
}

func (t *ResponseParameters) GetMigrateToChatID() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MigrateToChatID; field != nil {
		return *field
	}
	return res
}

func (t *ResponseParameters) GetRetryAfter() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.RetryAfter; field != nil {
		return *field
	}
	return res
}

// SentWebAppMessage
// Describes an inline message sent by a Web App on behalf of a user.
type SentWebAppMessage struct {
	// InlineMessageID
	// Identifier of the sent inline message. Available only if there is an inline keyboard
	// attached to the message.
	InlineMessageID *string `json:"inline_message_id,omitempty"`
}

func (t *SentWebAppMessage) GetInlineMessageID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.InlineMessageID; field != nil {
		return *field
	}
	return res
}

// ShippingAddress
// This object represents a shipping address.
type ShippingAddress struct {
	// City
	// City
	City string `json:"city"`
	// CountryCode
	// Two-letter ISO 3166-1 alpha-2 country code
	CountryCode string `json:"country_code"`
	// PostCode
	// Address post code
	PostCode string `json:"post_code"`
	// State
	// State, if applicable
	State string `json:"state"`
	// StreetLine1
	// First line for the address
	StreetLine1 string `json:"street_line1"`
	// StreetLine2
	// Second line for the address
	StreetLine2 string `json:"street_line2"`
}

func (t *ShippingAddress) GetCity() string {
	var res string
	if t == nil {
		return res
	}
	return t.City
}

func (t *ShippingAddress) GetCountryCode() string {
	var res string
	if t == nil {
		return res
	}
	return t.CountryCode
}

func (t *ShippingAddress) GetPostCode() string {
	var res string
	if t == nil {
		return res
	}
	return t.PostCode
}

func (t *ShippingAddress) GetState() string {
	var res string
	if t == nil {
		return res
	}
	return t.State
}

func (t *ShippingAddress) GetStreetLine1() string {
	var res string
	if t == nil {
		return res
	}
	return t.StreetLine1
}

func (t *ShippingAddress) GetStreetLine2() string {
	var res string
	if t == nil {
		return res
	}
	return t.StreetLine2
}

// ShippingOption
// This object represents one shipping option.
type ShippingOption struct {
	// ID
	// Shipping option identifier
	ID string `json:"id"`
	// Prices
	// List of price portions
	Prices []LabeledPrice `json:"prices"`
	// Title
	// Option title
	Title string `json:"title"`
}

func (t *ShippingOption) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *ShippingOption) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// ShippingQuery
// This object contains information about an incoming shipping query.
type ShippingQuery struct {
	// From
	// User who sent the query
	From User `json:"from"`
	// ID
	// Unique query identifier
	ID string `json:"id"`
	// InvoicePayload
	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// ShippingAddress
	// User specified shipping address
	ShippingAddress ShippingAddress `json:"shipping_address"`
}

func (t *ShippingQuery) GetFrom() *User {
	if t == nil {
		return nil
	}
	return &t.From
}

func (t *ShippingQuery) GetID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ID
}

func (t *ShippingQuery) GetInvoicePayload() string {
	var res string
	if t == nil {
		return res
	}
	return t.InvoicePayload
}

func (t *ShippingQuery) GetShippingAddress() *ShippingAddress {
	if t == nil {
		return nil
	}
	return &t.ShippingAddress
}

// Sticker
// This object represents a sticker.
type Sticker struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Sticker height
	Height int64 `json:"height"`
	// IsAnimated
	// True, if the sticker is animated
	IsAnimated bool `json:"is_animated"`
	// IsVideo
	// True, if the sticker is a video sticker
	IsVideo bool `json:"is_video"`
	// Type
	// Type of the sticker, currently one of "regular", "mask", "custom_emoji". The type of the
	// sticker is independent from its format, which is determined by the fields is_animated and
	// is_video.
	Type StickerType `json:"type"`
	// Width
	// Sticker width
	Width int64 `json:"width"`
	// CustomEmojiID
	// For custom emoji stickers, unique identifier of the custom emoji
	CustomEmojiID *string `json:"custom_emoji_id,omitempty"`
	// Emoji
	// Emoji associated with the sticker
	Emoji *string `json:"emoji,omitempty"`
	// FileSize
	// File size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// MaskPosition
	// For mask stickers, the position where the mask should be placed
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// NeedsRepainting
	// True, if the sticker must be repainted to a text color in messages, the color of the
	// Telegram Premium badge in emoji status, white color on chat photos, or another appropriate
	// color in other places
	NeedsRepainting *bool `json:"needs_repainting,omitempty"`
	// PremiumAnimation
	// For premium regular stickers, premium animation for the sticker
	PremiumAnimation *File `json:"premium_animation,omitempty"`
	// SetName
	// Name of the sticker set to which the sticker belongs
	SetName *string `json:"set_name,omitempty"`
	// Thumbnail
	// Sticker thumbnail in the .WEBP or .JPG format
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *Sticker) GetCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetEmoji() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Emoji; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Sticker) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Sticker) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Height
}

func (t *Sticker) GetIsAnimated() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnimated
}

func (t *Sticker) GetIsVideo() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsVideo
}

func (t *Sticker) GetMaskPosition() *MaskPosition {
	if t == nil {
		return nil
	}
	return t.MaskPosition
}

func (t *Sticker) GetNeedsRepainting() *bool {
	if t == nil {
		return nil
	}
	return t.NeedsRepainting
}

func (t *Sticker) GetPremiumAnimation() *File {
	if t == nil {
		return nil
	}
	return t.PremiumAnimation
}

func (t *Sticker) GetSetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SetName; field != nil {
		return *field
	}
	return res
}

func (t *Sticker) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *Sticker) GetType() *StickerType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *Sticker) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Width
}

// StickerSet
// This object represents a sticker set.
type StickerSet struct {
	// IsAnimated
	// True, if the sticker set contains animated stickers
	IsAnimated bool `json:"is_animated"`
	// IsVideo
	// True, if the sticker set contains video stickers
	IsVideo bool `json:"is_video"`
	// Name
	// Sticker set name
	Name string `json:"name"`
	// StickerType
	// Type of stickers in the set, currently one of "regular", "mask", "custom_emoji"
	StickerType string `json:"sticker_type"`
	// Stickers
	// List of all set stickers
	Stickers []Sticker `json:"stickers"`
	// Title
	// Sticker set title
	Title string `json:"title"`
	// Thumbnail
	// Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *StickerSet) GetIsAnimated() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnimated
}

func (t *StickerSet) GetIsVideo() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsVideo
}

func (t *StickerSet) GetName() string {
	var res string
	if t == nil {
		return res
	}
	return t.Name
}

func (t *StickerSet) GetStickerType() string {
	var res string
	if t == nil {
		return res
	}
	return t.StickerType
}

func (t *StickerSet) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *StickerSet) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// Stickers
// The following methods and objects allow your bot to handle stickers and sticker sets.
type Stickers struct {
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Sticker height
	Height int64 `json:"height"`
	// IsAnimated
	// True, if the sticker is animated
	IsAnimated bool `json:"is_animated"`
	// IsVideo
	// True, if the sticker is a video sticker
	IsVideo bool `json:"is_video"`
	// Type
	// Type of the sticker, currently one of "regular", "mask", "custom_emoji". The type of the
	// sticker is independent from its format, which is determined by the fields is_animated and
	// is_video.
	Type StickersType `json:"type"`
	// Width
	// Sticker width
	Width int64 `json:"width"`
	// CustomEmojiID
	// For custom emoji stickers, unique identifier of the custom emoji
	CustomEmojiID *string `json:"custom_emoji_id,omitempty"`
	// Emoji
	// Emoji associated with the sticker
	Emoji *string `json:"emoji,omitempty"`
	// FileSize
	// File size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// MaskPosition
	// For mask stickers, the position where the mask should be placed
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// NeedsRepainting
	// True, if the sticker must be repainted to a text color in messages, the color of the
	// Telegram Premium badge in emoji status, white color on chat photos, or another appropriate
	// color in other places
	NeedsRepainting *bool `json:"needs_repainting,omitempty"`
	// PremiumAnimation
	// For premium regular stickers, premium animation for the sticker
	PremiumAnimation *File `json:"premium_animation,omitempty"`
	// SetName
	// Name of the sticker set to which the sticker belongs
	SetName *string `json:"set_name,omitempty"`
	// Thumbnail
	// Sticker thumbnail in the .WEBP or .JPG format
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *Stickers) GetCustomEmojiID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.CustomEmojiID; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetEmoji() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Emoji; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Stickers) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Stickers) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Height
}

func (t *Stickers) GetIsAnimated() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsAnimated
}

func (t *Stickers) GetIsVideo() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsVideo
}

func (t *Stickers) GetMaskPosition() *MaskPosition {
	if t == nil {
		return nil
	}
	return t.MaskPosition
}

func (t *Stickers) GetNeedsRepainting() *bool {
	if t == nil {
		return nil
	}
	return t.NeedsRepainting
}

func (t *Stickers) GetPremiumAnimation() *File {
	if t == nil {
		return nil
	}
	return t.PremiumAnimation
}

func (t *Stickers) GetSetName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.SetName; field != nil {
		return *field
	}
	return res
}

func (t *Stickers) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *Stickers) GetType() *StickersType {
	if t == nil {
		return nil
	}
	return &t.Type
}

func (t *Stickers) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Width
}

// SuccessfulPayment
// This object contains basic information about a successful payment.
type SuccessfulPayment struct {
	// Currency
	// Three-letter ISO 4217 currency code
	Currency string `json:"currency"`
	// InvoicePayload
	// Bot specified invoice payload
	InvoicePayload string `json:"invoice_payload"`
	// ProviderPaymentChargeID
	// Provider payment identifier
	ProviderPaymentChargeID string `json:"provider_payment_charge_id"`
	// TelegramPaymentChargeID
	// Telegram payment identifier
	TelegramPaymentChargeID string `json:"telegram_payment_charge_id"`
	// TotalAmount
	// Total price in the smallest units of the currency (integer, not float/double). For example,
	// for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it
	// shows the number of digits past the decimal point for each currency (2 for the majority of
	// currencies).
	TotalAmount int64 `json:"total_amount"`
	// OrderInfo
	// Order information provided by the user
	OrderInfo *OrderInfo `json:"order_info,omitempty"`
	// ShippingOptionID
	// Identifier of the shipping option chosen by the user
	ShippingOptionID *string `json:"shipping_option_id,omitempty"`
}

func (t *SuccessfulPayment) GetCurrency() string {
	var res string
	if t == nil {
		return res
	}
	return t.Currency
}

func (t *SuccessfulPayment) GetInvoicePayload() string {
	var res string
	if t == nil {
		return res
	}
	return t.InvoicePayload
}

func (t *SuccessfulPayment) GetOrderInfo() *OrderInfo {
	if t == nil {
		return nil
	}
	return t.OrderInfo
}

func (t *SuccessfulPayment) GetProviderPaymentChargeID() string {
	var res string
	if t == nil {
		return res
	}
	return t.ProviderPaymentChargeID
}

func (t *SuccessfulPayment) GetShippingOptionID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.ShippingOptionID; field != nil {
		return *field
	}
	return res
}

func (t *SuccessfulPayment) GetTelegramPaymentChargeID() string {
	var res string
	if t == nil {
		return res
	}
	return t.TelegramPaymentChargeID
}

func (t *SuccessfulPayment) GetTotalAmount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.TotalAmount
}

// SwitchInlineQueryChosenChat
// This object represents an inline button that switches the current user to inline mode in a
// chosen chat, with an optional default inline query.
type SwitchInlineQueryChosenChat struct {
	// AllowBotChats
	// True, if private chats with bots can be chosen
	AllowBotChats *bool `json:"allow_bot_chats,omitempty"`
	// AllowChannelChats
	// True, if channel chats can be chosen
	AllowChannelChats *bool `json:"allow_channel_chats,omitempty"`
	// AllowGroupChats
	// True, if group and supergroup chats can be chosen
	AllowGroupChats *bool `json:"allow_group_chats,omitempty"`
	// AllowUserChats
	// True, if private chats with users can be chosen
	AllowUserChats *bool `json:"allow_user_chats,omitempty"`
	// Query
	// The default inline query to be inserted in the input field. If left empty, only the bot's
	// username will be inserted
	Query *string `json:"query,omitempty"`
}

func (t *SwitchInlineQueryChosenChat) GetAllowBotChats() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.AllowBotChats; field != nil {
		return *field
	}
	return res
}

func (t *SwitchInlineQueryChosenChat) GetAllowChannelChats() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.AllowChannelChats; field != nil {
		return *field
	}
	return res
}

func (t *SwitchInlineQueryChosenChat) GetAllowGroupChats() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.AllowGroupChats; field != nil {
		return *field
	}
	return res
}

func (t *SwitchInlineQueryChosenChat) GetAllowUserChats() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.AllowUserChats; field != nil {
		return *field
	}
	return res
}

func (t *SwitchInlineQueryChosenChat) GetQuery() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Query; field != nil {
		return *field
	}
	return res
}

// Update
// This object represents an incoming update.At most one of the optional parameters can be present
// in any given update.
type Update struct {
	// UpdateID
	// The update's unique identifier. Update identifiers start from a certain positive number and
	// increase sequentially. This ID becomes especially handy if you're using webhooks, since it
	// allows you to ignore repeated updates or to restore the correct update sequence, should they
	// get out of order. If there are no new updates for at least a week, then identifier of the
	// next update will be chosen randomly instead of sequentially.
	UpdateID int64 `json:"update_id"`
	// CallbackQuery
	// New incoming callback query
	CallbackQuery *CallbackQuery `json:"callback_query,omitempty"`
	// ChannelPost
	// New incoming channel post of any kind - text, photo, sticker, etc.
	ChannelPost *Message `json:"channel_post,omitempty"`
	// ChatJoinRequest
	// A request to join the chat has been sent. The bot must have the can_invite_users
	// administrator right in the chat to receive these updates.
	ChatJoinRequest *ChatJoinRequest `json:"chat_join_request,omitempty"`
	// ChatMember
	// A chat member's status was updated in a chat. The bot must be an administrator in the chat
	// and must explicitly specify "chat_member" in the list of allowed_updates to receive these
	// updates.
	ChatMember *ChatMemberUpdated `json:"chat_member,omitempty"`
	// ChosenInlineResult
	// The result of an inline query that was chosen by a user and sent to their chat partner.
	// Please see our documentation on the feedback collecting for details on how to enable these
	// updates for your bot.
	ChosenInlineResult *ChosenInlineResult `json:"chosen_inline_result,omitempty"`
	// EditedChannelPost
	// New version of a channel post that is known to the bot and was edited
	EditedChannelPost *Message `json:"edited_channel_post,omitempty"`
	// EditedMessage
	// New version of a message that is known to the bot and was edited
	EditedMessage *Message `json:"edited_message,omitempty"`
	// InlineQuery
	// New incoming inline query
	InlineQuery *InlineQuery `json:"inline_query,omitempty"`
	// Message
	// New incoming message of any kind - text, photo, sticker, etc.
	Message *Message `json:"message,omitempty"`
	// MyChatMember
	// The bot's chat member status was updated in a chat. For private chats, this update is
	// received only when the bot is blocked or unblocked by the user.
	MyChatMember *ChatMemberUpdated `json:"my_chat_member,omitempty"`
	// Poll
	// New poll state. Bots receive only updates about stopped polls and polls, which are sent by
	// the bot
	Poll *Poll `json:"poll,omitempty"`
	// PollAnswer
	// A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls
	// that were sent by the bot itself.
	PollAnswer *PollAnswer `json:"poll_answer,omitempty"`
	// PreCheckoutQuery
	// New incoming pre-checkout query. Contains full information about checkout
	PreCheckoutQuery *PreCheckoutQuery `json:"pre_checkout_query,omitempty"`
	// ShippingQuery
	// New incoming shipping query. Only for invoices with flexible price
	ShippingQuery *ShippingQuery `json:"shipping_query,omitempty"`
}

func (t *Update) GetCallbackQuery() *CallbackQuery {
	if t == nil {
		return nil
	}
	return t.CallbackQuery
}

func (t *Update) GetChannelPost() *Message {
	if t == nil {
		return nil
	}
	return t.ChannelPost
}

func (t *Update) GetChatJoinRequest() *ChatJoinRequest {
	if t == nil {
		return nil
	}
	return t.ChatJoinRequest
}

func (t *Update) GetChatMember() *ChatMemberUpdated {
	if t == nil {
		return nil
	}
	return t.ChatMember
}

func (t *Update) GetChosenInlineResult() *ChosenInlineResult {
	if t == nil {
		return nil
	}
	return t.ChosenInlineResult
}

func (t *Update) GetEditedChannelPost() *Message {
	if t == nil {
		return nil
	}
	return t.EditedChannelPost
}

func (t *Update) GetEditedMessage() *Message {
	if t == nil {
		return nil
	}
	return t.EditedMessage
}

func (t *Update) GetInlineQuery() *InlineQuery {
	if t == nil {
		return nil
	}
	return t.InlineQuery
}

func (t *Update) GetMessage() *Message {
	if t == nil {
		return nil
	}
	return t.Message
}

func (t *Update) GetMyChatMember() *ChatMemberUpdated {
	if t == nil {
		return nil
	}
	return t.MyChatMember
}

func (t *Update) GetPoll() *Poll {
	if t == nil {
		return nil
	}
	return t.Poll
}

func (t *Update) GetPollAnswer() *PollAnswer {
	if t == nil {
		return nil
	}
	return t.PollAnswer
}

func (t *Update) GetPreCheckoutQuery() *PreCheckoutQuery {
	if t == nil {
		return nil
	}
	return t.PreCheckoutQuery
}

func (t *Update) GetShippingQuery() *ShippingQuery {
	if t == nil {
		return nil
	}
	return t.ShippingQuery
}

func (t *Update) GetUpdateID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UpdateID
}

// User
// This object represents a Telegram user or bot.
type User struct {
	// FirstName
	// User's or bot's first name
	FirstName string `json:"first_name"`
	// ID
	// Unique identifier for this user or bot. This number may have more than 32 significant bits
	// and some programming languages may have difficulty/silent defects in interpreting it. But it
	// has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe
	// for storing this identifier.
	ID int64 `json:"id"`
	// IsBot
	// True, if this user is a bot
	IsBot bool `json:"is_bot"`
	// AddedToAttachmentMenu
	// True, if this user added the bot to the attachment menu
	AddedToAttachmentMenu *bool `json:"added_to_attachment_menu,omitempty"`
	// CanJoinGroups
	// True, if the bot can be invited to groups. Returned only in getMe.
	CanJoinGroups *bool `json:"can_join_groups,omitempty"`
	// CanReadAllGroupMessages
	// True, if privacy mode is disabled for the bot. Returned only in getMe.
	CanReadAllGroupMessages *bool `json:"can_read_all_group_messages,omitempty"`
	// IsPremium
	// True, if this user is a Telegram Premium user
	IsPremium *bool `json:"is_premium,omitempty"`
	// LanguageCode
	// IETF language tag of the user's language
	LanguageCode *string `json:"language_code,omitempty"`
	// LastName
	// User's or bot's last name
	LastName *string `json:"last_name,omitempty"`
	// SupportsInlineQueries
	// True, if the bot supports inline queries. Returned only in getMe.
	SupportsInlineQueries *bool `json:"supports_inline_queries,omitempty"`
	// Username
	// User's or bot's username
	Username *string `json:"username,omitempty"`
}

func (t *User) GetAddedToAttachmentMenu() *bool {
	if t == nil {
		return nil
	}
	return t.AddedToAttachmentMenu
}

func (t *User) GetCanJoinGroups() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanJoinGroups; field != nil {
		return *field
	}
	return res
}

func (t *User) GetCanReadAllGroupMessages() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.CanReadAllGroupMessages; field != nil {
		return *field
	}
	return res
}

func (t *User) GetFirstName() string {
	var res string
	if t == nil {
		return res
	}
	return t.FirstName
}

func (t *User) GetID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.ID
}

func (t *User) GetIsBot() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.IsBot
}

func (t *User) GetIsPremium() *bool {
	if t == nil {
		return nil
	}
	return t.IsPremium
}

func (t *User) GetLanguageCode() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LanguageCode; field != nil {
		return *field
	}
	return res
}

func (t *User) GetLastName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastName; field != nil {
		return *field
	}
	return res
}

func (t *User) GetSupportsInlineQueries() bool {
	var res bool
	if t == nil {
		return res
	}
	if field := t.SupportsInlineQueries; field != nil {
		return *field
	}
	return res
}

func (t *User) GetUsername() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.Username; field != nil {
		return *field
	}
	return res
}

// UserProfilePhotos
// This object represent a user's profile pictures.
type UserProfilePhotos struct {
	// Photos
	// Requested profile pictures (in up to 4 sizes each)
	Photos [][]PhotoSize `json:"photos"`
	// TotalCount
	// Total number of profile pictures the target user has
	TotalCount int64 `json:"total_count"`
}

func (t *UserProfilePhotos) GetTotalCount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.TotalCount
}

// UserShared
// This object contains information about the user whose identifier was shared with the bot using a
// KeyboardButtonRequestUser button.
type UserShared struct {
	// RequestID
	// Identifier of the request
	RequestID int64 `json:"request_id"`
	// UserID
	// Identifier of the shared user. This number may have more than 32 significant bits and some
	// programming languages may have difficulty/silent defects in interpreting it. But it has at
	// most 52 significant bits, so a 64-bit integer or double-precision float type are safe for
	// storing this identifier. The bot may not have access to the user and could be unable to use
	// this identifier, unless the user is already known to the bot by some other means.
	UserID int64 `json:"user_id"`
}

func (t *UserShared) GetRequestID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.RequestID
}

func (t *UserShared) GetUserID() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.UserID
}

// Venue
// This object represents a venue.
type Venue struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// Location
	// Venue location. Can't be a live location
	Location Location `json:"location"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// FoursquareID
	// Foursquare identifier of the venue
	FoursquareID *string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType *string `json:"foursquare_type,omitempty"`
	// GooglePlaceID
	// Google Places identifier of the venue
	GooglePlaceID *string `json:"google_place_id,omitempty"`
	// GooglePlaceType
	// Google Places type of the venue. (See supported types.)
	GooglePlaceType *string `json:"google_place_type,omitempty"`
}

func (t *Venue) GetAddress() string {
	var res string
	if t == nil {
		return res
	}
	return t.Address
}

func (t *Venue) GetFoursquareID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareID; field != nil {
		return *field
	}
	return res
}

func (t *Venue) GetFoursquareType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FoursquareType; field != nil {
		return *field
	}
	return res
}

func (t *Venue) GetGooglePlaceID() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GooglePlaceID; field != nil {
		return *field
	}
	return res
}

func (t *Venue) GetGooglePlaceType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.GooglePlaceType; field != nil {
		return *field
	}
	return res
}

func (t *Venue) GetLocation() *Location {
	if t == nil {
		return nil
	}
	return &t.Location
}

func (t *Venue) GetTitle() string {
	var res string
	if t == nil {
		return res
	}
	return t.Title
}

// Video
// This object represents a video file.
type Video struct {
	// Duration
	// Duration of the video in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Height
	// Video height as defined by sender
	Height int64 `json:"height"`
	// Width
	// Video width as defined by sender
	Width int64 `json:"width"`
	// FileName
	// Original filename as defined by sender
	FileName *string `json:"file_name,omitempty"`
	// FileSize
	// File size in bytes. It can be bigger than 2^31 and some programming languages may have
	// difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a
	// signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
	// Thumbnail
	// Video thumbnail
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *Video) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

func (t *Video) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Video) GetFileName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.FileName; field != nil {
		return *field
	}
	return res
}

func (t *Video) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Video) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Video) GetHeight() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Height
}

func (t *Video) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

func (t *Video) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

func (t *Video) GetWidth() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Width
}

// VideoChatEnded
// This object represents a service message about a video chat ended in the chat.
type VideoChatEnded struct {
	// Duration
	// Video chat duration in seconds
	Duration int64 `json:"duration"`
}

func (t *VideoChatEnded) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

// VideoChatParticipantsInvited
// This object represents a service message about new members invited to a video chat.
type VideoChatParticipantsInvited struct {
	// Users
	// New members that were invited to the video chat
	Users []User `json:"users"`
}

// VideoChatScheduled
// This object represents a service message about a video chat scheduled in the chat.
type VideoChatScheduled struct {
	// StartDate
	// Point in time (Unix timestamp) when the video chat is supposed to be started by a chat
	// administrator
	StartDate int64 `json:"start_date"`
}

func (t *VideoChatScheduled) GetStartDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.StartDate
}

// VideoChatStarted
// This object represents a service message about a video chat started in the chat. Currently holds
// no information.
type VideoChatStarted struct {
	// Duration
	// Video chat duration in seconds
	Duration int64 `json:"duration"`
}

func (t *VideoChatStarted) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

// VideoNote
// This object represents a video message (available in Telegram apps as of v.4.0).
type VideoNote struct {
	// Duration
	// Duration of the video in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// Length
	// Video width and height (diameter of the video message) as defined by sender
	Length int64 `json:"length"`
	// FileSize
	// File size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// Thumbnail
	// Video thumbnail
	Thumbnail *PhotoSize `json:"thumbnail,omitempty"`
}

func (t *VideoNote) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

func (t *VideoNote) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *VideoNote) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *VideoNote) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *VideoNote) GetLength() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Length
}

func (t *VideoNote) GetThumbnail() *PhotoSize {
	if t == nil {
		return nil
	}
	return t.Thumbnail
}

// Voice
// This object represents a voice note.
type Voice struct {
	// Duration
	// Duration of the audio in seconds as defined by sender
	Duration int64 `json:"duration"`
	// FileID
	// Identifier for this file, which can be used to download or reuse the file
	FileID string `json:"file_id"`
	// FileUniqueID
	// Unique identifier for this file, which is supposed to be the same over time and for
	// different bots. Can't be used to download or reuse the file.
	FileUniqueID string `json:"file_unique_id"`
	// FileSize
	// File size in bytes. It can be bigger than 2^31 and some programming languages may have
	// difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a
	// signed 64-bit integer or double-precision float type are safe for storing this value.
	FileSize *int64 `json:"file_size,omitempty"`
	// MimeType
	// MIME type of the file as defined by sender
	MimeType *string `json:"mime_type,omitempty"`
}

func (t *Voice) GetDuration() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.Duration
}

func (t *Voice) GetFileID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileID
}

func (t *Voice) GetFileSize() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.FileSize; field != nil {
		return *field
	}
	return res
}

func (t *Voice) GetFileUniqueID() string {
	var res string
	if t == nil {
		return res
	}
	return t.FileUniqueID
}

func (t *Voice) GetMimeType() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.MimeType; field != nil {
		return *field
	}
	return res
}

// WebAppData
// Describes data sent from a Web App to the bot.
type WebAppData struct {
	// ButtonText
	// Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad
	// client can send arbitrary data in this field.
	ButtonText string `json:"button_text"`
	// Data
	// The data. Be aware that a bad client can send arbitrary data in this field.
	Data string `json:"data"`
}

func (t *WebAppData) GetButtonText() string {
	var res string
	if t == nil {
		return res
	}
	return t.ButtonText
}

func (t *WebAppData) GetData() string {
	var res string
	if t == nil {
		return res
	}
	return t.Data
}

// WebAppInfo
// Describes a Web App.
type WebAppInfo struct {
	// URL
	// An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web
	// Apps
	URL string `json:"url"`
}

func (t *WebAppInfo) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.URL
}

// WebhookInfo
// Describes the current status of a webhook.
type WebhookInfo struct {
	// HasCustomCertificate
	// True, if a custom certificate was provided for webhook certificate checks
	HasCustomCertificate bool `json:"has_custom_certificate"`
	// PendingUpdateCount
	// Number of updates awaiting delivery
	PendingUpdateCount int64 `json:"pending_update_count"`
	// URL
	// Webhook URL, may be empty if webhook is not set up
	URL string `json:"url"`
	// AllowedUpdates
	// A list of update types the bot is subscribed to. Defaults to all update types except
	// chat_member
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// IPAddress
	// Currently used webhook IP address
	IPAddress *string `json:"ip_address,omitempty"`
	// LastErrorDate
	// Unix time for the most recent error that happened when trying to deliver an update via
	// webhook
	LastErrorDate *int64 `json:"last_error_date,omitempty"`
	// LastErrorMessage
	// Error message in human-readable format for the most recent error that happened when trying
	// to deliver an update via webhook
	LastErrorMessage *string `json:"last_error_message,omitempty"`
	// LastSynchronizationErrorDate
	// Unix time of the most recent error that happened when trying to synchronize available
	// updates with Telegram datacenters
	LastSynchronizationErrorDate *int64 `json:"last_synchronization_error_date,omitempty"`
	// MaxConnections
	// The maximum allowed number of simultaneous HTTPS connections to the webhook for update
	// delivery
	MaxConnections *int64 `json:"max_connections,omitempty"`
}

func (t *WebhookInfo) GetHasCustomCertificate() bool {
	var res bool
	if t == nil {
		return res
	}
	return t.HasCustomCertificate
}

func (t *WebhookInfo) GetIPAddress() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.IPAddress; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetLastErrorDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LastErrorDate; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetLastErrorMessage() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.LastErrorMessage; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetLastSynchronizationErrorDate() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.LastSynchronizationErrorDate; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetMaxConnections() int64 {
	var res int64
	if t == nil {
		return res
	}
	if field := t.MaxConnections; field != nil {
		return *field
	}
	return res
}

func (t *WebhookInfo) GetPendingUpdateCount() int64 {
	var res int64
	if t == nil {
		return res
	}
	return t.PendingUpdateCount
}

func (t *WebhookInfo) GetURL() string {
	var res string
	if t == nil {
		return res
	}
	return t.URL
}

// WriteAccessAllowed
// This object represents a service message about a user allowing a bot to write messages after
// adding the bot to the attachment menu or launching a Web App from a link.
type WriteAccessAllowed struct {
	// WebAppName
	// Name of the Web App which was launched from a link
	WebAppName *string `json:"web_app_name,omitempty"`
}

func (t *WriteAccessAllowed) GetWebAppName() string {
	var res string
	if t == nil {
		return res
	}
	if field := t.WebAppName; field != nil {
		return *field
	}
	return res
}
